{
  "version": 3,
  "sources": ["../bundle-1Iwz8Z/strip-cf-connecting-ip-header.js", "../../../node_modules/unenv/dist/runtime/_internal/utils.mjs", "../../../node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs", "../../../node_modules/unenv/dist/runtime/node/perf_hooks.mjs", "../../../node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs", "../../../node_modules/unenv/dist/runtime/mock/noop.mjs", "../../../node_modules/unenv/dist/runtime/node/console.mjs", "../../../node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs", "../../../node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console", "../../../node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs", "../../../node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs", "../../../node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs", "../../../node_modules/unenv/dist/runtime/node/tty.mjs", "../../../node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs", "../../../node_modules/unenv/dist/runtime/node/internal/process/process.mjs", "../../../node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs", "../../../node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process", "wrangler-modules-watch:wrangler:modules-watch", "../../../node_modules/wrangler/templates/modules-watch-stub.js", "../../../node_modules/uri-js/src/index.ts", "../../../node_modules/uri-js/src/schemes/urn-uuid.ts", "../../../node_modules/uri-js/src/schemes/urn.ts", "../../../node_modules/uri-js/src/schemes/mailto.ts", "../../../node_modules/uri-js/src/schemes/wss.ts", "../../../node_modules/uri-js/src/schemes/ws.ts", "../../../node_modules/uri-js/src/schemes/https.ts", "../../../node_modules/uri-js/src/schemes/http.ts", "../../../node_modules/uri-js/src/uri.ts", "../../../node_modules/uri-js/node_modules/punycode/punycode.es6.js", "../../../node_modules/uri-js/src/regexps-iri.ts", "../../../node_modules/uri-js/src/regexps-uri.ts", "../../../node_modules/uri-js/src/util.ts", "../../../node_modules/fast-deep-equal/index.js", "../../../node_modules/ajv/lib/compile/ucs2length.js", "../../../node_modules/ajv/lib/compile/util.js", "../../../node_modules/ajv/lib/compile/schema_obj.js", "../../../node_modules/json-schema-traverse/index.js", "../../../node_modules/ajv/lib/compile/resolve.js", "../../../node_modules/ajv/lib/compile/error_classes.js", "../../../node_modules/fast-json-stable-stringify/index.js", "../../../node_modules/ajv/lib/dotjs/validate.js", "../../../node_modules/ajv/lib/compile/index.js", "../../../node_modules/ajv/lib/cache.js", "../../../node_modules/ajv/lib/compile/formats.js", "../../../node_modules/ajv/lib/dotjs/ref.js", "../../../node_modules/ajv/lib/dotjs/allOf.js", "../../../node_modules/ajv/lib/dotjs/anyOf.js", "../../../node_modules/ajv/lib/dotjs/comment.js", "../../../node_modules/ajv/lib/dotjs/const.js", "../../../node_modules/ajv/lib/dotjs/contains.js", "../../../node_modules/ajv/lib/dotjs/dependencies.js", "../../../node_modules/ajv/lib/dotjs/enum.js", "../../../node_modules/ajv/lib/dotjs/format.js", "../../../node_modules/ajv/lib/dotjs/if.js", "../../../node_modules/ajv/lib/dotjs/items.js", "../../../node_modules/ajv/lib/dotjs/_limit.js", "../../../node_modules/ajv/lib/dotjs/_limitItems.js", "../../../node_modules/ajv/lib/dotjs/_limitLength.js", "../../../node_modules/ajv/lib/dotjs/_limitProperties.js", "../../../node_modules/ajv/lib/dotjs/multipleOf.js", "../../../node_modules/ajv/lib/dotjs/not.js", "../../../node_modules/ajv/lib/dotjs/oneOf.js", "../../../node_modules/ajv/lib/dotjs/pattern.js", "../../../node_modules/ajv/lib/dotjs/properties.js", "../../../node_modules/ajv/lib/dotjs/propertyNames.js", "../../../node_modules/ajv/lib/dotjs/required.js", "../../../node_modules/ajv/lib/dotjs/uniqueItems.js", "../../../node_modules/ajv/lib/dotjs/index.js", "../../../node_modules/ajv/lib/compile/rules.js", "../../../node_modules/ajv/lib/data.js", "../../../node_modules/ajv/lib/compile/async.js", "../../../node_modules/ajv/lib/dotjs/custom.js", "../../../node_modules/ajv/lib/refs/json-schema-draft-07.json", "../../../node_modules/ajv/lib/definition_schema.js", "../../../node_modules/ajv/lib/keyword.js", "../../../node_modules/ajv/lib/refs/data.json", "../../../node_modules/ajv/lib/ajv.js", "../../../node_modules/secure-json-parse/index.js", "../../../node_modules/@supabase/node-fetch/browser.js", "../../../node_modules/@supabase/postgrest-js/src/PostgrestError.ts", "../../../node_modules/@supabase/postgrest-js/src/PostgrestBuilder.ts", "../../../node_modules/@supabase/postgrest-js/src/PostgrestTransformBuilder.ts", "../../../node_modules/@supabase/postgrest-js/src/PostgrestFilterBuilder.ts", "../../../node_modules/@supabase/postgrest-js/src/PostgrestQueryBuilder.ts", "../../../node_modules/@supabase/postgrest-js/src/version.ts", "../../../node_modules/@supabase/postgrest-js/src/constants.ts", "../../../node_modules/@supabase/postgrest-js/src/PostgrestClient.ts", "../../../node_modules/@supabase/postgrest-js/src/index.ts", "../../../node_modules/@supabase/realtime-js/node_modules/ws/browser.js", "../bundle-1Iwz8Z/middleware-loader.entry.ts", "../bundle-1Iwz8Z/middleware-insertion-facade.js", "../../../src/index.ts", "../../../node_modules/@modelcontextprotocol/sdk/src/client/sse.ts", "../../../node_modules/eventsource-parser/src/errors.ts", "../../../node_modules/eventsource-parser/src/parse.ts", "../../../node_modules/eventsource/src/errors.ts", "../../../node_modules/eventsource/src/EventSource.ts", "../../../node_modules/@modelcontextprotocol/sdk/src/types.ts", "../../../node_modules/zod/dist/esm/index.js", "../../../node_modules/zod/dist/esm/v3/index.js", "../../../node_modules/zod/dist/esm/v3/external.js", "../../../node_modules/zod/dist/esm/v3/errors.js", "../../../node_modules/zod/dist/esm/v3/locales/en.js", "../../../node_modules/zod/dist/esm/v3/ZodError.js", "../../../node_modules/zod/dist/esm/v3/helpers/util.js", "../../../node_modules/zod/dist/esm/v3/helpers/parseUtil.js", "../../../node_modules/zod/dist/esm/v3/helpers/typeAliases.js", "../../../node_modules/zod/dist/esm/v3/types.js", "../../../node_modules/zod/dist/esm/v3/helpers/errorUtil.js", "../../../node_modules/@modelcontextprotocol/sdk/src/client/auth.ts", "../../../node_modules/pkce-challenge/dist/index.browser.js", "../../../node_modules/@modelcontextprotocol/sdk/src/shared/auth.ts", "../../../node_modules/@modelcontextprotocol/sdk/src/client/index.ts", "../../../node_modules/@modelcontextprotocol/sdk/src/shared/protocol.ts", "../../../node_modules/@ai-sdk/provider/src/errors/ai-sdk-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/api-call-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/empty-response-body-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/get-error-message.ts", "../../../node_modules/@ai-sdk/provider/src/errors/invalid-argument-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/invalid-prompt-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/invalid-response-data-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/json-parse-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/load-api-key-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/load-setting-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/no-content-generated-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/no-such-model-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/too-many-embedding-values-for-call-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/type-validation-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/unsupported-functionality-error.ts", "../../../node_modules/@ai-sdk/provider/src/json-value/is-json.ts", "../../../node_modules/@ai-sdk/provider-utils/node_modules/nanoid/non-secure/index.js", "../../../node_modules/@ai-sdk/provider-utils/src/combine-headers.ts", "../../../node_modules/@ai-sdk/provider-utils/src/convert-async-iterator-to-readable-stream.ts", "../../../node_modules/@ai-sdk/provider-utils/src/delay.ts", "../../../node_modules/@ai-sdk/provider-utils/src/event-source-parser-stream.ts", "../../../node_modules/@ai-sdk/provider-utils/src/extract-response-headers.ts", "../../../node_modules/@ai-sdk/provider-utils/src/generate-id.ts", "../../../node_modules/@ai-sdk/provider-utils/src/get-error-message.ts", "../../../node_modules/@ai-sdk/provider-utils/src/get-from-api.ts", "../../../node_modules/@ai-sdk/provider-utils/src/remove-undefined-entries.ts", "../../../node_modules/@ai-sdk/provider-utils/src/is-abort-error.ts", "../../../node_modules/@ai-sdk/provider-utils/src/load-api-key.ts", "../../../node_modules/@ai-sdk/provider-utils/src/load-optional-setting.ts", "../../../node_modules/@ai-sdk/provider-utils/src/load-setting.ts", "../../../node_modules/@ai-sdk/provider-utils/src/parse-json.ts", "../../../node_modules/@ai-sdk/provider-utils/src/validate-types.ts", "../../../node_modules/@ai-sdk/provider-utils/src/validator.ts", "../../../node_modules/@ai-sdk/provider-utils/src/parse-provider-options.ts", "../../../node_modules/@ai-sdk/provider-utils/src/post-to-api.ts", "../../../node_modules/@ai-sdk/provider-utils/src/resolve.ts", "../../../node_modules/@ai-sdk/provider-utils/src/response-handler.ts", "../../../node_modules/@ai-sdk/provider-utils/src/uint8-utils.ts", "../../../node_modules/@ai-sdk/provider-utils/src/without-trailing-slash.ts", "../../../node_modules/zod-to-json-schema/dist/esm/index.js", "../../../node_modules/zod-to-json-schema/dist/esm/Options.js", "../../../node_modules/zod-to-json-schema/dist/esm/Refs.js", "../../../node_modules/zod-to-json-schema/dist/esm/errorMessages.js", "../../../node_modules/zod-to-json-schema/dist/esm/parseDef.js", "../../../node_modules/zod-to-json-schema/dist/esm/selectParser.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/any.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/array.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/branded.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/catch.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/date.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/default.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/effects.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/enum.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/literal.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/map.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/record.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/string.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/never.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/null.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/union.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/number.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/object.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/optional.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/promise.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/set.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js", "../../../node_modules/zod-to-json-schema/dist/esm/parseTypes.js", "../../../node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js", "../../../node_modules/@ai-sdk/ui-utils/src/index.ts", "../../../node_modules/@ai-sdk/ui-utils/src/assistant-stream-parts.ts", "../../../node_modules/@ai-sdk/ui-utils/src/process-chat-response.ts", "../../../node_modules/@ai-sdk/ui-utils/src/duplicated/usage.ts", "../../../node_modules/@ai-sdk/ui-utils/src/parse-partial-json.ts", "../../../node_modules/@ai-sdk/ui-utils/src/fix-json.ts", "../../../node_modules/@ai-sdk/ui-utils/src/data-stream-parts.ts", "../../../node_modules/@ai-sdk/ui-utils/src/process-data-stream.ts", "../../../node_modules/@ai-sdk/ui-utils/src/process-chat-text-response.ts", "../../../node_modules/@ai-sdk/ui-utils/src/process-text-stream.ts", "../../../node_modules/@ai-sdk/ui-utils/src/call-chat-api.ts", "../../../node_modules/@ai-sdk/ui-utils/src/call-completion-api.ts", "../../../node_modules/@ai-sdk/ui-utils/src/data-url.ts", "../../../node_modules/@ai-sdk/ui-utils/src/extract-max-tool-invocation-step.ts", "../../../node_modules/@ai-sdk/ui-utils/src/get-message-parts.ts", "../../../node_modules/@ai-sdk/ui-utils/src/fill-message-parts.ts", "../../../node_modules/@ai-sdk/ui-utils/src/is-deep-equal-data.ts", "../../../node_modules/@ai-sdk/ui-utils/src/prepare-attachments-for-request.ts", "../../../node_modules/@ai-sdk/ui-utils/src/process-assistant-stream.ts", "../../../node_modules/@ai-sdk/ui-utils/src/schema.ts", "../../../node_modules/@ai-sdk/ui-utils/src/zod-schema.ts", "../../../node_modules/@ai-sdk/ui-utils/src/should-resubmit-messages.ts", "../../../node_modules/@ai-sdk/ui-utils/src/update-tool-call-result.ts", "../../../node_modules/ai/core/index.ts", "../../../node_modules/ai/core/data-stream/create-data-stream.ts", "../../../node_modules/ai/core/util/prepare-response-headers.ts", "../../../node_modules/ai/core/data-stream/create-data-stream-response.ts", "../../../node_modules/ai/core/util/prepare-outgoing-http-headers.ts", "../../../node_modules/ai/core/util/write-to-server-response.ts", "../../../node_modules/ai/core/data-stream/pipe-data-stream-to-response.ts", "../../../node_modules/ai/errors/invalid-argument-error.ts", "../../../node_modules/ai/util/retry-with-exponential-backoff.ts", "../../../node_modules/ai/util/retry-error.ts", "../../../node_modules/ai/core/prompt/prepare-retries.ts", "../../../node_modules/ai/core/telemetry/assemble-operation-name.ts", "../../../node_modules/ai/core/telemetry/get-base-telemetry-attributes.ts", "../../../node_modules/ai/core/telemetry/get-tracer.ts", "../../../node_modules/ai/core/telemetry/noop-tracer.ts", "../../../node_modules/ai/core/telemetry/record-span.ts", "../../../node_modules/ai/core/telemetry/select-telemetry-attributes.ts", "../../../node_modules/ai/core/embed/embed.ts", "../../../node_modules/ai/core/util/split-array.ts", "../../../node_modules/ai/core/embed/embed-many.ts", "../../../node_modules/ai/errors/no-image-generated-error.ts", "../../../node_modules/ai/core/generate-text/generated-file.ts", "../../../node_modules/ai/core/util/detect-mimetype.ts", "../../../node_modules/ai/core/generate-image/generate-image.ts", "../../../node_modules/ai/core/generate-object/generate-object.ts", "../../../node_modules/ai/errors/no-object-generated-error.ts", "../../../node_modules/ai/util/download-error.ts", "../../../node_modules/ai/util/download.ts", "../../../node_modules/ai/core/prompt/data-content.ts", "../../../node_modules/ai/core/prompt/invalid-data-content-error.ts", "../../../node_modules/ai/core/prompt/invalid-message-role-error.ts", "../../../node_modules/ai/core/prompt/split-data-url.ts", "../../../node_modules/ai/core/prompt/convert-to-language-model-prompt.ts", "../../../node_modules/ai/core/prompt/prepare-call-settings.ts", "../../../node_modules/ai/core/prompt/standardize-prompt.ts", "../../../node_modules/ai/core/prompt/attachments-to-parts.ts", "../../../node_modules/ai/core/prompt/message-conversion-error.ts", "../../../node_modules/ai/core/prompt/convert-to-core-messages.ts", "../../../node_modules/ai/core/prompt/message.ts", "../../../node_modules/ai/core/types/provider-metadata.ts", "../../../node_modules/ai/core/types/json-value.ts", "../../../node_modules/ai/core/prompt/content-part.ts", "../../../node_modules/ai/core/prompt/tool-result-content.ts", "../../../node_modules/ai/core/types/usage.ts", "../../../node_modules/ai/core/generate-object/inject-json-instruction.ts", "../../../node_modules/ai/core/generate-object/output-strategy.ts", "../../../node_modules/ai/core/util/async-iterable-stream.ts", "../../../node_modules/ai/core/generate-object/validate-object-generation-input.ts", "../../../node_modules/ai/core/prompt/stringify-for-telemetry.ts", "../../../node_modules/ai/core/generate-object/stream-object.ts", "../../../node_modules/ai/util/delayed-promise.ts", "../../../node_modules/ai/util/create-resolvable-promise.ts", "../../../node_modules/ai/core/util/create-stitchable-stream.ts", "../../../node_modules/ai/core/util/now.ts", "../../../node_modules/ai/core/generate-text/generate-text.ts", "../../../node_modules/ai/errors/no-output-specified-error.ts", "../../../node_modules/ai/errors/tool-execution-error.ts", "../../../node_modules/ai/core/prompt/prepare-tools-and-tool-choice.ts", "../../../node_modules/ai/core/util/is-non-empty-object.ts", "../../../node_modules/ai/core/util/split-on-last-whitespace.ts", "../../../node_modules/ai/core/util/remove-text-after-last-whitespace.ts", "../../../node_modules/ai/core/generate-text/parse-tool-call.ts", "../../../node_modules/ai/errors/invalid-tool-arguments-error.ts", "../../../node_modules/ai/errors/no-such-tool-error.ts", "../../../node_modules/ai/errors/tool-call-repair-error.ts", "../../../node_modules/ai/core/generate-text/reasoning-detail.ts", "../../../node_modules/ai/core/generate-text/to-response-messages.ts", "../../../node_modules/ai/core/generate-text/output.ts", "../../../node_modules/ai/errors/index.ts", "../../../node_modules/ai/errors/invalid-stream-part-error.ts", "../../../node_modules/ai/errors/mcp-client-error.ts", "../../../node_modules/ai/core/generate-text/smooth-stream.ts", "../../../node_modules/ai/core/generate-text/stream-text.ts", "../../../node_modules/ai/util/as-array.ts", "../../../node_modules/ai/util/consume-stream.ts", "../../../node_modules/ai/core/util/merge-streams.ts", "../../../node_modules/ai/core/generate-text/run-tools-transformation.ts", "../../../node_modules/ai/errors/no-speech-generated-error.ts", "../../../node_modules/ai/core/generate-speech/generated-audio-file.ts", "../../../node_modules/ai/core/generate-speech/generate-speech.ts", "../../../node_modules/ai/errors/no-transcript-generated-error.ts", "../../../node_modules/ai/core/transcribe/transcribe.ts", "../../../node_modules/ai/core/util/merge-objects.ts", "../../../node_modules/ai/core/middleware/default-settings-middleware.ts", "../../../node_modules/ai/core/util/get-potential-start-index.ts", "../../../node_modules/ai/core/middleware/extract-reasoning-middleware.ts", "../../../node_modules/ai/core/middleware/simulate-streaming-middleware.ts", "../../../node_modules/ai/core/middleware/wrap-language-model.ts", "../../../node_modules/ai/core/prompt/append-client-message.ts", "../../../node_modules/ai/core/prompt/append-response-messages.ts", "../../../node_modules/ai/core/registry/custom-provider.ts", "../../../node_modules/ai/core/registry/no-such-provider-error.ts", "../../../node_modules/ai/core/registry/provider-registry.ts", "../../../node_modules/ai/core/tool/mcp/mcp-client.ts", "../../../node_modules/ai/core/tool/tool.ts", "../../../node_modules/ai/core/tool/mcp/mcp-sse-transport.ts", "../../../node_modules/ai/core/tool/mcp/json-rpc-message.ts", "../../../node_modules/ai/core/tool/mcp/types.ts", "../../../node_modules/ai/core/tool/mcp/mcp-transport.ts", "../../../node_modules/ai/core/util/cosine-similarity.ts", "../../../node_modules/ai/core/util/simulate-readable-stream.ts", "../../../node_modules/ai/streams/assistant-response.ts", "../../../node_modules/ai/streams/langchain-adapter.ts", "../../../node_modules/ai/streams/stream-callbacks.ts", "../../../node_modules/ai/streams/llamaindex-adapter.ts", "../../../node_modules/ai/streams/stream-data.ts", "../../../node_modules/ai/util/constants.ts", "../../../node_modules/nanoid/index.browser.js", "../../../node_modules/nanoid/url-alphabet/index.js", "../../../node_modules/agents/src/mcp/sse-edge.ts", "../../../node_modules/agents/src/mcp/client-connection.ts", "../../../node_modules/agents/src/mcp/client.ts", "../../../node_modules/agents/src/mcp/do-oauth-client-provider.ts", "../../../node_modules/partysocket/dist/index.mjs", "../../../node_modules/partysocket/src/ws.ts", "../../../node_modules/agents/src/client.ts", "../../../node_modules/partyserver/src/index.ts", "../../../node_modules/partyserver/src/connection.ts", "../../../node_modules/cron-schedule/src/cron-parser.ts", "../../../node_modules/cron-schedule/src/cron.ts", "../../../node_modules/cron-schedule/src/utils.ts", "../../../node_modules/@cloudflare/unenv-preset/dist/runtime/node/async_hooks.mjs", "../../../node_modules/agents/src/index.ts", "../../../node_modules/agents/src/mcp/index.ts", "../../../node_modules/@modelcontextprotocol/sdk/src/server/mcp.ts", "../../../node_modules/@modelcontextprotocol/sdk/src/server/index.ts", "../../../node_modules/@modelcontextprotocol/sdk/src/server/completable.ts", "../../../node_modules/@modelcontextprotocol/sdk/src/shared/uriTemplate.ts", "../../../node_modules/@supabase/supabase-js/src/index.ts", "../../../node_modules/@supabase/functions-js/src/index.ts", "../../../node_modules/@supabase/functions-js/src/helper.ts", "../../../node_modules/@supabase/functions-js/src/types.ts", "../../../node_modules/@supabase/functions-js/src/FunctionsClient.ts", "../../../node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs", "../../../node_modules/@supabase/realtime-js/src/index.ts", "../../../node_modules/@supabase/realtime-js/src/RealtimeClient.ts", "../../../node_modules/@supabase/realtime-js/src/WebSocket.ts", "../../../node_modules/@supabase/realtime-js/src/lib/constants.ts", "../../../node_modules/@supabase/realtime-js/src/lib/version.ts", "../../../node_modules/@supabase/realtime-js/src/lib/serializer.ts", "../../../node_modules/@supabase/realtime-js/src/lib/timer.ts", "../../../node_modules/@supabase/realtime-js/src/lib/transformers.ts", "../../../node_modules/@supabase/realtime-js/src/RealtimeChannel.ts", "../../../node_modules/@supabase/realtime-js/src/lib/push.ts", "../../../node_modules/@supabase/realtime-js/src/RealtimePresence.ts", "../../../node_modules/@supabase/storage-js/src/index.ts", "../../../node_modules/@supabase/storage-js/src/StorageClient.ts", "../../../node_modules/@supabase/storage-js/src/lib/errors.ts", "../../../node_modules/@supabase/storage-js/src/lib/helpers.ts", "../../../node_modules/@supabase/storage-js/src/lib/fetch.ts", "../../../node_modules/@supabase/storage-js/src/packages/StorageFileApi.ts", "../../../node_modules/@supabase/storage-js/src/lib/constants.ts", "../../../node_modules/@supabase/storage-js/src/lib/version.ts", "../../../node_modules/@supabase/storage-js/src/packages/StorageBucketApi.ts", "../../../node_modules/@supabase/supabase-js/src/lib/constants.ts", "../../../node_modules/@supabase/supabase-js/src/lib/version.ts", "../../../node_modules/@supabase/supabase-js/src/lib/fetch.ts", "../../../node_modules/@supabase/supabase-js/src/lib/helpers.ts", "../../../node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts", "../../../node_modules/@supabase/auth-js/src/index.ts", "../../../node_modules/@supabase/auth-js/src/lib/constants.ts", "../../../node_modules/@supabase/auth-js/src/lib/version.ts", "../../../node_modules/@supabase/auth-js/src/lib/helpers.ts", "../../../node_modules/@supabase/auth-js/src/lib/errors.ts", "../../../node_modules/@supabase/auth-js/src/lib/base64url.ts", "../../../node_modules/@supabase/auth-js/src/lib/fetch.ts", "../../../node_modules/@supabase/auth-js/src/lib/types.ts", "../../../node_modules/@supabase/auth-js/src/GoTrueAdminApi.ts", "../../../node_modules/@supabase/auth-js/src/GoTrueClient.ts", "../../../node_modules/@supabase/auth-js/src/lib/local-storage.ts", "../../../node_modules/@supabase/auth-js/src/lib/polyfills.ts", "../../../node_modules/@supabase/auth-js/src/lib/locks.ts", "../../../node_modules/@supabase/auth-js/src/AuthAdminApi.ts", "../../../node_modules/@supabase/auth-js/src/AuthClient.ts", "../../../node_modules/@supabase/supabase-js/src/SupabaseClient.ts", "../../../src/components/secret.ts", "../../../src/components/layer.ts", "../../../src/components/get_outfit_details.ts", "../../../src/components/calculate_outfit_warmth.ts", "../../../src/components/get_logs.ts", "../../../src/components/get_weather.ts", "../../../src/components/schema.ts", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../../../node_modules/wrangler/templates/middleware/common.ts"],
  "sourceRoot": "/Users/michaelsipes/Desktop/coding/layers-project/remote-mcp-server-authless/.wrangler/tmp/dev-3qTFke",
  "sourcesContent": ["function stripCfConnectingIPHeader(input, init) {\n\tconst request = new Request(input, init);\n\trequest.headers.delete(\"CF-Connecting-IP\");\n\treturn request;\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\treturn Reflect.apply(target, thisArg, [\n\t\t\tstripCfConnectingIPHeader.apply(null, argArray),\n\t\t]);\n\t},\n});\n", "/* @__NO_SIDE_EFFECTS__ */\nexport function rawHeaders(headers) {\n\tconst rawHeaders = [];\n\tfor (const key in headers) {\n\t\tif (Array.isArray(headers[key])) {\n\t\t\tfor (const h of headers[key]) {\n\t\t\t\trawHeaders.push(key, h);\n\t\t\t}\n\t\t} else {\n\t\t\trawHeaders.push(key, headers[key]);\n\t\t}\n\t}\n\treturn rawHeaders;\n}\n/* @__NO_SIDE_EFFECTS__ */\nexport function mergeFns(...functions) {\n\treturn function(...args) {\n\t\tfor (const fn of functions) {\n\t\t\tfn(...args);\n\t\t}\n\t};\n}\n/* @__NO_SIDE_EFFECTS__ */\nexport function createNotImplementedError(name) {\n\treturn new Error(`[unenv] ${name} is not implemented yet!`);\n}\n/* @__NO_SIDE_EFFECTS__ */\nexport function notImplemented(name) {\n\tconst fn = () => {\n\t\tthrow createNotImplementedError(name);\n\t};\n\treturn Object.assign(fn, { __unenv__: true });\n}\n/* @__NO_SIDE_EFFECTS__ */\nexport function notImplementedAsync(name) {\n\tconst fn = notImplemented(name);\n\tfn.__promisify__ = () => notImplemented(name + \".__promisify__\");\n\tfn.native = fn;\n\treturn fn;\n}\n/* @__NO_SIDE_EFFECTS__ */\nexport function notImplementedClass(name) {\n\treturn class {\n\t\t__unenv__ = true;\n\t\tconstructor() {\n\t\t\tthrow new Error(`[unenv] ${name} is not implemented yet!`);\n\t\t}\n\t};\n}\n", "import { createNotImplementedError } from \"../../../_internal/utils.mjs\";\nconst _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();\nconst _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;\nconst nodeTiming = {\n\tname: \"node\",\n\tentryType: \"node\",\n\tstartTime: 0,\n\tduration: 0,\n\tnodeStart: 0,\n\tv8Start: 0,\n\tbootstrapComplete: 0,\n\tenvironment: 0,\n\tloopStart: 0,\n\tloopExit: 0,\n\tidleTime: 0,\n\tuvMetricsInfo: {\n\t\tloopCount: 0,\n\t\tevents: 0,\n\t\teventsWaiting: 0\n\t},\n\tdetail: undefined,\n\ttoJSON() {\n\t\treturn this;\n\t}\n};\nexport class PerformanceEntry {\n\t__unenv__ = true;\n\tdetail;\n\tentryType = \"event\";\n\tname;\n\tstartTime;\n\tconstructor(name, options) {\n\t\tthis.name = name;\n\t\tthis.startTime = options?.startTime || _performanceNow();\n\t\tthis.detail = options?.detail;\n\t}\n\tget duration() {\n\t\treturn _performanceNow() - this.startTime;\n\t}\n\ttoJSON() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tentryType: this.entryType,\n\t\t\tstartTime: this.startTime,\n\t\t\tduration: this.duration,\n\t\t\tdetail: this.detail\n\t\t};\n\t}\n}\nexport const PerformanceMark = class PerformanceMark extends PerformanceEntry {\n\tentryType = \"mark\";\n\tconstructor() {\n\t\tsuper(...arguments);\n\t}\n\tget duration() {\n\t\treturn 0;\n\t}\n};\nexport class PerformanceMeasure extends PerformanceEntry {\n\tentryType = \"measure\";\n}\nexport class PerformanceResourceTiming extends PerformanceEntry {\n\tentryType = \"resource\";\n\tserverTiming = [];\n\tconnectEnd = 0;\n\tconnectStart = 0;\n\tdecodedBodySize = 0;\n\tdomainLookupEnd = 0;\n\tdomainLookupStart = 0;\n\tencodedBodySize = 0;\n\tfetchStart = 0;\n\tinitiatorType = \"\";\n\tname = \"\";\n\tnextHopProtocol = \"\";\n\tredirectEnd = 0;\n\tredirectStart = 0;\n\trequestStart = 0;\n\tresponseEnd = 0;\n\tresponseStart = 0;\n\tsecureConnectionStart = 0;\n\tstartTime = 0;\n\ttransferSize = 0;\n\tworkerStart = 0;\n\tresponseStatus = 0;\n}\nexport class PerformanceObserverEntryList {\n\t__unenv__ = true;\n\tgetEntries() {\n\t\treturn [];\n\t}\n\tgetEntriesByName(_name, _type) {\n\t\treturn [];\n\t}\n\tgetEntriesByType(type) {\n\t\treturn [];\n\t}\n}\nexport class Performance {\n\t__unenv__ = true;\n\ttimeOrigin = _timeOrigin;\n\teventCounts = new Map();\n\t_entries = [];\n\t_resourceTimingBufferSize = 0;\n\tnavigation = undefined;\n\ttiming = undefined;\n\ttimerify(_fn, _options) {\n\t\tthrow createNotImplementedError(\"Performance.timerify\");\n\t}\n\tget nodeTiming() {\n\t\treturn nodeTiming;\n\t}\n\teventLoopUtilization() {\n\t\treturn {};\n\t}\n\tmarkResourceTiming() {\n\t\treturn new PerformanceResourceTiming(\"\");\n\t}\n\tonresourcetimingbufferfull = null;\n\tnow() {\n\t\tif (this.timeOrigin === _timeOrigin) {\n\t\t\treturn _performanceNow();\n\t\t}\n\t\treturn Date.now() - this.timeOrigin;\n\t}\n\tclearMarks(markName) {\n\t\tthis._entries = markName ? this._entries.filter((e) => e.name !== markName) : this._entries.filter((e) => e.entryType !== \"mark\");\n\t}\n\tclearMeasures(measureName) {\n\t\tthis._entries = measureName ? this._entries.filter((e) => e.name !== measureName) : this._entries.filter((e) => e.entryType !== \"measure\");\n\t}\n\tclearResourceTimings() {\n\t\tthis._entries = this._entries.filter((e) => e.entryType !== \"resource\" || e.entryType !== \"navigation\");\n\t}\n\tgetEntries() {\n\t\treturn this._entries;\n\t}\n\tgetEntriesByName(name, type) {\n\t\treturn this._entries.filter((e) => e.name === name && (!type || e.entryType === type));\n\t}\n\tgetEntriesByType(type) {\n\t\treturn this._entries.filter((e) => e.entryType === type);\n\t}\n\tmark(name, options) {\n\t\tconst entry = new PerformanceMark(name, options);\n\t\tthis._entries.push(entry);\n\t\treturn entry;\n\t}\n\tmeasure(measureName, startOrMeasureOptions, endMark) {\n\t\tlet start;\n\t\tlet end;\n\t\tif (typeof startOrMeasureOptions === \"string\") {\n\t\t\tstart = this.getEntriesByName(startOrMeasureOptions, \"mark\")[0]?.startTime;\n\t\t\tend = this.getEntriesByName(endMark, \"mark\")[0]?.startTime;\n\t\t} else {\n\t\t\tstart = Number.parseFloat(startOrMeasureOptions?.start) || this.now();\n\t\t\tend = Number.parseFloat(startOrMeasureOptions?.end) || this.now();\n\t\t}\n\t\tconst entry = new PerformanceMeasure(measureName, {\n\t\t\tstartTime: start,\n\t\t\tdetail: {\n\t\t\t\tstart,\n\t\t\t\tend\n\t\t\t}\n\t\t});\n\t\tthis._entries.push(entry);\n\t\treturn entry;\n\t}\n\tsetResourceTimingBufferSize(maxSize) {\n\t\tthis._resourceTimingBufferSize = maxSize;\n\t}\n\taddEventListener(type, listener, options) {\n\t\tthrow createNotImplementedError(\"Performance.addEventListener\");\n\t}\n\tremoveEventListener(type, listener, options) {\n\t\tthrow createNotImplementedError(\"Performance.removeEventListener\");\n\t}\n\tdispatchEvent(event) {\n\t\tthrow createNotImplementedError(\"Performance.dispatchEvent\");\n\t}\n\ttoJSON() {\n\t\treturn this;\n\t}\n}\nexport class PerformanceObserver {\n\t__unenv__ = true;\n\tstatic supportedEntryTypes = [];\n\t_callback = null;\n\tconstructor(callback) {\n\t\tthis._callback = callback;\n\t}\n\ttakeRecords() {\n\t\treturn [];\n\t}\n\tdisconnect() {\n\t\tthrow createNotImplementedError(\"PerformanceObserver.disconnect\");\n\t}\n\tobserve(options) {\n\t\tthrow createNotImplementedError(\"PerformanceObserver.observe\");\n\t}\n\tbind(fn) {\n\t\treturn fn;\n\t}\n\trunInAsyncScope(fn, thisArg, ...args) {\n\t\treturn fn.call(thisArg, ...args);\n\t}\n\tasyncId() {\n\t\treturn 0;\n\t}\n\ttriggerAsyncId() {\n\t\treturn 0;\n\t}\n\temitDestroy() {\n\t\treturn this;\n\t}\n}\nexport const performance = globalThis.performance && \"addEventListener\" in globalThis.performance ? globalThis.performance : new Performance();\n", "import { IntervalHistogram, RecordableHistogram } from \"./internal/perf_hooks/histogram.mjs\";\nimport { performance, Performance, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceObserverEntryList, PerformanceObserver, PerformanceResourceTiming } from \"./internal/perf_hooks/performance.mjs\";\nexport * from \"./internal/perf_hooks/performance.mjs\";\nimport { NODE_PERFORMANCE_GC_MAJOR, NODE_PERFORMANCE_GC_MINOR, NODE_PERFORMANCE_GC_INCREMENTAL, NODE_PERFORMANCE_GC_WEAKCB, NODE_PERFORMANCE_GC_FLAGS_NO, NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED, NODE_PERFORMANCE_GC_FLAGS_FORCED, NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING, NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE, NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY, NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE, NODE_PERFORMANCE_ENTRY_TYPE_GC, NODE_PERFORMANCE_ENTRY_TYPE_HTTP, NODE_PERFORMANCE_ENTRY_TYPE_HTTP2, NODE_PERFORMANCE_ENTRY_TYPE_NET, NODE_PERFORMANCE_ENTRY_TYPE_DNS, NODE_PERFORMANCE_MILESTONE_TIME_ORIGIN_TIMESTAMP, NODE_PERFORMANCE_MILESTONE_TIME_ORIGIN, NODE_PERFORMANCE_MILESTONE_ENVIRONMENT, NODE_PERFORMANCE_MILESTONE_NODE_START, NODE_PERFORMANCE_MILESTONE_V8_START, NODE_PERFORMANCE_MILESTONE_LOOP_START, NODE_PERFORMANCE_MILESTONE_LOOP_EXIT, NODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE } from \"./internal/perf_hooks/constants.mjs\";\nexport const constants = {\n\tNODE_PERFORMANCE_GC_MAJOR,\n\tNODE_PERFORMANCE_GC_MINOR,\n\tNODE_PERFORMANCE_GC_INCREMENTAL,\n\tNODE_PERFORMANCE_GC_WEAKCB,\n\tNODE_PERFORMANCE_GC_FLAGS_NO,\n\tNODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED,\n\tNODE_PERFORMANCE_GC_FLAGS_FORCED,\n\tNODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING,\n\tNODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE,\n\tNODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY,\n\tNODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE,\n\tNODE_PERFORMANCE_ENTRY_TYPE_GC,\n\tNODE_PERFORMANCE_ENTRY_TYPE_HTTP,\n\tNODE_PERFORMANCE_ENTRY_TYPE_HTTP2,\n\tNODE_PERFORMANCE_ENTRY_TYPE_NET,\n\tNODE_PERFORMANCE_ENTRY_TYPE_DNS,\n\tNODE_PERFORMANCE_MILESTONE_TIME_ORIGIN_TIMESTAMP,\n\tNODE_PERFORMANCE_MILESTONE_TIME_ORIGIN,\n\tNODE_PERFORMANCE_MILESTONE_ENVIRONMENT,\n\tNODE_PERFORMANCE_MILESTONE_NODE_START,\n\tNODE_PERFORMANCE_MILESTONE_V8_START,\n\tNODE_PERFORMANCE_MILESTONE_LOOP_START,\n\tNODE_PERFORMANCE_MILESTONE_LOOP_EXIT,\n\tNODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE\n};\nexport const monitorEventLoopDelay = function(_options) {\n\treturn new IntervalHistogram();\n};\nexport const createHistogram = function(_options) {\n\treturn new RecordableHistogram();\n};\nexport default {\n\tPerformance,\n\tPerformanceMark,\n\tPerformanceEntry,\n\tPerformanceMeasure,\n\tPerformanceObserverEntryList,\n\tPerformanceObserver,\n\tPerformanceResourceTiming,\n\tperformance,\n\tconstants,\n\tcreateHistogram,\n\tmonitorEventLoopDelay\n};\n", "import {\n  performance,\n  Performance,\n  PerformanceEntry,\n  PerformanceMark,\n  PerformanceMeasure,\n  PerformanceObserver,\n  PerformanceObserverEntryList,\n  PerformanceResourceTiming\n} from \"node:perf_hooks\";\nglobalThis.performance = performance;\nglobalThis.Performance = Performance;\nglobalThis.PerformanceEntry = PerformanceEntry;\nglobalThis.PerformanceMark = PerformanceMark;\nglobalThis.PerformanceMeasure = PerformanceMeasure;\nglobalThis.PerformanceObserver = PerformanceObserver;\nglobalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;\nglobalThis.PerformanceResourceTiming = PerformanceResourceTiming;\n", "export default Object.assign(() => {}, { __unenv__: true });\n", "import { Writable } from \"node:stream\";\nimport noop from \"../mock/noop.mjs\";\nimport { notImplemented, notImplementedClass } from \"../_internal/utils.mjs\";\nconst _console = globalThis.console;\nexport const _ignoreErrors = true;\nexport const _stderr = new Writable();\nexport const _stdout = new Writable();\nexport const log = _console?.log ?? noop;\nexport const info = _console?.info ?? log;\nexport const trace = _console?.trace ?? info;\nexport const debug = _console?.debug ?? log;\nexport const table = _console?.table ?? log;\nexport const error = _console?.error ?? log;\nexport const warn = _console?.warn ?? error;\nexport const createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented(\"console.createTask\");\nexport const assert = /* @__PURE__ */ notImplemented(\"console.assert\");\nexport const clear = _console?.clear ?? noop;\nexport const count = _console?.count ?? noop;\nexport const countReset = _console?.countReset ?? noop;\nexport const dir = _console?.dir ?? noop;\nexport const dirxml = _console?.dirxml ?? noop;\nexport const group = _console?.group ?? noop;\nexport const groupEnd = _console?.groupEnd ?? noop;\nexport const groupCollapsed = _console?.groupCollapsed ?? noop;\nexport const profile = _console?.profile ?? noop;\nexport const profileEnd = _console?.profileEnd ?? noop;\nexport const time = _console?.time ?? noop;\nexport const timeEnd = _console?.timeEnd ?? noop;\nexport const timeLog = _console?.timeLog ?? noop;\nexport const timeStamp = _console?.timeStamp ?? noop;\nexport const Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass(\"console.Console\");\nexport const _times = /* @__PURE__ */ new Map();\nexport function context() {\n\treturn _console;\n}\nexport const _stdoutErrorHandler = noop;\nexport const _stderrErrorHandler = noop;\nexport default {\n\t_times,\n\t_ignoreErrors,\n\t_stdoutErrorHandler,\n\t_stderrErrorHandler,\n\t_stdout,\n\t_stderr,\n\tassert,\n\tclear,\n\tConsole,\n\tcount,\n\tcountReset,\n\tdebug,\n\tdir,\n\tdirxml,\n\terror,\n\tcontext,\n\tcreateTask,\n\tgroup,\n\tgroupEnd,\n\tgroupCollapsed,\n\tinfo,\n\tlog,\n\tprofile,\n\tprofileEnd,\n\ttable,\n\ttime,\n\ttimeEnd,\n\ttimeLog,\n\ttimeStamp,\n\ttrace,\n\twarn\n};\n", "import {\n  _ignoreErrors,\n  _stderr,\n  _stderrErrorHandler,\n  _stdout,\n  _stdoutErrorHandler,\n  _times,\n  Console\n} from \"unenv/node/console\";\nexport {\n  Console,\n  _ignoreErrors,\n  _stderr,\n  _stderrErrorHandler,\n  _stdout,\n  _stdoutErrorHandler,\n  _times\n} from \"unenv/node/console\";\nconst workerdConsole = globalThis[\"console\"];\nexport const {\n  assert,\n  clear,\n  // @ts-expect-error undocumented public API\n  context,\n  count,\n  countReset,\n  // @ts-expect-error undocumented public API\n  createTask,\n  debug,\n  dir,\n  dirxml,\n  error,\n  group,\n  groupCollapsed,\n  groupEnd,\n  info,\n  log,\n  profile,\n  profileEnd,\n  table,\n  time,\n  timeEnd,\n  timeLog,\n  timeStamp,\n  trace,\n  warn\n} = workerdConsole;\nObject.assign(workerdConsole, {\n  Console,\n  _ignoreErrors,\n  _stderr,\n  _stderrErrorHandler,\n  _stdout,\n  _stdoutErrorHandler,\n  _times\n});\nexport default workerdConsole;\n", "import { default as defaultExport } from \"@cloudflare/unenv-preset/node/console\";\nglobalThis.console = defaultExport;", "export const hrtime = /* @__PURE__ */ Object.assign(function hrtime(startTime) {\n\tconst now = Date.now();\n\tconst seconds = Math.trunc(now / 1e3);\n\tconst nanos = now % 1e3 * 1e6;\n\tif (startTime) {\n\t\tlet diffSeconds = seconds - startTime[0];\n\t\tlet diffNanos = nanos - startTime[0];\n\t\tif (diffNanos < 0) {\n\t\t\tdiffSeconds = diffSeconds - 1;\n\t\t\tdiffNanos = 1e9 + diffNanos;\n\t\t}\n\t\treturn [diffSeconds, diffNanos];\n\t}\n\treturn [seconds, nanos];\n}, { bigint: function bigint() {\n\treturn BigInt(Date.now() * 1e6);\n} });\n", "export class WriteStream {\n\tfd;\n\tcolumns = 80;\n\trows = 24;\n\tisTTY = false;\n\tconstructor(fd) {\n\t\tthis.fd = fd;\n\t}\n\tclearLine(dir, callback) {\n\t\tcallback && callback();\n\t\treturn false;\n\t}\n\tclearScreenDown(callback) {\n\t\tcallback && callback();\n\t\treturn false;\n\t}\n\tcursorTo(x, y, callback) {\n\t\tcallback && typeof callback === \"function\" && callback();\n\t\treturn false;\n\t}\n\tmoveCursor(dx, dy, callback) {\n\t\tcallback && callback();\n\t\treturn false;\n\t}\n\tgetColorDepth(env) {\n\t\treturn 1;\n\t}\n\thasColors(count, env) {\n\t\treturn false;\n\t}\n\tgetWindowSize() {\n\t\treturn [this.columns, this.rows];\n\t}\n\twrite(str, encoding, cb) {\n\t\tif (str instanceof Uint8Array) {\n\t\t\tstr = new TextDecoder().decode(str);\n\t\t}\n\t\ttry {\n\t\t\tconsole.log(str);\n\t\t} catch {}\n\t\tcb && typeof cb === \"function\" && cb();\n\t\treturn false;\n\t}\n}\n", "export class ReadStream {\n\tfd;\n\tisRaw = false;\n\tisTTY = false;\n\tconstructor(fd) {\n\t\tthis.fd = fd;\n\t}\n\tsetRawMode(mode) {\n\t\tthis.isRaw = mode;\n\t\treturn this;\n\t}\n}\n", "import { WriteStream } from \"./internal/tty/write-stream.mjs\";\nexport { ReadStream } from \"./internal/tty/read-stream.mjs\";\nexport { WriteStream } from \"./internal/tty/write-stream.mjs\";\nexport const isatty = function() {\n\treturn false;\n};\nexport default {\n\tReadStream: WriteStream,\n\tWriteStream,\n\tisatty\n};\n", "export const NODE_VERSION = \"22.14.0\";\n", "import { EventEmitter } from \"node:events\";\nimport { ReadStream, WriteStream } from \"node:tty\";\nimport { notImplemented, createNotImplementedError } from \"../../../_internal/utils.mjs\";\nimport { NODE_VERSION } from \"./node-version.mjs\";\nexport class Process extends EventEmitter {\n\tenv;\n\thrtime;\n\tnextTick;\n\tconstructor(impl) {\n\t\tsuper();\n\t\tthis.env = impl.env;\n\t\tthis.hrtime = impl.hrtime;\n\t\tthis.nextTick = impl.nextTick;\n\t\tfor (const prop of [...Object.getOwnPropertyNames(Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {\n\t\t\tconst value = this[prop];\n\t\t\tif (typeof value === \"function\") {\n\t\t\t\tthis[prop] = value.bind(this);\n\t\t\t}\n\t\t}\n\t}\n\temitWarning(warning, type, code) {\n\t\tconsole.warn(`${code ? `[${code}] ` : \"\"}${type ? `${type}: ` : \"\"}${warning}`);\n\t}\n\temit(...args) {\n\t\treturn super.emit(...args);\n\t}\n\tlisteners(eventName) {\n\t\treturn super.listeners(eventName);\n\t}\n\t#stdin;\n\t#stdout;\n\t#stderr;\n\tget stdin() {\n\t\treturn this.#stdin ??= new ReadStream(0);\n\t}\n\tget stdout() {\n\t\treturn this.#stdout ??= new WriteStream(1);\n\t}\n\tget stderr() {\n\t\treturn this.#stderr ??= new WriteStream(2);\n\t}\n\t#cwd = \"/\";\n\tchdir(cwd) {\n\t\tthis.#cwd = cwd;\n\t}\n\tcwd() {\n\t\treturn this.#cwd;\n\t}\n\tarch = \"\";\n\tplatform = \"\";\n\targv = [];\n\targv0 = \"\";\n\texecArgv = [];\n\texecPath = \"\";\n\ttitle = \"\";\n\tpid = 200;\n\tppid = 100;\n\tget version() {\n\t\treturn `v${NODE_VERSION}`;\n\t}\n\tget versions() {\n\t\treturn { node: NODE_VERSION };\n\t}\n\tget allowedNodeEnvironmentFlags() {\n\t\treturn new Set();\n\t}\n\tget sourceMapsEnabled() {\n\t\treturn false;\n\t}\n\tget debugPort() {\n\t\treturn 0;\n\t}\n\tget throwDeprecation() {\n\t\treturn false;\n\t}\n\tget traceDeprecation() {\n\t\treturn false;\n\t}\n\tget features() {\n\t\treturn {};\n\t}\n\tget release() {\n\t\treturn {};\n\t}\n\tget connected() {\n\t\treturn false;\n\t}\n\tget config() {\n\t\treturn {};\n\t}\n\tget moduleLoadList() {\n\t\treturn [];\n\t}\n\tconstrainedMemory() {\n\t\treturn 0;\n\t}\n\tavailableMemory() {\n\t\treturn 0;\n\t}\n\tuptime() {\n\t\treturn 0;\n\t}\n\tresourceUsage() {\n\t\treturn {};\n\t}\n\tref() {}\n\tunref() {}\n\tumask() {\n\t\tthrow createNotImplementedError(\"process.umask\");\n\t}\n\tgetBuiltinModule() {\n\t\treturn undefined;\n\t}\n\tgetActiveResourcesInfo() {\n\t\tthrow createNotImplementedError(\"process.getActiveResourcesInfo\");\n\t}\n\texit() {\n\t\tthrow createNotImplementedError(\"process.exit\");\n\t}\n\treallyExit() {\n\t\tthrow createNotImplementedError(\"process.reallyExit\");\n\t}\n\tkill() {\n\t\tthrow createNotImplementedError(\"process.kill\");\n\t}\n\tabort() {\n\t\tthrow createNotImplementedError(\"process.abort\");\n\t}\n\tdlopen() {\n\t\tthrow createNotImplementedError(\"process.dlopen\");\n\t}\n\tsetSourceMapsEnabled() {\n\t\tthrow createNotImplementedError(\"process.setSourceMapsEnabled\");\n\t}\n\tloadEnvFile() {\n\t\tthrow createNotImplementedError(\"process.loadEnvFile\");\n\t}\n\tdisconnect() {\n\t\tthrow createNotImplementedError(\"process.disconnect\");\n\t}\n\tcpuUsage() {\n\t\tthrow createNotImplementedError(\"process.cpuUsage\");\n\t}\n\tsetUncaughtExceptionCaptureCallback() {\n\t\tthrow createNotImplementedError(\"process.setUncaughtExceptionCaptureCallback\");\n\t}\n\thasUncaughtExceptionCaptureCallback() {\n\t\tthrow createNotImplementedError(\"process.hasUncaughtExceptionCaptureCallback\");\n\t}\n\tinitgroups() {\n\t\tthrow createNotImplementedError(\"process.initgroups\");\n\t}\n\topenStdin() {\n\t\tthrow createNotImplementedError(\"process.openStdin\");\n\t}\n\tassert() {\n\t\tthrow createNotImplementedError(\"process.assert\");\n\t}\n\tbinding() {\n\t\tthrow createNotImplementedError(\"process.binding\");\n\t}\n\tpermission = { has: /* @__PURE__ */ notImplemented(\"process.permission.has\") };\n\treport = {\n\t\tdirectory: \"\",\n\t\tfilename: \"\",\n\t\tsignal: \"SIGUSR2\",\n\t\tcompact: false,\n\t\treportOnFatalError: false,\n\t\treportOnSignal: false,\n\t\treportOnUncaughtException: false,\n\t\tgetReport: /* @__PURE__ */ notImplemented(\"process.report.getReport\"),\n\t\twriteReport: /* @__PURE__ */ notImplemented(\"process.report.writeReport\")\n\t};\n\tfinalization = {\n\t\tregister: /* @__PURE__ */ notImplemented(\"process.finalization.register\"),\n\t\tunregister: /* @__PURE__ */ notImplemented(\"process.finalization.unregister\"),\n\t\tregisterBeforeExit: /* @__PURE__ */ notImplemented(\"process.finalization.registerBeforeExit\")\n\t};\n\tmemoryUsage = Object.assign(() => ({\n\t\tarrayBuffers: 0,\n\t\trss: 0,\n\t\texternal: 0,\n\t\theapTotal: 0,\n\t\theapUsed: 0\n\t}), { rss: () => 0 });\n\tmainModule = undefined;\n\tdomain = undefined;\n\tsend = undefined;\n\texitCode = undefined;\n\tchannel = undefined;\n\tgetegid = undefined;\n\tgeteuid = undefined;\n\tgetgid = undefined;\n\tgetgroups = undefined;\n\tgetuid = undefined;\n\tsetegid = undefined;\n\tseteuid = undefined;\n\tsetgid = undefined;\n\tsetgroups = undefined;\n\tsetuid = undefined;\n\t_events = undefined;\n\t_eventsCount = undefined;\n\t_exiting = undefined;\n\t_maxListeners = undefined;\n\t_debugEnd = undefined;\n\t_debugProcess = undefined;\n\t_fatalException = undefined;\n\t_getActiveHandles = undefined;\n\t_getActiveRequests = undefined;\n\t_kill = undefined;\n\t_preload_modules = undefined;\n\t_rawDebug = undefined;\n\t_startProfilerIdleNotifier = undefined;\n\t_stopProfilerIdleNotifier = undefined;\n\t_tickCallback = undefined;\n\t_disconnect = undefined;\n\t_handleQueue = undefined;\n\t_pendingMessage = undefined;\n\t_channel = undefined;\n\t_send = undefined;\n\t_linkedBinding = undefined;\n}\n", "import { hrtime as UnenvHrTime } from \"unenv/node/internal/process/hrtime\";\nimport { Process as UnenvProcess } from \"unenv/node/internal/process/process\";\nconst globalProcess = globalThis[\"process\"];\nexport const getBuiltinModule = globalProcess.getBuiltinModule;\nexport const { exit, platform, nextTick } = getBuiltinModule(\n  \"node:process\"\n);\nconst unenvProcess = new UnenvProcess({\n  env: globalProcess.env,\n  hrtime: UnenvHrTime,\n  nextTick\n});\nexport const {\n  abort,\n  addListener,\n  allowedNodeEnvironmentFlags,\n  hasUncaughtExceptionCaptureCallback,\n  setUncaughtExceptionCaptureCallback,\n  loadEnvFile,\n  sourceMapsEnabled,\n  arch,\n  argv,\n  argv0,\n  chdir,\n  config,\n  connected,\n  constrainedMemory,\n  availableMemory,\n  cpuUsage,\n  cwd,\n  debugPort,\n  dlopen,\n  disconnect,\n  emit,\n  emitWarning,\n  env,\n  eventNames,\n  execArgv,\n  execPath,\n  finalization,\n  features,\n  getActiveResourcesInfo,\n  getMaxListeners,\n  hrtime,\n  kill,\n  listeners,\n  listenerCount,\n  memoryUsage,\n  on,\n  off,\n  once,\n  pid,\n  ppid,\n  prependListener,\n  prependOnceListener,\n  rawListeners,\n  release,\n  removeAllListeners,\n  removeListener,\n  report,\n  resourceUsage,\n  setMaxListeners,\n  setSourceMapsEnabled,\n  stderr,\n  stdin,\n  stdout,\n  title,\n  throwDeprecation,\n  traceDeprecation,\n  umask,\n  uptime,\n  version,\n  versions,\n  domain,\n  initgroups,\n  moduleLoadList,\n  reallyExit,\n  openStdin,\n  assert,\n  binding,\n  send,\n  exitCode,\n  channel,\n  getegid,\n  geteuid,\n  getgid,\n  getgroups,\n  getuid,\n  setegid,\n  seteuid,\n  setgid,\n  setgroups,\n  setuid,\n  permission,\n  mainModule,\n  _events,\n  _eventsCount,\n  _exiting,\n  _maxListeners,\n  _debugEnd,\n  _debugProcess,\n  _fatalException,\n  _getActiveHandles,\n  _getActiveRequests,\n  _kill,\n  _preload_modules,\n  _rawDebug,\n  _startProfilerIdleNotifier,\n  _stopProfilerIdleNotifier,\n  _tickCallback,\n  _disconnect,\n  _handleQueue,\n  _pendingMessage,\n  _channel,\n  _send,\n  _linkedBinding\n} = unenvProcess;\nconst _process = {\n  abort,\n  addListener,\n  allowedNodeEnvironmentFlags,\n  hasUncaughtExceptionCaptureCallback,\n  setUncaughtExceptionCaptureCallback,\n  loadEnvFile,\n  sourceMapsEnabled,\n  arch,\n  argv,\n  argv0,\n  chdir,\n  config,\n  connected,\n  constrainedMemory,\n  availableMemory,\n  cpuUsage,\n  cwd,\n  debugPort,\n  dlopen,\n  disconnect,\n  emit,\n  emitWarning,\n  env,\n  eventNames,\n  execArgv,\n  execPath,\n  exit,\n  finalization,\n  features,\n  getBuiltinModule,\n  getActiveResourcesInfo,\n  getMaxListeners,\n  hrtime,\n  kill,\n  listeners,\n  listenerCount,\n  memoryUsage,\n  nextTick,\n  on,\n  off,\n  once,\n  pid,\n  platform,\n  ppid,\n  prependListener,\n  prependOnceListener,\n  rawListeners,\n  release,\n  removeAllListeners,\n  removeListener,\n  report,\n  resourceUsage,\n  setMaxListeners,\n  setSourceMapsEnabled,\n  stderr,\n  stdin,\n  stdout,\n  title,\n  throwDeprecation,\n  traceDeprecation,\n  umask,\n  uptime,\n  version,\n  versions,\n  // @ts-expect-error old API\n  domain,\n  initgroups,\n  moduleLoadList,\n  reallyExit,\n  openStdin,\n  assert,\n  binding,\n  send,\n  exitCode,\n  channel,\n  getegid,\n  geteuid,\n  getgid,\n  getgroups,\n  getuid,\n  setegid,\n  seteuid,\n  setgid,\n  setgroups,\n  setuid,\n  permission,\n  mainModule,\n  _events,\n  _eventsCount,\n  _exiting,\n  _maxListeners,\n  _debugEnd,\n  _debugProcess,\n  _fatalException,\n  _getActiveHandles,\n  _getActiveRequests,\n  _kill,\n  _preload_modules,\n  _rawDebug,\n  _startProfilerIdleNotifier,\n  _stopProfilerIdleNotifier,\n  _tickCallback,\n  _disconnect,\n  _handleQueue,\n  _pendingMessage,\n  _channel,\n  _send,\n  _linkedBinding\n};\nexport default _process;\n", "import { default as defaultExport } from \"@cloudflare/unenv-preset/node/process\";\nglobalThis.process = defaultExport;", "", "// `esbuild` doesn't support returning `watch*` options from `onStart()`\n// plugin callbacks. Instead, we define an empty virtual module that is\n// imported by this injected file. Importing the module registers watchers.\nimport \"wrangler:modules-watch\";\n", "import { SCHEMES } from \"./uri\";\n\nimport http from \"./schemes/http\";\nSCHEMES[http.scheme] = http;\n\nimport https from \"./schemes/https\";\nSCHEMES[https.scheme] = https;\n\nimport ws from \"./schemes/ws\";\nSCHEMES[ws.scheme] = ws;\n\nimport wss from \"./schemes/wss\";\nSCHEMES[wss.scheme] = wss;\n\nimport mailto from \"./schemes/mailto\";\nSCHEMES[mailto.scheme] = mailto;\n\nimport urn from \"./schemes/urn\";\nSCHEMES[urn.scheme] = urn;\n\nimport uuid from \"./schemes/urn-uuid\";\nSCHEMES[uuid.scheme] = uuid;\n\nexport * from \"./uri\";\n", "import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { URNComponents } from \"./urn\";\nimport { SCHEMES } from \"../uri\";\n\nexport interface UUIDComponents extends URNComponents {\n\tuuid?: string;\n}\n\nconst UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\nconst UUID_PARSE = /^[0-9A-Fa-f\\-]{36}/;\n\n//RFC 4122\nconst handler:URISchemeHandler<UUIDComponents, URIOptions, URNComponents> = {\n\tscheme : \"urn:uuid\",\n\n\tparse : function (urnComponents:URNComponents, options:URIOptions):UUIDComponents {\n\t\tconst uuidComponents = urnComponents as UUIDComponents;\n\t\tuuidComponents.uuid = uuidComponents.nss;\n\t\tuuidComponents.nss = undefined;\n\n\t\tif (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n\t\t\tuuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n\t\t}\n\n\t\treturn uuidComponents;\n\t},\n\n\tserialize : function (uuidComponents:UUIDComponents, options:URIOptions):URNComponents {\n\t\tconst urnComponents = uuidComponents as URNComponents;\n\t\t//normalize UUID\n\t\turnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n\t\treturn urnComponents;\n\t},\n};\n\nexport default handler;", "import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, SCHEMES } from \"../uri\";\n\nexport interface URNComponents extends URIComponents {\n\tnid?:string;\n\tnss?:string;\n}\n\nexport interface URNOptions extends URIOptions {\n\tnid?:string;\n}\n\nconst NID$ = \"(?:[0-9A-Za-z][0-9A-Za-z\\\\-]{1,31})\";\nconst PCT_ENCODED$ = \"(?:\\\\%[0-9A-Fa-f]{2})\";\nconst TRANS$$ = \"[0-9A-Za-z\\\\(\\\\)\\\\+\\\\,\\\\-\\\\.\\\\:\\\\=\\\\@\\\\;\\\\$\\\\_\\\\!\\\\*\\\\'\\\\/\\\\?\\\\#]\";\nconst NSS$ = \"(?:(?:\" + PCT_ENCODED$ + \"|\" + TRANS$$ + \")+)\";\nconst URN_SCHEME = new RegExp(\"^urn\\\\:(\" + NID$ + \")$\");\nconst URN_PATH = new RegExp(\"^(\" + NID$ + \")\\\\:(\" + NSS$ + \")$\");\nconst URN_PARSE = /^([^\\:]+)\\:(.*)/;\nconst URN_EXCLUDED = /[\\x00-\\x20\\\\\\\"\\&\\<\\>\\[\\]\\^\\`\\{\\|\\}\\~\\x7F-\\xFF]/g;\n\n//RFC 2141\nconst handler:URISchemeHandler<URNComponents,URNOptions> = {\n\tscheme : \"urn\",\n\n\tparse : function (components:URIComponents, options:URNOptions):URNComponents {\n\t\tconst matches = components.path && components.path.match(URN_PARSE);\n\t\tlet urnComponents = components as URNComponents;\n\n\t\tif (matches) {\n\t\t\tconst scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\t\tconst nid = matches[1].toLowerCase();\n\t\t\tconst nss = matches[2];\n\t\t\tconst urnScheme = `${scheme}:${options.nid || nid}`;\n\t\t\tconst schemeHandler = SCHEMES[urnScheme];\n\n\t\t\turnComponents.nid = nid;\n\t\t\turnComponents.nss = nss;\n\t\t\turnComponents.path = undefined;\n\n\t\t\tif (schemeHandler) {\n\t\t\t\turnComponents = schemeHandler.parse(urnComponents, options) as URNComponents;\n\t\t\t}\n\t\t} else {\n\t\t\turnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n\t\t}\n\n\t\treturn urnComponents;\n\t},\n\n\tserialize : function (urnComponents:URNComponents, options:URNOptions):URIComponents {\n\t\tconst scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\tconst nid = urnComponents.nid;\n\t\tconst urnScheme = `${scheme}:${options.nid || nid}`;\n\t\tconst schemeHandler = SCHEMES[urnScheme];\n\n\t\tif (schemeHandler) {\n\t\t\turnComponents = schemeHandler.serialize(urnComponents, options) as URNComponents;\n\t\t}\n\n\t\tconst uriComponents = urnComponents as URIComponents;\n\t\tconst nss = urnComponents.nss;\n\t\turiComponents.path = `${nid || options.nid}:${nss}`;\n\n\t\treturn uriComponents;\n\t},\n};\n\nexport default handler;", "import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, pctDecChars, unescapeComponent } from \"../uri\";\nimport punycode from \"punycode\";\nimport { merge, subexp, toUpperCase, toArray } from \"../util\";\n\nexport interface MailtoHeaders {\n\t[hfname:string]:string\n}\n\nexport interface MailtoComponents extends URIComponents {\n\tto:Array<string>,\n\theaders?:MailtoHeaders,\n\tsubject?:string,\n\tbody?:string\n}\n\nconst O:MailtoHeaders = {};\nconst isIRI = true;\n\n//RFC 3986\nconst UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nconst HEXDIG$$ = \"[0-9A-Fa-f]\";  //case-insensitive\nconst PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$));  //expanded\n\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nconst ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nconst QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nconst VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nconst DOT_ATOM_TEXT$ = subexp(ATEXT$$ + \"+\" + subexp(\"\\\\.\" + ATEXT$$ + \"+\") + \"*\");\nconst QUOTED_PAIR$ = subexp(\"\\\\\\\\\" + VCHAR$$);\nconst QCONTENT$ = subexp(QTEXT$$ + \"|\" + QUOTED_PAIR$);\nconst QUOTED_STRING$ = subexp('\\\\\"' + QCONTENT$ + \"*\" + '\\\\\"');\n\n//RFC 6068\nconst DTEXT_NO_OBS$$ = \"[\\\\x21-\\\\x5A\\\\x5E-\\\\x7E]\";  //%d33-90 / %d94-126\nconst SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nconst QCHAR$ = subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$ + \"|\" + SOME_DELIMS$$);\nconst DOMAIN$ = subexp(DOT_ATOM_TEXT$ + \"|\" + \"\\\\[\" + DTEXT_NO_OBS$$ + \"*\" + \"\\\\]\");\nconst LOCAL_PART$ = subexp(DOT_ATOM_TEXT$ + \"|\" + QUOTED_STRING$);\nconst ADDR_SPEC$ = subexp(LOCAL_PART$ + \"\\\\@\" + DOMAIN$);\nconst TO$ = subexp(ADDR_SPEC$ + subexp(\"\\\\,\" + ADDR_SPEC$) + \"*\");\nconst HFNAME$ = subexp(QCHAR$ + \"*\");\nconst HFVALUE$ = HFNAME$;\nconst HFIELD$ = subexp(HFNAME$ + \"\\\\=\" + HFVALUE$);\nconst HFIELDS2$ = subexp(HFIELD$ + subexp(\"\\\\&\" + HFIELD$) + \"*\");\nconst HFIELDS$ = subexp(\"\\\\?\" + HFIELDS2$);\nconst MAILTO_URI = new RegExp(\"^mailto\\\\:\" + TO$ + \"?\" + HFIELDS$ + \"?$\");\n\nconst UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nconst PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nconst NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nconst NOT_DOMAIN = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", \"[\\\\[]\", DTEXT_NO_OBS$$, \"[\\\\]]\"), \"g\");\nconst NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nconst NOT_HFVALUE = NOT_HFNAME;\nconst TO = new RegExp(\"^\" + TO$ + \"$\");\nconst HFIELDS = new RegExp(\"^\" + HFIELDS2$ + \"$\");\n\nfunction decodeUnreserved(str:string):string {\n\tconst decStr = pctDecChars(str);\n\treturn (!decStr.match(UNRESERVED) ? str : decStr);\n}\n\nconst handler:URISchemeHandler<MailtoComponents> =  {\n\tscheme : \"mailto\",\n\n\tparse : function (components:URIComponents, options:URIOptions):MailtoComponents {\n\t\tconst mailtoComponents = components as MailtoComponents;\n\t\tconst to = mailtoComponents.to = (mailtoComponents.path ? mailtoComponents.path.split(\",\") : []);\n\t\tmailtoComponents.path = undefined;\n\n\t\tif (mailtoComponents.query) {\n\t\t\tlet unknownHeaders = false\n\t\t\tconst headers:MailtoHeaders = {};\n\t\t\tconst hfields = mailtoComponents.query.split(\"&\");\n\n\t\t\tfor (let x = 0, xl = hfields.length; x < xl; ++x) {\n\t\t\t\tconst hfield = hfields[x].split(\"=\");\n\n\t\t\t\tswitch (hfield[0]) {\n\t\t\t\t\tcase \"to\":\n\t\t\t\t\t\tconst toAddrs = hfield[1].split(\",\");\n\t\t\t\t\t\tfor (let x = 0, xl = toAddrs.length; x < xl; ++x) {\n\t\t\t\t\t\t\tto.push(toAddrs[x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"subject\":\n\t\t\t\t\t\tmailtoComponents.subject = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"body\":\n\t\t\t\t\t\tmailtoComponents.body = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tunknownHeaders = true;\n\t\t\t\t\t\theaders[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (unknownHeaders) mailtoComponents.headers = headers;\n\t\t}\n\n\t\tmailtoComponents.query = undefined;\n\n\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\tconst addr = to[x].split(\"@\");\n\n\t\t\taddr[0] = unescapeComponent(addr[0]);\n\n\t\t\tif (!options.unicodeSupport) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\taddr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tmailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddr[1] = unescapeComponent(addr[1], options).toLowerCase();\n\t\t\t}\n\n\t\t\tto[x] = addr.join(\"@\");\n\t\t}\n\n\t\treturn mailtoComponents;\n\t},\n\n\tserialize : function (mailtoComponents:MailtoComponents, options:URIOptions):URIComponents {\n\t\tconst components = mailtoComponents as URIComponents;\n\t\tconst to = toArray(mailtoComponents.to);\n\t\tif (to) {\n\t\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\t\tconst toAddr = String(to[x]);\n\t\t\t\tconst atIdx = toAddr.lastIndexOf(\"@\");\n\t\t\t\tconst localPart = (toAddr.slice(0, atIdx)).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n\t\t\t\tlet domain = toAddr.slice(atIdx + 1);\n\n\t\t\t\t//convert IDN via punycode\n\t\t\t\ttry {\n\t\t\t\t\tdomain = (!options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t\t}\n\n\t\t\t\tto[x] = localPart + \"@\" + domain;\n\t\t\t}\n\n\t\t\tcomponents.path = to.join(\",\");\n\t\t}\n\n\t\tconst headers = mailtoComponents.headers = mailtoComponents.headers || {};\n\n\t\tif (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n\t\tif (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n\n\t\tconst fields = [];\n\t\tfor (const name in headers) {\n\t\t\tif (headers[name] !== O[name]) {\n\t\t\t\tfields.push(\n\t\t\t\t\tname.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) +\n\t\t\t\t\t\"=\" +\n\t\t\t\t\theaders[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (fields.length) {\n\t\t\tcomponents.query = fields.join(\"&\");\n\t\t}\n\n\t\treturn components;\n\t}\n}\n\nexport default handler;", "import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport ws from \"./ws\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"wss\",\n\tdomainHost : ws.domainHost,\n\tparse : ws.parse,\n\tserialize : ws.serialize\n}\n\nexport default handler;", "import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\n\nexport interface WSComponents extends URIComponents {\n\tresourceName?: string;\n\tsecure?: boolean;\n}\n\nfunction isSecure(wsComponents:WSComponents):boolean {\n\treturn typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n}\n\n//RFC 6455\nconst handler:URISchemeHandler = {\n\tscheme : \"ws\",\n\n\tdomainHost : true,\n\n\tparse : function (components:URIComponents, options:URIOptions):WSComponents {\n\t\tconst wsComponents = components as WSComponents;\n\n\t\t//indicate if the secure flag is set\n\t\twsComponents.secure = isSecure(wsComponents);\n\n\t\t//construct resouce name\n\t\twsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n\t\twsComponents.path = undefined;\n\t\twsComponents.query = undefined;\n\n\t\treturn wsComponents;\n\t},\n\n\tserialize : function (wsComponents:WSComponents, options:URIOptions):URIComponents {\n\t\t//normalize the default port\n\t\tif (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n\t\t\twsComponents.port = undefined;\n\t\t}\n\n\t\t//ensure scheme matches secure flag\n\t\tif (typeof wsComponents.secure === 'boolean') {\n\t\t\twsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws');\n\t\t\twsComponents.secure = undefined;\n\t\t}\n\n\t\t//reconstruct path from resource name\n\t\tif (wsComponents.resourceName) {\n\t\t\tconst [path, query] = wsComponents.resourceName.split('?');\n\t\t\twsComponents.path = (path && path !== '/' ? path : undefined);\n\t\t\twsComponents.query = query;\n\t\t\twsComponents.resourceName = undefined;\n\t\t}\n\n\t\t//forbid fragment component\n\t\twsComponents.fragment = undefined;\n\n\t\treturn wsComponents;\n\t}\n};\n\nexport default handler;", "import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport http from \"./http\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"https\",\n\tdomainHost : http.domainHost,\n\tparse : http.parse,\n\tserialize : http.serialize\n}\n\nexport default handler;", "import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"http\",\n\n\tdomainHost : true,\n\n\tparse : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\t//report missing host\n\t\tif (!components.host) {\n\t\t\tcomponents.error = components.error || \"HTTP URIs must have a host.\";\n\t\t}\n\n\t\treturn components;\n\t},\n\n\tserialize : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\tconst secure = String(components.scheme).toLowerCase() === \"https\";\n\n\t\t//normalize the default port\n\t\tif (components.port === (secure ? 443 : 80) || components.port === \"\") {\n\t\t\tcomponents.port = undefined;\n\t\t}\n\t\t\n\t\t//normalize the empty path\n\t\tif (!components.path) {\n\t\t\tcomponents.path = \"/\";\n\t\t}\n\n\t\t//NOTE: We do not parse query strings for HTTP URIs\n\t\t//as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n\t\t//and not the HTTP spec.\n\n\t\treturn components;\n\t}\n};\n\nexport default handler;", "/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\n\nimport URI_PROTOCOL from \"./regexps-uri\";\nimport IRI_PROTOCOL from \"./regexps-iri\";\nimport punycode from \"punycode\";\nimport { toUpperCase, typeOf, assign } from \"./util\";\n\nexport interface URIComponents {\n\tscheme?:string;\n\tuserinfo?:string;\n\thost?:string;\n\tport?:number|string;\n\tpath?:string;\n\tquery?:string;\n\tfragment?:string;\n\treference?:string;\n\terror?:string;\n}\n\nexport interface URIOptions {\n\tscheme?:string;\n\treference?:string;\n\ttolerant?:boolean;\n\tabsolutePath?:boolean;\n\tiri?:boolean;\n\tunicodeSupport?:boolean;\n\tdomainHost?:boolean;\n}\n\nexport interface URISchemeHandler<Components extends URIComponents = URIComponents, Options extends URIOptions = URIOptions, ParentComponents extends URIComponents = URIComponents> {\n\tscheme:string;\n\tparse(components:ParentComponents, options:Options):Components;\n\tserialize(components:Components, options:Options):ParentComponents;\n\tunicodeSupport?:boolean;\n\tdomainHost?:boolean;\n\tabsolutePath?:boolean;\n}\n\nexport interface URIRegExps {\n\tNOT_SCHEME : RegExp,\n\tNOT_USERINFO : RegExp,\n\tNOT_HOST : RegExp,\n\tNOT_PATH : RegExp,\n\tNOT_PATH_NOSCHEME : RegExp,\n\tNOT_QUERY : RegExp,\n\tNOT_FRAGMENT : RegExp,\n\tESCAPE : RegExp,\n\tUNRESERVED : RegExp,\n\tOTHER_CHARS : RegExp,\n\tPCT_ENCODED : RegExp,\n\tIPV4ADDRESS : RegExp,\n\tIPV6ADDRESS : RegExp,\n}\n\nexport const SCHEMES:{[scheme:string]:URISchemeHandler} = {};\n\nexport function pctEncChar(chr:string):string {\n\tconst c = chr.charCodeAt(0);\n\tlet e:string;\n\n\tif (c < 16) e = \"%0\" + c.toString(16).toUpperCase();\n\telse if (c < 128) e = \"%\" + c.toString(16).toUpperCase();\n\telse if (c < 2048) e = \"%\" + ((c >> 6) | 192).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\telse e = \"%\" + ((c >> 12) | 224).toString(16).toUpperCase() + \"%\" + (((c >> 6) & 63) | 128).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\n\treturn e;\n}\n\nexport function pctDecChars(str:string):string {\n\tlet newStr = \"\";\n\tlet i = 0;\n\tconst il = str.length;\n\n\twhile (i < il) {\n\t\tconst c = parseInt(str.substr(i + 1, 2), 16);\n\n\t\tif (c < 128) {\n\t\t\tnewStr += String.fromCharCode(c);\n\t\t\ti += 3;\n\t\t}\n\t\telse if (c >= 194 && c < 224) {\n\t\t\tif ((il - i) >= 6) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 6);\n\t\t\t}\n\t\t\ti += 6;\n\t\t}\n\t\telse if (c >= 224) {\n\t\t\tif ((il - i) >= 9) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tconst c3 = parseInt(str.substr(i + 7, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 9);\n\t\t\t}\n\t\t\ti += 9;\n\t\t}\n\t\telse {\n\t\t\tnewStr += str.substr(i, 3);\n\t\t\ti += 3;\n\t\t}\n\t}\n\n\treturn newStr;\n}\n\nfunction _normalizeComponentEncoding(components:URIComponents, protocol:URIRegExps) {\n\tfunction decodeUnreserved(str:string):string {\n\t\tconst decStr = pctDecChars(str);\n\t\treturn (!decStr.match(protocol.UNRESERVED) ? str : decStr);\n\t}\n\n\tif (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n\tif (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace((components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME), pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\n\treturn components;\n};\n\nfunction _stripLeadingZeros(str:string):string {\n\treturn str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\n\nfunction _normalizeIPv4(host:string, protocol:URIRegExps):string {\n\tconst matches = host.match(protocol.IPV4ADDRESS) || [];\n\tconst [, address] = matches;\n\t\n\tif (address) {\n\t\treturn address.split(\".\").map(_stripLeadingZeros).join(\".\");\n\t} else {\n\t\treturn host;\n\t}\n}\n\nfunction _normalizeIPv6(host:string, protocol:URIRegExps):string {\n\tconst matches = host.match(protocol.IPV6ADDRESS) || [];\n\tconst [, address, zone] = matches;\n\n\tif (address) {\n\t\tconst [last, first] = address.toLowerCase().split('::').reverse();\n\t\tconst firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n\t\tconst lastFields = last.split(\":\").map(_stripLeadingZeros);\n\t\tconst isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n\t\tconst fieldCount = isLastFieldIPv4Address ? 7 : 8;\n\t\tconst lastFieldsStart = lastFields.length - fieldCount;\n\t\tconst fields = Array<string>(fieldCount);\n\n\t\tfor (let x = 0; x < fieldCount; ++x) {\n\t\t\tfields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n\t\t}\n\n\t\tif (isLastFieldIPv4Address) {\n\t\t\tfields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n\t\t}\n\n\t\tconst allZeroFields = fields.reduce<Array<{index:number,length:number}>>((acc, field, index) => {\n\t\t\tif (!field || field === \"0\") {\n\t\t\t\tconst lastLongest = acc[acc.length - 1];\n\t\t\t\tif (lastLongest && lastLongest.index + lastLongest.length === index) {\n\t\t\t\t\tlastLongest.length++;\n\t\t\t\t} else {\n\t\t\t\t\tacc.push({ index, length : 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\n\t\tconst longestZeroFields = allZeroFields.sort((a, b) => b.length - a.length)[0];\n\n\t\tlet newHost:string;\n\t\tif (longestZeroFields && longestZeroFields.length > 1) {\n\t\t\tconst newFirst = fields.slice(0, longestZeroFields.index) ;\n\t\t\tconst newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n\t\t\tnewHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n\t\t} else {\n\t\t\tnewHost = fields.join(\":\");\n\t\t}\n\n\t\tif (zone) {\n\t\t\tnewHost += \"%\" + zone;\n\t\t}\n\n\t\treturn newHost;\n\t} else {\n\t\treturn host;\n\t}\n}\n\nconst URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nconst NO_MATCH_IS_UNDEFINED = (<RegExpMatchArray>(\"\").match(/(){0}/))[1] === undefined;\n\nexport function parse(uriString:string, options:URIOptions = {}):URIComponents {\n\tconst components:URIComponents = {};\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\n\tif (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n\n\tconst matches = uriString.match(URI_PARSE);\n\n\tif (matches) {\n\t\tif (NO_MATCH_IS_UNDEFINED) {\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1];\n\t\t\tcomponents.userinfo = matches[3];\n\t\t\tcomponents.host = matches[4];\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = matches[7];\n\t\t\tcomponents.fragment = matches[8];\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = matches[5];\n\t\t\t}\n\t\t} else {  //IE FIX for improper RegExp matching\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1] || undefined;\n\t\t\tcomponents.userinfo = (uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined);\n\t\t\tcomponents.host = (uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined);\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = (uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined);\n\t\t\tcomponents.fragment = (uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined);\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = (uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined);\n\t\t\t}\n\t\t}\n\n\t\tif (components.host) {\n\t\t\t//normalize IP hosts\n\t\t\tcomponents.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n\t\t}\n\n\t\t//determine reference type\n\t\tif (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n\t\t\tcomponents.reference = \"same-document\";\n\t\t} else if (components.scheme === undefined) {\n\t\t\tcomponents.reference = \"relative\";\n\t\t} else if (components.fragment === undefined) {\n\t\t\tcomponents.reference = \"absolute\";\n\t\t} else {\n\t\t\tcomponents.reference = \"uri\";\n\t\t}\n\n\t\t//check for reference errors\n\t\tif (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n\t\t\tcomponents.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n\t\t}\n\n\t\t//find scheme handler\n\t\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t\t//check if scheme can't handle IRIs\n\t\tif (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n\t\t\t//if host component is a domain name\n\t\t\tif (components.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost))) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\tcomponents.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//convert IRI -> URI\n\t\t\t_normalizeComponentEncoding(components, URI_PROTOCOL);\n\t\t} else {\n\t\t\t//normalize encodings\n\t\t\t_normalizeComponentEncoding(components, protocol);\n\t\t}\n\n\t\t//perform scheme specific parsing\n\t\tif (schemeHandler && schemeHandler.parse) {\n\t\t\tschemeHandler.parse(components, options);\n\t\t}\n\t} else {\n\t\tcomponents.error = components.error || \"URI can not be parsed.\";\n\t}\n\n\treturn components;\n};\n\nfunction _recomposeAuthority(components:URIComponents, options:URIOptions):string|undefined {\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\tif (components.userinfo !== undefined) {\n\t\turiTokens.push(components.userinfo);\n\t\turiTokens.push(\"@\");\n\t}\n\n\tif (components.host !== undefined) {\n\t\t//normalize IP hosts, add brackets and escape zone separator for IPv6\n\t\turiTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, (_, $1, $2) => \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\"));\n\t}\n\n\tif (typeof components.port === \"number\" || typeof components.port === \"string\") {\n\t\turiTokens.push(\":\");\n\t\turiTokens.push(String(components.port));\n\t}\n\n\treturn uriTokens.length ? uriTokens.join(\"\") : undefined;\n};\n\nconst RDS1 = /^\\.\\.?\\//;\nconst RDS2 = /^\\/\\.(\\/|$)/;\nconst RDS3 = /^\\/\\.\\.(\\/|$)/;\nconst RDS4 = /^\\.\\.?$/;\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n\nexport function removeDotSegments(input:string):string {\n\tconst output:Array<string> = [];\n\n\twhile (input.length) {\n\t\tif (input.match(RDS1)) {\n\t\t\tinput = input.replace(RDS1, \"\");\n\t\t} else if (input.match(RDS2)) {\n\t\t\tinput = input.replace(RDS2, \"/\");\n\t\t} else if (input.match(RDS3)) {\n\t\t\tinput = input.replace(RDS3, \"/\");\n\t\t\toutput.pop();\n\t\t} else if (input === \".\" || input === \"..\") {\n\t\t\tinput = \"\";\n\t\t} else {\n\t\t\tconst im = input.match(RDS5);\n\t\t\tif (im) {\n\t\t\t\tconst s = im[0];\n\t\t\t\tinput = input.slice(s.length);\n\t\t\t\toutput.push(s);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Unexpected dot segment condition\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output.join(\"\");\n};\n\nexport function serialize(components:URIComponents, options:URIOptions = {}):string {\n\tconst protocol = (options.iri ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\t//find scheme handler\n\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t//perform scheme specific serialization\n\tif (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n\n\tif (components.host) {\n\t\t//if host component is an IPv6 address\n\t\tif (protocol.IPV6ADDRESS.test(components.host)) {\n\t\t\t//TODO: normalize IPv6 address as per RFC 5952\n\t\t}\n\n\t\t//if host component is a domain name\n\t\telse if (options.domainHost || (schemeHandler && schemeHandler.domainHost)) {\n\t\t\t//convert IDN via punycode\n\t\t\ttry {\n\t\t\t\tcomponents.host = (!options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host));\n\t\t\t} catch (e) {\n\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t}\n\t\t}\n\t}\n\n\t//normalize encoding\n\t_normalizeComponentEncoding(components, protocol);\n\n\tif (options.reference !== \"suffix\" && components.scheme) {\n\t\turiTokens.push(components.scheme);\n\t\turiTokens.push(\":\");\n\t}\n\n\tconst authority = _recomposeAuthority(components, options);\n\tif (authority !== undefined) {\n\t\tif (options.reference !== \"suffix\") {\n\t\t\turiTokens.push(\"//\");\n\t\t}\n\n\t\turiTokens.push(authority);\n\n\t\tif (components.path && components.path.charAt(0) !== \"/\") {\n\t\t\turiTokens.push(\"/\");\n\t\t}\n\t}\n\n\tif (components.path !== undefined) {\n\t\tlet s = components.path;\n\n\t\tif (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n\t\t\ts = removeDotSegments(s);\n\t\t}\n\n\t\tif (authority === undefined) {\n\t\t\ts = s.replace(/^\\/\\//, \"/%2F\");  //don't allow the path to start with \"//\"\n\t\t}\n\n\t\turiTokens.push(s);\n\t}\n\n\tif (components.query !== undefined) {\n\t\turiTokens.push(\"?\");\n\t\turiTokens.push(components.query);\n\t}\n\n\tif (components.fragment !== undefined) {\n\t\turiTokens.push(\"#\");\n\t\turiTokens.push(components.fragment);\n\t}\n\n\treturn uriTokens.join(\"\");  //merge tokens into a string\n};\n\nexport function resolveComponents(base:URIComponents, relative:URIComponents, options:URIOptions = {}, skipNormalization?:boolean):URIComponents {\n\tconst target:URIComponents = {};\n\n\tif (!skipNormalization) {\n\t\tbase = parse(serialize(base, options), options);  //normalize base components\n\t\trelative = parse(serialize(relative, options), options);  //normalize relative components\n\t}\n\toptions = options || {};\n\n\tif (!options.tolerant && relative.scheme) {\n\t\ttarget.scheme = relative.scheme;\n\t\t//target.authority = relative.authority;\n\t\ttarget.userinfo = relative.userinfo;\n\t\ttarget.host = relative.host;\n\t\ttarget.port = relative.port;\n\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\ttarget.query = relative.query;\n\t} else {\n\t\tif (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n\t\t\t//target.authority = relative.authority;\n\t\t\ttarget.userinfo = relative.userinfo;\n\t\t\ttarget.host = relative.host;\n\t\t\ttarget.port = relative.port;\n\t\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\t\ttarget.query = relative.query;\n\t\t} else {\n\t\t\tif (!relative.path) {\n\t\t\t\ttarget.path = base.path;\n\t\t\t\tif (relative.query !== undefined) {\n\t\t\t\t\ttarget.query = relative.query;\n\t\t\t\t} else {\n\t\t\t\t\ttarget.query = base.query;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (relative.path.charAt(0) === \"/\") {\n\t\t\t\t\ttarget.path = removeDotSegments(relative.path);\n\t\t\t\t} else {\n\t\t\t\t\tif ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n\t\t\t\t\t\ttarget.path = \"/\" + relative.path;\n\t\t\t\t\t} else if (!base.path) {\n\t\t\t\t\t\ttarget.path = relative.path;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n\t\t\t\t\t}\n\t\t\t\t\ttarget.path = removeDotSegments(target.path);\n\t\t\t\t}\n\t\t\t\ttarget.query = relative.query;\n\t\t\t}\n\t\t\t//target.authority = base.authority;\n\t\t\ttarget.userinfo = base.userinfo;\n\t\t\ttarget.host = base.host;\n\t\t\ttarget.port = base.port;\n\t\t}\n\t\ttarget.scheme = base.scheme;\n\t}\n\n\ttarget.fragment = relative.fragment;\n\n\treturn target;\n};\n\nexport function resolve(baseURI:string, relativeURI:string, options?:URIOptions):string {\n\tconst schemelessOptions = assign({ scheme : 'null' }, options);\n\treturn serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n};\n\nexport function normalize(uri:string, options?:URIOptions):string;\nexport function normalize(uri:URIComponents, options?:URIOptions):URIComponents;\nexport function normalize(uri:any, options?:URIOptions):any {\n\tif (typeof uri === \"string\") {\n\t\turi = serialize(parse(uri, options), options);\n\t} else if (typeOf(uri) === \"object\") {\n\t\turi = parse(serialize(<URIComponents>uri, options), options);\n\t}\n\n\treturn uri;\n};\n\nexport function equal(uriA:string, uriB:string, options?: URIOptions):boolean;\nexport function equal(uriA:URIComponents, uriB:URIComponents, options?:URIOptions):boolean;\nexport function equal(uriA:any, uriB:any, options?:URIOptions):boolean {\n\tif (typeof uriA === \"string\") {\n\t\turiA = serialize(parse(uriA, options), options);\n\t} else if (typeOf(uriA) === \"object\") {\n\t\turiA = serialize(<URIComponents>uriA, options);\n\t}\n\n\tif (typeof uriB === \"string\") {\n\t\turiB = serialize(parse(uriB, options), options);\n\t} else if (typeOf(uriB) === \"object\") {\n\t\turiB = serialize(<URIComponents>uriB, options);\n\t}\n\n\treturn uriA === uriB;\n};\n\nexport function escapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE), pctEncChar);\n};\n\nexport function unescapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED), pctDecChars);\n};\n", "'use strict';\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tconst parts = string.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tconst labels = string.split('.');\n\tconst encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = array => String.fromCodePoint(...array);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tlet oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tlet inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tlet basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue == n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.1.0',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\nexport default punycode;\n", "import { URIRegExps } from \"./uri\";\nimport { buildExps } from \"./regexps-uri\";\n\nexport default buildExps(true);\n", "import { URIRegExps } from \"./uri\";\nimport { merge, subexp } from \"./util\";\n\nexport function buildExps(isIRI:boolean):URIRegExps {\n\tconst\n\t\tALPHA$$ = \"[A-Za-z]\",\n\t\tCR$ = \"[\\\\x0D]\",\n\t\tDIGIT$$ = \"[0-9]\",\n\t\tDQUOTE$$ = \"[\\\\x22]\",\n\t\tHEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),  //case-insensitive\n\t\tLF$$ = \"[\\\\x0A]\",\n\t\tSP$$ = \"[\\\\x20]\",\n\t\tPCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),  //expanded\n\t\tGEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n\t\tSUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n\t\tRESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n\t\tUCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",  //subset, excludes bidi control characters\n\t\tIPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",  //subset\n\t\tUNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n\t\tSCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n\t\tUSERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n\t\tDEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n\t\tDEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),  //relaxed parsing rules\n\t\tIPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n\t\tH16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n\t\tLS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n\t\tIPV6ADDRESS1$ = subexp(                                                            subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$), //                           6( h16 \":\" ) ls32\n\t\tIPV6ADDRESS2$ = subexp(                                                 \"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$), //                      \"::\" 5( h16 \":\" ) ls32\n\t\tIPV6ADDRESS3$ = subexp(subexp(                                 H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$), //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n\t\tIPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$), //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n\t\tIPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$), //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n\t\tIPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" +        H16$ + \"\\\\:\"          + LS32$), //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n\t\tIPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\"                                + LS32$), //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n\t\tIPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\"                                + H16$ ), //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n\t\tIPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"                                       ), //[ *6( h16 \":\" ) h16 ] \"::\"\n\t\tIPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n\t\tZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),  //RFC 6874\n\t\tIPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),  //RFC 6874\n\t\tIPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),  //RFC 6874, with relaxed parsing rules\n\t\tIPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n\t\tIP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),  //RFC 6874\n\t\tREG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n\t\tHOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n\t\tPORT$ = subexp(DIGIT$$ + \"*\"),\n\t\tAUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n\t\tPCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n\t\tSEGMENT$ = subexp(PCHAR$ + \"*\"),\n\t\tSEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n\t\tSEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n\t\tPATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n\t\tPATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),  //simplified\n\t\tPATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n\t\tPATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tQUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n\t\tFRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n\t\tHIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tURI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tRELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n\t\tRELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tURI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n\t\tABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n\n\t\tGENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tRELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n\t\tSAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tAUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\"\n\t;\n\n\treturn {\n\t\tNOT_SCHEME : new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n\t\tNOT_USERINFO : new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_HOST : new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH : new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH_NOSCHEME : new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_QUERY : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n\t\tNOT_FRAGMENT : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n\t\tESCAPE : new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tUNRESERVED : new RegExp(UNRESERVED$$, \"g\"),\n\t\tOTHER_CHARS : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n\t\tPCT_ENCODED : new RegExp(PCT_ENCODED$, \"g\"),\n\t\tIPV4ADDRESS : new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n\t\tIPV6ADDRESS : new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\")  //RFC 6874, with relaxed parsing rules\n\t};\n}\n\nexport default buildExps(false);\n", "export function merge(...sets:Array<string>):string {\n\tif (sets.length > 1) {\n\t\tsets[0] = sets[0].slice(0, -1);\n\t\tconst xl = sets.length - 1;\n\t\tfor (let x = 1; x < xl; ++x) {\n\t\t\tsets[x] = sets[x].slice(1, -1);\n\t\t}\n\t\tsets[xl] = sets[xl].slice(1);\n\t\treturn sets.join('');\n\t} else {\n\t\treturn sets[0];\n\t}\n}\n\nexport function subexp(str:string):string {\n\treturn \"(?:\" + str + \")\";\n}\n\nexport function typeOf(o:any):string {\n\treturn o === undefined ? \"undefined\" : (o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase());\n}\n\nexport function toUpperCase(str:string):string {\n\treturn str.toUpperCase();\n}\n\nexport function toArray(obj:any):Array<any> {\n\treturn obj !== undefined && obj !== null ? (obj instanceof Array ? obj : (typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj))) : [];\n}\n\n\nexport function assign(target: object, source: any): any {\n\tconst obj = target as any;\n\tif (source) {\n\t\tfor (const key in source) {\n\t\t\tobj[key] = source[key];\n\t\t}\n\t}\n\treturn obj;\n}", "'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n", "'use strict';\n\n// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nmodule.exports = function ucs2length(str) {\n  var length = 0\n    , len = str.length\n    , pos = 0\n    , value;\n  while (pos < len) {\n    length++;\n    value = str.charCodeAt(pos++);\n    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos);\n      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate\n    }\n  }\n  return length;\n};\n", "'use strict';\n\n\nmodule.exports = {\n  copy: copy,\n  checkDataType: checkDataType,\n  checkDataTypes: checkDataTypes,\n  coerceToTypes: coerceToTypes,\n  toHash: toHash,\n  getProperty: getProperty,\n  escapeQuotes: escapeQuotes,\n  equal: require('fast-deep-equal'),\n  ucs2length: require('./ucs2length'),\n  varOccurences: varOccurences,\n  varReplace: varReplace,\n  schemaHasRules: schemaHasRules,\n  schemaHasRulesExcept: schemaHasRulesExcept,\n  schemaUnknownRules: schemaUnknownRules,\n  toQuotedString: toQuotedString,\n  getPathExpr: getPathExpr,\n  getPath: getPath,\n  getData: getData,\n  unescapeFragment: unescapeFragment,\n  unescapeJsonPointer: unescapeJsonPointer,\n  escapeFragment: escapeFragment,\n  escapeJsonPointer: escapeJsonPointer\n};\n\n\nfunction copy(o, to) {\n  to = to || {};\n  for (var key in o) to[key] = o[key];\n  return to;\n}\n\n\nfunction checkDataType(dataType, data, strictNumbers, negate) {\n  var EQUAL = negate ? ' !== ' : ' === '\n    , AND = negate ? ' || ' : ' && '\n    , OK = negate ? '!' : ''\n    , NOT = negate ? '' : '!';\n  switch (dataType) {\n    case 'null': return data + EQUAL + 'null';\n    case 'array': return OK + 'Array.isArray(' + data + ')';\n    case 'object': return '(' + OK + data + AND +\n                          'typeof ' + data + EQUAL + '\"object\"' + AND +\n                          NOT + 'Array.isArray(' + data + '))';\n    case 'integer': return '(typeof ' + data + EQUAL + '\"number\"' + AND +\n                           NOT + '(' + data + ' % 1)' +\n                           AND + data + EQUAL + data +\n                           (strictNumbers ? (AND + OK + 'isFinite(' + data + ')') : '') + ')';\n    case 'number': return '(typeof ' + data + EQUAL + '\"' + dataType + '\"' +\n                          (strictNumbers ? (AND + OK + 'isFinite(' + data + ')') : '') + ')';\n    default: return 'typeof ' + data + EQUAL + '\"' + dataType + '\"';\n  }\n}\n\n\nfunction checkDataTypes(dataTypes, data, strictNumbers) {\n  switch (dataTypes.length) {\n    case 1: return checkDataType(dataTypes[0], data, strictNumbers, true);\n    default:\n      var code = '';\n      var types = toHash(dataTypes);\n      if (types.array && types.object) {\n        code = types.null ? '(': '(!' + data + ' || ';\n        code += 'typeof ' + data + ' !== \"object\")';\n        delete types.null;\n        delete types.array;\n        delete types.object;\n      }\n      if (types.number) delete types.integer;\n      for (var t in types)\n        code += (code ? ' && ' : '' ) + checkDataType(t, data, strictNumbers, true);\n\n      return code;\n  }\n}\n\n\nvar COERCE_TO_TYPES = toHash([ 'string', 'number', 'integer', 'boolean', 'null' ]);\nfunction coerceToTypes(optionCoerceTypes, dataTypes) {\n  if (Array.isArray(dataTypes)) {\n    var types = [];\n    for (var i=0; i<dataTypes.length; i++) {\n      var t = dataTypes[i];\n      if (COERCE_TO_TYPES[t]) types[types.length] = t;\n      else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;\n    }\n    if (types.length) return types;\n  } else if (COERCE_TO_TYPES[dataTypes]) {\n    return [dataTypes];\n  } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {\n    return ['array'];\n  }\n}\n\n\nfunction toHash(arr) {\n  var hash = {};\n  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;\n  return hash;\n}\n\n\nvar IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\nvar SINGLE_QUOTE = /'|\\\\/g;\nfunction getProperty(key) {\n  return typeof key == 'number'\n          ? '[' + key + ']'\n          : IDENTIFIER.test(key)\n            ? '.' + key\n            : \"['\" + escapeQuotes(key) + \"']\";\n}\n\n\nfunction escapeQuotes(str) {\n  return str.replace(SINGLE_QUOTE, '\\\\$&')\n            .replace(/\\n/g, '\\\\n')\n            .replace(/\\r/g, '\\\\r')\n            .replace(/\\f/g, '\\\\f')\n            .replace(/\\t/g, '\\\\t');\n}\n\n\nfunction varOccurences(str, dataVar) {\n  dataVar += '[^0-9]';\n  var matches = str.match(new RegExp(dataVar, 'g'));\n  return matches ? matches.length : 0;\n}\n\n\nfunction varReplace(str, dataVar, expr) {\n  dataVar += '([^0-9])';\n  expr = expr.replace(/\\$/g, '$$$$');\n  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');\n}\n\n\nfunction schemaHasRules(schema, rules) {\n  if (typeof schema == 'boolean') return !schema;\n  for (var key in schema) if (rules[key]) return true;\n}\n\n\nfunction schemaHasRulesExcept(schema, rules, exceptKeyword) {\n  if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';\n  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;\n}\n\n\nfunction schemaUnknownRules(schema, rules) {\n  if (typeof schema == 'boolean') return;\n  for (var key in schema) if (!rules[key]) return key;\n}\n\n\nfunction toQuotedString(str) {\n  return '\\'' + escapeQuotes(str) + '\\'';\n}\n\n\nfunction getPathExpr(currentPath, expr, jsonPointers, isNumber) {\n  var path = jsonPointers // false by default\n              ? '\\'/\\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \\'~0\\').replace(/\\\\//g, \\'~1\\')')\n              : (isNumber ? '\\'[\\' + ' + expr + ' + \\']\\'' : '\\'[\\\\\\'\\' + ' + expr + ' + \\'\\\\\\']\\'');\n  return joinPaths(currentPath, path);\n}\n\n\nfunction getPath(currentPath, prop, jsonPointers) {\n  var path = jsonPointers // false by default\n              ? toQuotedString('/' + escapeJsonPointer(prop))\n              : toQuotedString(getProperty(prop));\n  return joinPaths(currentPath, path);\n}\n\n\nvar JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nvar RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, lvl, paths) {\n  var up, jsonPointer, data, matches;\n  if ($data === '') return 'rootData';\n  if ($data[0] == '/') {\n    if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);\n    jsonPointer = $data;\n    data = 'rootData';\n  } else {\n    matches = $data.match(RELATIVE_JSON_POINTER);\n    if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);\n    up = +matches[1];\n    jsonPointer = matches[2];\n    if (jsonPointer == '#') {\n      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);\n      return paths[lvl - up];\n    }\n\n    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);\n    data = 'data' + ((lvl - up) || '');\n    if (!jsonPointer) return data;\n  }\n\n  var expr = data;\n  var segments = jsonPointer.split('/');\n  for (var i=0; i<segments.length; i++) {\n    var segment = segments[i];\n    if (segment) {\n      data += getProperty(unescapeJsonPointer(segment));\n      expr += ' && ' + data;\n    }\n  }\n  return expr;\n}\n\n\nfunction joinPaths (a, b) {\n  if (a == '\"\"') return b;\n  return (a + ' + ' + b).replace(/([^\\\\])' \\+ '/g, '$1');\n}\n\n\nfunction unescapeFragment(str) {\n  return unescapeJsonPointer(decodeURIComponent(str));\n}\n\n\nfunction escapeFragment(str) {\n  return encodeURIComponent(escapeJsonPointer(str));\n}\n\n\nfunction escapeJsonPointer(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n\n\nfunction unescapeJsonPointer(str) {\n  return str.replace(/~1/g, '/').replace(/~0/g, '~');\n}\n", "'use strict';\n\nvar util = require('./util');\n\nmodule.exports = SchemaObject;\n\nfunction SchemaObject(obj) {\n  util.copy(obj, this);\n}\n", "'use strict';\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n", "'use strict';\n\nvar URI = require('uri-js')\n  , equal = require('fast-deep-equal')\n  , util = require('./util')\n  , SchemaObject = require('./schema_obj')\n  , traverse = require('json-schema-traverse');\n\nmodule.exports = resolve;\n\nresolve.normalizeId = normalizeId;\nresolve.fullPath = getFullPath;\nresolve.url = resolveUrl;\nresolve.ids = resolveIds;\nresolve.inlineRef = inlineRef;\nresolve.schema = resolveSchema;\n\n/**\n * [resolve and compile the references ($ref)]\n * @this   Ajv\n * @param  {Function} compile reference to schema compilation funciton (localCompile)\n * @param  {Object} root object with information about the root schema for the current schema\n * @param  {String} ref reference to resolve\n * @return {Object|Function} schema object (if the schema can be inlined) or validation function\n */\nfunction resolve(compile, root, ref) {\n  /* jshint validthis: true */\n  var refVal = this._refs[ref];\n  if (typeof refVal == 'string') {\n    if (this._refs[refVal]) refVal = this._refs[refVal];\n    else return resolve.call(this, compile, root, refVal);\n  }\n\n  refVal = refVal || this._schemas[ref];\n  if (refVal instanceof SchemaObject) {\n    return inlineRef(refVal.schema, this._opts.inlineRefs)\n            ? refVal.schema\n            : refVal.validate || this._compile(refVal);\n  }\n\n  var res = resolveSchema.call(this, root, ref);\n  var schema, v, baseId;\n  if (res) {\n    schema = res.schema;\n    root = res.root;\n    baseId = res.baseId;\n  }\n\n  if (schema instanceof SchemaObject) {\n    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);\n  } else if (schema !== undefined) {\n    v = inlineRef(schema, this._opts.inlineRefs)\n        ? schema\n        : compile.call(this, schema, root, undefined, baseId);\n  }\n\n  return v;\n}\n\n\n/**\n * Resolve schema, its root and baseId\n * @this Ajv\n * @param  {Object} root root object with properties schema, refVal, refs\n * @param  {String} ref  reference to resolve\n * @return {Object} object with properties schema, root, baseId\n */\nfunction resolveSchema(root, ref) {\n  /* jshint validthis: true */\n  var p = URI.parse(ref)\n    , refPath = _getFullPath(p)\n    , baseId = getFullPath(this._getId(root.schema));\n  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {\n    var id = normalizeId(refPath);\n    var refVal = this._refs[id];\n    if (typeof refVal == 'string') {\n      return resolveRecursive.call(this, root, refVal, p);\n    } else if (refVal instanceof SchemaObject) {\n      if (!refVal.validate) this._compile(refVal);\n      root = refVal;\n    } else {\n      refVal = this._schemas[id];\n      if (refVal instanceof SchemaObject) {\n        if (!refVal.validate) this._compile(refVal);\n        if (id == normalizeId(ref))\n          return { schema: refVal, root: root, baseId: baseId };\n        root = refVal;\n      } else {\n        return;\n      }\n    }\n    if (!root.schema) return;\n    baseId = getFullPath(this._getId(root.schema));\n  }\n  return getJsonPointer.call(this, p, baseId, root.schema, root);\n}\n\n\n/* @this Ajv */\nfunction resolveRecursive(root, ref, parsedRef) {\n  /* jshint validthis: true */\n  var res = resolveSchema.call(this, root, ref);\n  if (res) {\n    var schema = res.schema;\n    var baseId = res.baseId;\n    root = res.root;\n    var id = this._getId(schema);\n    if (id) baseId = resolveUrl(baseId, id);\n    return getJsonPointer.call(this, parsedRef, baseId, schema, root);\n  }\n}\n\n\nvar PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);\n/* @this Ajv */\nfunction getJsonPointer(parsedRef, baseId, schema, root) {\n  /* jshint validthis: true */\n  parsedRef.fragment = parsedRef.fragment || '';\n  if (parsedRef.fragment.slice(0,1) != '/') return;\n  var parts = parsedRef.fragment.split('/');\n\n  for (var i = 1; i < parts.length; i++) {\n    var part = parts[i];\n    if (part) {\n      part = util.unescapeFragment(part);\n      schema = schema[part];\n      if (schema === undefined) break;\n      var id;\n      if (!PREVENT_SCOPE_CHANGE[part]) {\n        id = this._getId(schema);\n        if (id) baseId = resolveUrl(baseId, id);\n        if (schema.$ref) {\n          var $ref = resolveUrl(baseId, schema.$ref);\n          var res = resolveSchema.call(this, root, $ref);\n          if (res) {\n            schema = res.schema;\n            root = res.root;\n            baseId = res.baseId;\n          }\n        }\n      }\n    }\n  }\n  if (schema !== undefined && schema !== root.schema)\n    return { schema: schema, root: root, baseId: baseId };\n}\n\n\nvar SIMPLE_INLINED = util.toHash([\n  'type', 'format', 'pattern',\n  'maxLength', 'minLength',\n  'maxProperties', 'minProperties',\n  'maxItems', 'minItems',\n  'maximum', 'minimum',\n  'uniqueItems', 'multipleOf',\n  'required', 'enum'\n]);\nfunction inlineRef(schema, limit) {\n  if (limit === false) return false;\n  if (limit === undefined || limit === true) return checkNoRef(schema);\n  else if (limit) return countKeys(schema) <= limit;\n}\n\n\nfunction checkNoRef(schema) {\n  var item;\n  if (Array.isArray(schema)) {\n    for (var i=0; i<schema.length; i++) {\n      item = schema[i];\n      if (typeof item == 'object' && !checkNoRef(item)) return false;\n    }\n  } else {\n    for (var key in schema) {\n      if (key == '$ref') return false;\n      item = schema[key];\n      if (typeof item == 'object' && !checkNoRef(item)) return false;\n    }\n  }\n  return true;\n}\n\n\nfunction countKeys(schema) {\n  var count = 0, item;\n  if (Array.isArray(schema)) {\n    for (var i=0; i<schema.length; i++) {\n      item = schema[i];\n      if (typeof item == 'object') count += countKeys(item);\n      if (count == Infinity) return Infinity;\n    }\n  } else {\n    for (var key in schema) {\n      if (key == '$ref') return Infinity;\n      if (SIMPLE_INLINED[key]) {\n        count++;\n      } else {\n        item = schema[key];\n        if (typeof item == 'object') count += countKeys(item) + 1;\n        if (count == Infinity) return Infinity;\n      }\n    }\n  }\n  return count;\n}\n\n\nfunction getFullPath(id, normalize) {\n  if (normalize !== false) id = normalizeId(id);\n  var p = URI.parse(id);\n  return _getFullPath(p);\n}\n\n\nfunction _getFullPath(p) {\n  return URI.serialize(p).split('#')[0] + '#';\n}\n\n\nvar TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';\n}\n\n\nfunction resolveUrl(baseId, id) {\n  id = normalizeId(id);\n  return URI.resolve(baseId, id);\n}\n\n\n/* @this Ajv */\nfunction resolveIds(schema) {\n  var schemaId = normalizeId(this._getId(schema));\n  var baseIds = {'': schemaId};\n  var fullPaths = {'': getFullPath(schemaId, false)};\n  var localRefs = {};\n  var self = this;\n\n  traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n    if (jsonPtr === '') return;\n    var id = self._getId(sch);\n    var baseId = baseIds[parentJsonPtr];\n    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;\n    if (keyIndex !== undefined)\n      fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));\n\n    if (typeof id == 'string') {\n      id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);\n\n      var refVal = self._refs[id];\n      if (typeof refVal == 'string') refVal = self._refs[refVal];\n      if (refVal && refVal.schema) {\n        if (!equal(sch, refVal.schema))\n          throw new Error('id \"' + id + '\" resolves to more than one schema');\n      } else if (id != normalizeId(fullPath)) {\n        if (id[0] == '#') {\n          if (localRefs[id] && !equal(sch, localRefs[id]))\n            throw new Error('id \"' + id + '\" resolves to more than one schema');\n          localRefs[id] = sch;\n        } else {\n          self._refs[id] = fullPath;\n        }\n      }\n    }\n    baseIds[jsonPtr] = baseId;\n    fullPaths[jsonPtr] = fullPath;\n  });\n\n  return localRefs;\n}\n", "'use strict';\n\nvar resolve = require('./resolve');\n\nmodule.exports = {\n  Validation: errorSubclass(ValidationError),\n  MissingRef: errorSubclass(MissingRefError)\n};\n\n\nfunction ValidationError(errors) {\n  this.message = 'validation failed';\n  this.errors = errors;\n  this.ajv = this.validation = true;\n}\n\n\nMissingRefError.message = function (baseId, ref) {\n  return 'can\\'t resolve reference ' + ref + ' from id ' + baseId;\n};\n\n\nfunction MissingRefError(baseId, ref, message) {\n  this.message = message || MissingRefError.message(baseId, ref);\n  this.missingRef = resolve.url(baseId, ref);\n  this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));\n}\n\n\nfunction errorSubclass(Subclass) {\n  Subclass.prototype = Object.create(Error.prototype);\n  Subclass.prototype.constructor = Subclass;\n  return Subclass;\n}\n", "'use strict';\n\nmodule.exports = function (data, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (node) {\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        if (node === undefined) return;\n        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';\n        if (typeof node !== 'object') return JSON.stringify(node);\n\n        var i, out;\n        if (Array.isArray(node)) {\n            out = '[';\n            for (i = 0; i < node.length; i++) {\n                if (i) out += ',';\n                out += stringify(node[i]) || 'null';\n            }\n            return out + ']';\n        }\n\n        if (node === null) return 'null';\n\n        if (seen.indexOf(node) !== -1) {\n            if (cycles) return JSON.stringify('__cycle__');\n            throw new TypeError('Converting circular structure to JSON');\n        }\n\n        var seenIndex = seen.push(node) - 1;\n        var keys = Object.keys(node).sort(cmp && cmp(node));\n        out = '';\n        for (i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var value = stringify(node[key]);\n\n            if (!value) continue;\n            if (out) out += ',';\n            out += JSON.stringify(key) + ':' + value;\n        }\n        seen.splice(seenIndex, 1);\n        return '{' + out + '}';\n    })(data);\n};\n", "'use strict';\nmodule.exports = function generate_validate(it, $keyword, $ruleType) {\n  var out = '';\n  var $async = it.schema.$async === true,\n    $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),\n    $id = it.self._getId(it.schema);\n  if (it.opts.strictKeywords) {\n    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);\n    if ($unknownKwd) {\n      var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;\n      if (it.opts.strictKeywords === 'log') it.logger.warn($keywordsMsg);\n      else throw new Error($keywordsMsg);\n    }\n  }\n  if (it.isTop) {\n    out += ' var validate = ';\n    if ($async) {\n      it.async = true;\n      out += 'async ';\n    }\n    out += 'function(data, dataPath, parentData, parentDataProperty, rootData) { \\'use strict\\'; ';\n    if ($id && (it.opts.sourceCode || it.opts.processCode)) {\n      out += ' ' + ('/\\*# sourceURL=' + $id + ' */') + ' ';\n    }\n  }\n  if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {\n    var $keyword = 'false schema';\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $errorKeyword;\n    var $data = 'data' + ($dataLvl || '');\n    var $valid = 'valid' + $lvl;\n    if (it.schema === false) {\n      if (it.isTop) {\n        $breakOnError = true;\n      } else {\n        out += ' var ' + ($valid) + ' = false; ';\n      }\n      var $$outStack = $$outStack || [];\n      $$outStack.push(out);\n      out = ''; /* istanbul ignore else */\n      if (it.createErrors !== false) {\n        out += ' { keyword: \\'' + ($errorKeyword || 'false schema') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n        if (it.opts.messages !== false) {\n          out += ' , message: \\'boolean schema is false\\' ';\n        }\n        if (it.opts.verbose) {\n          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n        }\n        out += ' } ';\n      } else {\n        out += ' {} ';\n      }\n      var __err = out;\n      out = $$outStack.pop();\n      if (!it.compositeRule && $breakOnError) {\n        /* istanbul ignore if */\n        if (it.async) {\n          out += ' throw new ValidationError([' + (__err) + ']); ';\n        } else {\n          out += ' validate.errors = [' + (__err) + ']; return false; ';\n        }\n      } else {\n        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n      }\n    } else {\n      if (it.isTop) {\n        if ($async) {\n          out += ' return data; ';\n        } else {\n          out += ' validate.errors = null; return true; ';\n        }\n      } else {\n        out += ' var ' + ($valid) + ' = true; ';\n      }\n    }\n    if (it.isTop) {\n      out += ' }; return validate; ';\n    }\n    return out;\n  }\n  if (it.isTop) {\n    var $top = it.isTop,\n      $lvl = it.level = 0,\n      $dataLvl = it.dataLevel = 0,\n      $data = 'data';\n    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));\n    it.baseId = it.baseId || it.rootId;\n    delete it.isTop;\n    it.dataPathArr = [\"\"];\n    if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {\n      var $defaultMsg = 'default is ignored in the schema root';\n      if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);\n      else throw new Error($defaultMsg);\n    }\n    out += ' var vErrors = null; ';\n    out += ' var errors = 0;     ';\n    out += ' if (rootData === undefined) rootData = data; ';\n  } else {\n    var $lvl = it.level,\n      $dataLvl = it.dataLevel,\n      $data = 'data' + ($dataLvl || '');\n    if ($id) it.baseId = it.resolve.url(it.baseId, $id);\n    if ($async && !it.async) throw new Error('async schema in sync schema');\n    out += ' var errs_' + ($lvl) + ' = errors;';\n  }\n  var $valid = 'valid' + $lvl,\n    $breakOnError = !it.opts.allErrors,\n    $closingBraces1 = '',\n    $closingBraces2 = '';\n  var $errorKeyword;\n  var $typeSchema = it.schema.type,\n    $typeIsArray = Array.isArray($typeSchema);\n  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {\n    if ($typeIsArray) {\n      if ($typeSchema.indexOf('null') == -1) $typeSchema = $typeSchema.concat('null');\n    } else if ($typeSchema != 'null') {\n      $typeSchema = [$typeSchema, 'null'];\n      $typeIsArray = true;\n    }\n  }\n  if ($typeIsArray && $typeSchema.length == 1) {\n    $typeSchema = $typeSchema[0];\n    $typeIsArray = false;\n  }\n  if (it.schema.$ref && $refKeywords) {\n    if (it.opts.extendRefs == 'fail') {\n      throw new Error('$ref: validation keywords used in schema at path \"' + it.errSchemaPath + '\" (see option extendRefs)');\n    } else if (it.opts.extendRefs !== true) {\n      $refKeywords = false;\n      it.logger.warn('$ref: keywords ignored in schema at path \"' + it.errSchemaPath + '\"');\n    }\n  }\n  if (it.schema.$comment && it.opts.$comment) {\n    out += ' ' + (it.RULES.all.$comment.code(it, '$comment'));\n  }\n  if ($typeSchema) {\n    if (it.opts.coerceTypes) {\n      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);\n    }\n    var $rulesGroup = it.RULES.types[$typeSchema];\n    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {\n      var $schemaPath = it.schemaPath + '.type',\n        $errSchemaPath = it.errSchemaPath + '/type';\n      var $schemaPath = it.schemaPath + '.type',\n        $errSchemaPath = it.errSchemaPath + '/type',\n        $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';\n      out += ' if (' + (it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true)) + ') { ';\n      if ($coerceToTypes) {\n        var $dataType = 'dataType' + $lvl,\n          $coerced = 'coerced' + $lvl;\n        out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; var ' + ($coerced) + ' = undefined; ';\n        if (it.opts.coerceTypes == 'array') {\n          out += ' if (' + ($dataType) + ' == \\'object\\' && Array.isArray(' + ($data) + ') && ' + ($data) + '.length == 1) { ' + ($data) + ' = ' + ($data) + '[0]; ' + ($dataType) + ' = typeof ' + ($data) + '; if (' + (it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers)) + ') ' + ($coerced) + ' = ' + ($data) + '; } ';\n        }\n        out += ' if (' + ($coerced) + ' !== undefined) ; ';\n        var arr1 = $coerceToTypes;\n        if (arr1) {\n          var $type, $i = -1,\n            l1 = arr1.length - 1;\n          while ($i < l1) {\n            $type = arr1[$i += 1];\n            if ($type == 'string') {\n              out += ' else if (' + ($dataType) + ' == \\'number\\' || ' + ($dataType) + ' == \\'boolean\\') ' + ($coerced) + ' = \\'\\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \\'\\'; ';\n            } else if ($type == 'number' || $type == 'integer') {\n              out += ' else if (' + ($dataType) + ' == \\'boolean\\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \\'string\\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';\n              if ($type == 'integer') {\n                out += ' && !(' + ($data) + ' % 1)';\n              }\n              out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';\n            } else if ($type == 'boolean') {\n              out += ' else if (' + ($data) + ' === \\'false\\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \\'true\\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';\n            } else if ($type == 'null') {\n              out += ' else if (' + ($data) + ' === \\'\\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';\n            } else if (it.opts.coerceTypes == 'array' && $type == 'array') {\n              out += ' else if (' + ($dataType) + ' == \\'string\\' || ' + ($dataType) + ' == \\'number\\' || ' + ($dataType) + ' == \\'boolean\\' || ' + ($data) + ' == null) ' + ($coerced) + ' = [' + ($data) + ']; ';\n            }\n          }\n        }\n        out += ' else {   ';\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ($errorKeyword || 'type') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \\'';\n          if ($typeIsArray) {\n            out += '' + ($typeSchema.join(\",\"));\n          } else {\n            out += '' + ($typeSchema);\n          }\n          out += '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'should be ';\n            if ($typeIsArray) {\n              out += '' + ($typeSchema.join(\",\"));\n            } else {\n              out += '' + ($typeSchema);\n            }\n            out += '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        out += ' } if (' + ($coerced) + ' !== undefined) {  ';\n        var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',\n          $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';\n        out += ' ' + ($data) + ' = ' + ($coerced) + '; ';\n        if (!$dataLvl) {\n          out += 'if (' + ($parentData) + ' !== undefined)';\n        }\n        out += ' ' + ($parentData) + '[' + ($parentDataProperty) + '] = ' + ($coerced) + '; } ';\n      } else {\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ($errorKeyword || 'type') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \\'';\n          if ($typeIsArray) {\n            out += '' + ($typeSchema.join(\",\"));\n          } else {\n            out += '' + ($typeSchema);\n          }\n          out += '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'should be ';\n            if ($typeIsArray) {\n              out += '' + ($typeSchema.join(\",\"));\n            } else {\n              out += '' + ($typeSchema);\n            }\n            out += '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n      }\n      out += ' } ';\n    }\n  }\n  if (it.schema.$ref && !$refKeywords) {\n    out += ' ' + (it.RULES.all.$ref.code(it, '$ref')) + ' ';\n    if ($breakOnError) {\n      out += ' } if (errors === ';\n      if ($top) {\n        out += '0';\n      } else {\n        out += 'errs_' + ($lvl);\n      }\n      out += ') { ';\n      $closingBraces2 += '}';\n    }\n  } else {\n    var arr2 = it.RULES;\n    if (arr2) {\n      var $rulesGroup, i2 = -1,\n        l2 = arr2.length - 1;\n      while (i2 < l2) {\n        $rulesGroup = arr2[i2 += 1];\n        if ($shouldUseGroup($rulesGroup)) {\n          if ($rulesGroup.type) {\n            out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers)) + ') { ';\n          }\n          if (it.opts.useDefaults) {\n            if ($rulesGroup.type == 'object' && it.schema.properties) {\n              var $schema = it.schema.properties,\n                $schemaKeys = Object.keys($schema);\n              var arr3 = $schemaKeys;\n              if (arr3) {\n                var $propertyKey, i3 = -1,\n                  l3 = arr3.length - 1;\n                while (i3 < l3) {\n                  $propertyKey = arr3[i3 += 1];\n                  var $sch = $schema[$propertyKey];\n                  if ($sch.default !== undefined) {\n                    var $passData = $data + it.util.getProperty($propertyKey);\n                    if (it.compositeRule) {\n                      if (it.opts.strictDefaults) {\n                        var $defaultMsg = 'default is ignored for: ' + $passData;\n                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);\n                        else throw new Error($defaultMsg);\n                      }\n                    } else {\n                      out += ' if (' + ($passData) + ' === undefined ';\n                      if (it.opts.useDefaults == 'empty') {\n                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \\'\\' ';\n                      }\n                      out += ' ) ' + ($passData) + ' = ';\n                      if (it.opts.useDefaults == 'shared') {\n                        out += ' ' + (it.useDefault($sch.default)) + ' ';\n                      } else {\n                        out += ' ' + (JSON.stringify($sch.default)) + ' ';\n                      }\n                      out += '; ';\n                    }\n                  }\n                }\n              }\n            } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {\n              var arr4 = it.schema.items;\n              if (arr4) {\n                var $sch, $i = -1,\n                  l4 = arr4.length - 1;\n                while ($i < l4) {\n                  $sch = arr4[$i += 1];\n                  if ($sch.default !== undefined) {\n                    var $passData = $data + '[' + $i + ']';\n                    if (it.compositeRule) {\n                      if (it.opts.strictDefaults) {\n                        var $defaultMsg = 'default is ignored for: ' + $passData;\n                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);\n                        else throw new Error($defaultMsg);\n                      }\n                    } else {\n                      out += ' if (' + ($passData) + ' === undefined ';\n                      if (it.opts.useDefaults == 'empty') {\n                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \\'\\' ';\n                      }\n                      out += ' ) ' + ($passData) + ' = ';\n                      if (it.opts.useDefaults == 'shared') {\n                        out += ' ' + (it.useDefault($sch.default)) + ' ';\n                      } else {\n                        out += ' ' + (JSON.stringify($sch.default)) + ' ';\n                      }\n                      out += '; ';\n                    }\n                  }\n                }\n              }\n            }\n          }\n          var arr5 = $rulesGroup.rules;\n          if (arr5) {\n            var $rule, i5 = -1,\n              l5 = arr5.length - 1;\n            while (i5 < l5) {\n              $rule = arr5[i5 += 1];\n              if ($shouldUseRule($rule)) {\n                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);\n                if ($code) {\n                  out += ' ' + ($code) + ' ';\n                  if ($breakOnError) {\n                    $closingBraces1 += '}';\n                  }\n                }\n              }\n            }\n          }\n          if ($breakOnError) {\n            out += ' ' + ($closingBraces1) + ' ';\n            $closingBraces1 = '';\n          }\n          if ($rulesGroup.type) {\n            out += ' } ';\n            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {\n              out += ' else { ';\n              var $schemaPath = it.schemaPath + '.type',\n                $errSchemaPath = it.errSchemaPath + '/type';\n              var $$outStack = $$outStack || [];\n              $$outStack.push(out);\n              out = ''; /* istanbul ignore else */\n              if (it.createErrors !== false) {\n                out += ' { keyword: \\'' + ($errorKeyword || 'type') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \\'';\n                if ($typeIsArray) {\n                  out += '' + ($typeSchema.join(\",\"));\n                } else {\n                  out += '' + ($typeSchema);\n                }\n                out += '\\' } ';\n                if (it.opts.messages !== false) {\n                  out += ' , message: \\'should be ';\n                  if ($typeIsArray) {\n                    out += '' + ($typeSchema.join(\",\"));\n                  } else {\n                    out += '' + ($typeSchema);\n                  }\n                  out += '\\' ';\n                }\n                if (it.opts.verbose) {\n                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n                }\n                out += ' } ';\n              } else {\n                out += ' {} ';\n              }\n              var __err = out;\n              out = $$outStack.pop();\n              if (!it.compositeRule && $breakOnError) {\n                /* istanbul ignore if */\n                if (it.async) {\n                  out += ' throw new ValidationError([' + (__err) + ']); ';\n                } else {\n                  out += ' validate.errors = [' + (__err) + ']; return false; ';\n                }\n              } else {\n                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n              }\n              out += ' } ';\n            }\n          }\n          if ($breakOnError) {\n            out += ' if (errors === ';\n            if ($top) {\n              out += '0';\n            } else {\n              out += 'errs_' + ($lvl);\n            }\n            out += ') { ';\n            $closingBraces2 += '}';\n          }\n        }\n      }\n    }\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces2) + ' ';\n  }\n  if ($top) {\n    if ($async) {\n      out += ' if (errors === 0) return data;           ';\n      out += ' else throw new ValidationError(vErrors); ';\n    } else {\n      out += ' validate.errors = vErrors; ';\n      out += ' return errors === 0;       ';\n    }\n    out += ' }; return validate;';\n  } else {\n    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';\n  }\n\n  function $shouldUseGroup($rulesGroup) {\n    var rules = $rulesGroup.rules;\n    for (var i = 0; i < rules.length; i++)\n      if ($shouldUseRule(rules[i])) return true;\n  }\n\n  function $shouldUseRule($rule) {\n    return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImplementsSomeKeyword($rule));\n  }\n\n  function $ruleImplementsSomeKeyword($rule) {\n    var impl = $rule.implements;\n    for (var i = 0; i < impl.length; i++)\n      if (it.schema[impl[i]] !== undefined) return true;\n  }\n  return out;\n}\n", "'use strict';\n\nvar resolve = require('./resolve')\n  , util = require('./util')\n  , errorClasses = require('./error_classes')\n  , stableStringify = require('fast-json-stable-stringify');\n\nvar validateGenerator = require('../dotjs/validate');\n\n/**\n * Functions below are used inside compiled validations function\n */\n\nvar ucs2length = util.ucs2length;\nvar equal = require('fast-deep-equal');\n\n// this error is thrown by async schemas to return validation errors via exception\nvar ValidationError = errorClasses.Validation;\n\nmodule.exports = compile;\n\n\n/**\n * Compiles schema to validation function\n * @this   Ajv\n * @param  {Object} schema schema object\n * @param  {Object} root object with information about the root schema for this schema\n * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution\n * @param  {String} baseId base ID for IDs in the schema\n * @return {Function} validation function\n */\nfunction compile(schema, root, localRefs, baseId) {\n  /* jshint validthis: true, evil: true */\n  /* eslint no-shadow: 0 */\n  var self = this\n    , opts = this._opts\n    , refVal = [ undefined ]\n    , refs = {}\n    , patterns = []\n    , patternsHash = {}\n    , defaults = []\n    , defaultsHash = {}\n    , customRules = [];\n\n  root = root || { schema: schema, refVal: refVal, refs: refs };\n\n  var c = checkCompiling.call(this, schema, root, baseId);\n  var compilation = this._compilations[c.index];\n  if (c.compiling) return (compilation.callValidate = callValidate);\n\n  var formats = this._formats;\n  var RULES = this.RULES;\n\n  try {\n    var v = localCompile(schema, root, localRefs, baseId);\n    compilation.validate = v;\n    var cv = compilation.callValidate;\n    if (cv) {\n      cv.schema = v.schema;\n      cv.errors = null;\n      cv.refs = v.refs;\n      cv.refVal = v.refVal;\n      cv.root = v.root;\n      cv.$async = v.$async;\n      if (opts.sourceCode) cv.source = v.source;\n    }\n    return v;\n  } finally {\n    endCompiling.call(this, schema, root, baseId);\n  }\n\n  /* @this   {*} - custom context, see passContext option */\n  function callValidate() {\n    /* jshint validthis: true */\n    var validate = compilation.validate;\n    var result = validate.apply(this, arguments);\n    callValidate.errors = validate.errors;\n    return result;\n  }\n\n  function localCompile(_schema, _root, localRefs, baseId) {\n    var isRoot = !_root || (_root && _root.schema == _schema);\n    if (_root.schema != root.schema)\n      return compile.call(self, _schema, _root, localRefs, baseId);\n\n    var $async = _schema.$async === true;\n\n    var sourceCode = validateGenerator({\n      isTop: true,\n      schema: _schema,\n      isRoot: isRoot,\n      baseId: baseId,\n      root: _root,\n      schemaPath: '',\n      errSchemaPath: '#',\n      errorPath: '\"\"',\n      MissingRefError: errorClasses.MissingRef,\n      RULES: RULES,\n      validate: validateGenerator,\n      util: util,\n      resolve: resolve,\n      resolveRef: resolveRef,\n      usePattern: usePattern,\n      useDefault: useDefault,\n      useCustomRule: useCustomRule,\n      opts: opts,\n      formats: formats,\n      logger: self.logger,\n      self: self\n    });\n\n    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)\n                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode)\n                   + sourceCode;\n\n    if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);\n    // console.log('\\n\\n\\n *** \\n', JSON.stringify(sourceCode));\n    var validate;\n    try {\n      var makeValidate = new Function(\n        'self',\n        'RULES',\n        'formats',\n        'root',\n        'refVal',\n        'defaults',\n        'customRules',\n        'equal',\n        'ucs2length',\n        'ValidationError',\n        sourceCode\n      );\n\n      validate = makeValidate(\n        self,\n        RULES,\n        formats,\n        root,\n        refVal,\n        defaults,\n        customRules,\n        equal,\n        ucs2length,\n        ValidationError\n      );\n\n      refVal[0] = validate;\n    } catch(e) {\n      self.logger.error('Error compiling schema, function code:', sourceCode);\n      throw e;\n    }\n\n    validate.schema = _schema;\n    validate.errors = null;\n    validate.refs = refs;\n    validate.refVal = refVal;\n    validate.root = isRoot ? validate : _root;\n    if ($async) validate.$async = true;\n    if (opts.sourceCode === true) {\n      validate.source = {\n        code: sourceCode,\n        patterns: patterns,\n        defaults: defaults\n      };\n    }\n\n    return validate;\n  }\n\n  function resolveRef(baseId, ref, isRoot) {\n    ref = resolve.url(baseId, ref);\n    var refIndex = refs[ref];\n    var _refVal, refCode;\n    if (refIndex !== undefined) {\n      _refVal = refVal[refIndex];\n      refCode = 'refVal[' + refIndex + ']';\n      return resolvedRef(_refVal, refCode);\n    }\n    if (!isRoot && root.refs) {\n      var rootRefId = root.refs[ref];\n      if (rootRefId !== undefined) {\n        _refVal = root.refVal[rootRefId];\n        refCode = addLocalRef(ref, _refVal);\n        return resolvedRef(_refVal, refCode);\n      }\n    }\n\n    refCode = addLocalRef(ref);\n    var v = resolve.call(self, localCompile, root, ref);\n    if (v === undefined) {\n      var localSchema = localRefs && localRefs[ref];\n      if (localSchema) {\n        v = resolve.inlineRef(localSchema, opts.inlineRefs)\n            ? localSchema\n            : compile.call(self, localSchema, root, localRefs, baseId);\n      }\n    }\n\n    if (v === undefined) {\n      removeLocalRef(ref);\n    } else {\n      replaceLocalRef(ref, v);\n      return resolvedRef(v, refCode);\n    }\n  }\n\n  function addLocalRef(ref, v) {\n    var refId = refVal.length;\n    refVal[refId] = v;\n    refs[ref] = refId;\n    return 'refVal' + refId;\n  }\n\n  function removeLocalRef(ref) {\n    delete refs[ref];\n  }\n\n  function replaceLocalRef(ref, v) {\n    var refId = refs[ref];\n    refVal[refId] = v;\n  }\n\n  function resolvedRef(refVal, code) {\n    return typeof refVal == 'object' || typeof refVal == 'boolean'\n            ? { code: code, schema: refVal, inline: true }\n            : { code: code, $async: refVal && !!refVal.$async };\n  }\n\n  function usePattern(regexStr) {\n    var index = patternsHash[regexStr];\n    if (index === undefined) {\n      index = patternsHash[regexStr] = patterns.length;\n      patterns[index] = regexStr;\n    }\n    return 'pattern' + index;\n  }\n\n  function useDefault(value) {\n    switch (typeof value) {\n      case 'boolean':\n      case 'number':\n        return '' + value;\n      case 'string':\n        return util.toQuotedString(value);\n      case 'object':\n        if (value === null) return 'null';\n        var valueStr = stableStringify(value);\n        var index = defaultsHash[valueStr];\n        if (index === undefined) {\n          index = defaultsHash[valueStr] = defaults.length;\n          defaults[index] = value;\n        }\n        return 'default' + index;\n    }\n  }\n\n  function useCustomRule(rule, schema, parentSchema, it) {\n    if (self._opts.validateSchema !== false) {\n      var deps = rule.definition.dependencies;\n      if (deps && !deps.every(function(keyword) {\n        return Object.prototype.hasOwnProperty.call(parentSchema, keyword);\n      }))\n        throw new Error('parent schema must have all required keywords: ' + deps.join(','));\n\n      var validateSchema = rule.definition.validateSchema;\n      if (validateSchema) {\n        var valid = validateSchema(schema);\n        if (!valid) {\n          var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);\n          if (self._opts.validateSchema == 'log') self.logger.error(message);\n          else throw new Error(message);\n        }\n      }\n    }\n\n    var compile = rule.definition.compile\n      , inline = rule.definition.inline\n      , macro = rule.definition.macro;\n\n    var validate;\n    if (compile) {\n      validate = compile.call(self, schema, parentSchema, it);\n    } else if (macro) {\n      validate = macro.call(self, schema, parentSchema, it);\n      if (opts.validateSchema !== false) self.validateSchema(validate, true);\n    } else if (inline) {\n      validate = inline.call(self, it, rule.keyword, schema, parentSchema);\n    } else {\n      validate = rule.definition.validate;\n      if (!validate) return;\n    }\n\n    if (validate === undefined)\n      throw new Error('custom keyword \"' + rule.keyword + '\"failed to compile');\n\n    var index = customRules.length;\n    customRules[index] = validate;\n\n    return {\n      code: 'customRule' + index,\n      validate: validate\n    };\n  }\n}\n\n\n/**\n * Checks if the schema is currently compiled\n * @this   Ajv\n * @param  {Object} schema schema to compile\n * @param  {Object} root root object\n * @param  {String} baseId base schema ID\n * @return {Object} object with properties \"index\" (compilation index) and \"compiling\" (boolean)\n */\nfunction checkCompiling(schema, root, baseId) {\n  /* jshint validthis: true */\n  var index = compIndex.call(this, schema, root, baseId);\n  if (index >= 0) return { index: index, compiling: true };\n  index = this._compilations.length;\n  this._compilations[index] = {\n    schema: schema,\n    root: root,\n    baseId: baseId\n  };\n  return { index: index, compiling: false };\n}\n\n\n/**\n * Removes the schema from the currently compiled list\n * @this   Ajv\n * @param  {Object} schema schema to compile\n * @param  {Object} root root object\n * @param  {String} baseId base schema ID\n */\nfunction endCompiling(schema, root, baseId) {\n  /* jshint validthis: true */\n  var i = compIndex.call(this, schema, root, baseId);\n  if (i >= 0) this._compilations.splice(i, 1);\n}\n\n\n/**\n * Index of schema compilation in the currently compiled list\n * @this   Ajv\n * @param  {Object} schema schema to compile\n * @param  {Object} root root object\n * @param  {String} baseId base schema ID\n * @return {Integer} compilation index\n */\nfunction compIndex(schema, root, baseId) {\n  /* jshint validthis: true */\n  for (var i=0; i<this._compilations.length; i++) {\n    var c = this._compilations[i];\n    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;\n  }\n  return -1;\n}\n\n\nfunction patternCode(i, patterns) {\n  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';\n}\n\n\nfunction defaultCode(i) {\n  return 'var default' + i + ' = defaults[' + i + '];';\n}\n\n\nfunction refValCode(i, refVal) {\n  return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';\n}\n\n\nfunction customRuleCode(i) {\n  return 'var customRule' + i + ' = customRules[' + i + '];';\n}\n\n\nfunction vars(arr, statement) {\n  if (!arr.length) return '';\n  var code = '';\n  for (var i=0; i<arr.length; i++)\n    code += statement(i, arr);\n  return code;\n}\n", "'use strict';\n\n\nvar Cache = module.exports = function Cache() {\n  this._cache = {};\n};\n\n\nCache.prototype.put = function Cache_put(key, value) {\n  this._cache[key] = value;\n};\n\n\nCache.prototype.get = function Cache_get(key) {\n  return this._cache[key];\n};\n\n\nCache.prototype.del = function Cache_del(key) {\n  delete this._cache[key];\n};\n\n\nCache.prototype.clear = function Cache_clear() {\n  this._cache = {};\n};\n", "'use strict';\n\nvar util = require('./util');\n\nvar DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\nvar DAYS = [0,31,28,31,30,31,30,31,31,30,31,30,31];\nvar TIME = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nvar HOSTNAME = /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i;\nvar URI = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\nvar URIREF = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n// uri-template: https://tools.ietf.org/html/rfc6570\nvar URITEMPLATE = /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;\n// For the source: https://gist.github.com/dperini/729294\n// For test cases: https://mathiasbynens.be/demo/url-regex\n// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.\n// var URL = /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-)*[a-z\\u{00a1}-\\u{ffff}0-9]+)(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-)*[a-z\\u{00a1}-\\u{ffff}0-9]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu;\nvar URL = /^(?:(?:http[s\\u017F]?|ftp):\\/\\/)(?:(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+(?::(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?@)?(?:(?!10(?:\\.[0-9]{1,3}){3})(?!127(?:\\.[0-9]{1,3}){3})(?!169\\.254(?:\\.[0-9]{1,3}){2})(?!192\\.168(?:\\.[0-9]{1,3}){2})(?!172\\.(?:1[6-9]|2[0-9]|3[01])(?:\\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-)*(?:[0-9a-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)(?:\\.(?:(?:[0-9a-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-)*(?:[0-9a-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)*(?:\\.(?:(?:[a-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\\/(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?$/i;\nvar UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;\nvar JSON_POINTER = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;\nvar JSON_POINTER_URI_FRAGMENT = /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;\nvar RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;\n\n\nmodule.exports = formats;\n\nfunction formats(mode) {\n  mode = mode == 'full' ? 'full' : 'fast';\n  return util.copy(formats[mode]);\n}\n\n\nformats.fast = {\n  // date: http://tools.ietf.org/html/rfc3339#section-5.6\n  date: /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/,\n  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n  time: /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i,\n  'date-time': /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s](?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i,\n  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n  uri: /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/)?[^\\s]*$/i,\n  'uri-reference': /^(?:(?:[a-z][a-z0-9+\\-.]*:)?\\/?\\/)?(?:[^\\\\\\s#][^\\s#]*)?(?:#[^\\\\\\s]*)?$/i,\n  'uri-template': URITEMPLATE,\n  url: URL,\n  // email (sources from jsen validator):\n  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363\n  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')\n  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,\n  hostname: HOSTNAME,\n  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses\n  ipv6: /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,\n  regex: regex,\n  // uuid: http://tools.ietf.org/html/rfc4122\n  uuid: UUID,\n  // JSON-pointer: https://tools.ietf.org/html/rfc6901\n  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n  'json-pointer': JSON_POINTER,\n  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,\n  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00\n  'relative-json-pointer': RELATIVE_JSON_POINTER\n};\n\n\nformats.full = {\n  date: date,\n  time: time,\n  'date-time': date_time,\n  uri: uri,\n  'uri-reference': URIREF,\n  'uri-template': URITEMPLATE,\n  url: URL,\n  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n  hostname: HOSTNAME,\n  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n  ipv6: /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,\n  regex: regex,\n  uuid: UUID,\n  'json-pointer': JSON_POINTER,\n  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,\n  'relative-json-pointer': RELATIVE_JSON_POINTER\n};\n\n\nfunction isLeapYear(year) {\n  // https://tools.ietf.org/html/rfc3339#appendix-C\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n\n\nfunction date(str) {\n  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n  var matches = str.match(DATE);\n  if (!matches) return false;\n\n  var year = +matches[1];\n  var month = +matches[2];\n  var day = +matches[3];\n\n  return month >= 1 && month <= 12 && day >= 1 &&\n          day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);\n}\n\n\nfunction time(str, full) {\n  var matches = str.match(TIME);\n  if (!matches) return false;\n\n  var hour = matches[1];\n  var minute = matches[2];\n  var second = matches[3];\n  var timeZone = matches[5];\n  return ((hour <= 23 && minute <= 59 && second <= 59) ||\n          (hour == 23 && minute == 59 && second == 60)) &&\n         (!full || timeZone);\n}\n\n\nvar DATE_TIME_SEPARATOR = /t|\\s/i;\nfunction date_time(str) {\n  // http://tools.ietf.org/html/rfc3339#section-5.6\n  var dateTime = str.split(DATE_TIME_SEPARATOR);\n  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);\n}\n\n\nvar NOT_URI_FRAGMENT = /\\/|:/;\nfunction uri(str) {\n  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n  return NOT_URI_FRAGMENT.test(str) && URI.test(str);\n}\n\n\nvar Z_ANCHOR = /[^\\\\]\\\\Z/;\nfunction regex(str) {\n  if (Z_ANCHOR.test(str)) return false;\n  try {\n    new RegExp(str);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n", "'use strict';\nmodule.exports = function generate_ref(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $async, $refCode;\n  if ($schema == '#' || $schema == '#/') {\n    if (it.isRoot) {\n      $async = it.async;\n      $refCode = 'validate';\n    } else {\n      $async = it.root.schema.$async === true;\n      $refCode = 'root.refVal[0]';\n    }\n  } else {\n    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);\n    if ($refVal === undefined) {\n      var $message = it.MissingRefError.message(it.baseId, $schema);\n      if (it.opts.missingRefs == 'fail') {\n        it.logger.error($message);\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ('$ref') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { ref: \\'' + (it.util.escapeQuotes($schema)) + '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'can\\\\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        if ($breakOnError) {\n          out += ' if (false) { ';\n        }\n      } else if (it.opts.missingRefs == 'ignore') {\n        it.logger.warn($message);\n        if ($breakOnError) {\n          out += ' if (true) { ';\n        }\n      } else {\n        throw new it.MissingRefError(it.baseId, $schema, $message);\n      }\n    } else if ($refVal.inline) {\n      var $it = it.util.copy(it);\n      $it.level++;\n      var $nextValid = 'valid' + $it.level;\n      $it.schema = $refVal.schema;\n      $it.schemaPath = '';\n      $it.errSchemaPath = $schema;\n      var $code = it.validate($it).replace(/validate\\.schema/g, $refVal.code);\n      out += ' ' + ($code) + ' ';\n      if ($breakOnError) {\n        out += ' if (' + ($nextValid) + ') { ';\n      }\n    } else {\n      $async = $refVal.$async === true || (it.async && $refVal.$async !== false);\n      $refCode = $refVal.code;\n    }\n  }\n  if ($refCode) {\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = '';\n    if (it.opts.passContext) {\n      out += ' ' + ($refCode) + '.call(this, ';\n    } else {\n      out += ' ' + ($refCode) + '( ';\n    }\n    out += ' ' + ($data) + ', (dataPath || \\'\\')';\n    if (it.errorPath != '\"\"') {\n      out += ' + ' + (it.errorPath);\n    }\n    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',\n      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';\n    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ', rootData)  ';\n    var __callValidate = out;\n    out = $$outStack.pop();\n    if ($async) {\n      if (!it.async) throw new Error('async schema referenced by sync schema');\n      if ($breakOnError) {\n        out += ' var ' + ($valid) + '; ';\n      }\n      out += ' try { await ' + (__callValidate) + '; ';\n      if ($breakOnError) {\n        out += ' ' + ($valid) + ' = true; ';\n      }\n      out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';\n      if ($breakOnError) {\n        out += ' ' + ($valid) + ' = false; ';\n      }\n      out += ' } ';\n      if ($breakOnError) {\n        out += ' if (' + ($valid) + ') { ';\n      }\n    } else {\n      out += ' if (!' + (__callValidate) + ') { if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; } ';\n      if ($breakOnError) {\n        out += ' else { ';\n      }\n    }\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate_allOf(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $currentBaseId = $it.baseId,\n    $allSchemasEmpty = true;\n  var arr1 = $schema;\n  if (arr1) {\n    var $sch, $i = -1,\n      l1 = arr1.length - 1;\n    while ($i < l1) {\n      $sch = arr1[$i += 1];\n      if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {\n        $allSchemasEmpty = false;\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + '[' + $i + ']';\n        $it.errSchemaPath = $errSchemaPath + '/' + $i;\n        out += '  ' + (it.validate($it)) + ' ';\n        $it.baseId = $currentBaseId;\n        if ($breakOnError) {\n          out += ' if (' + ($nextValid) + ') { ';\n          $closingBraces += '}';\n        }\n      }\n    }\n  }\n  if ($breakOnError) {\n    if ($allSchemasEmpty) {\n      out += ' if (true) { ';\n    } else {\n      out += ' ' + ($closingBraces.slice(0, -1)) + ' ';\n    }\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate_anyOf(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $noEmptySchema = $schema.every(function($sch) {\n    return (it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all));\n  });\n  if ($noEmptySchema) {\n    var $currentBaseId = $it.baseId;\n    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    var arr1 = $schema;\n    if (arr1) {\n      var $sch, $i = -1,\n        l1 = arr1.length - 1;\n      while ($i < l1) {\n        $sch = arr1[$i += 1];\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + '[' + $i + ']';\n        $it.errSchemaPath = $errSchemaPath + '/' + $i;\n        out += '  ' + (it.validate($it)) + ' ';\n        $it.baseId = $currentBaseId;\n        out += ' ' + ($valid) + ' = ' + ($valid) + ' || ' + ($nextValid) + '; if (!' + ($valid) + ') { ';\n        $closingBraces += '}';\n      }\n    }\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('anyOf') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should match some schema in anyOf\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError(vErrors); ';\n      } else {\n        out += ' validate.errors = vErrors; return false; ';\n      }\n    }\n    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';\n    if (it.opts.allErrors) {\n      out += ' } ';\n    }\n  } else {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate_comment(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $schema = it.schema[$keyword];\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $comment = it.util.toQuotedString($schema);\n  if (it.opts.$comment === true) {\n    out += ' console.log(' + ($comment) + ');';\n  } else if (typeof it.opts.$comment == 'function') {\n    out += ' self._opts.$comment(' + ($comment) + ', ' + (it.util.toQuotedString($errSchemaPath)) + ', validate.root.schema);';\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate_const(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  if (!$isData) {\n    out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';\n  }\n  out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') {   ';\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('const') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValue: schema' + ($lvl) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be equal to constant\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' }';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate_contains(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $idx = 'i' + $lvl,\n    $dataNxt = $it.dataLevel = it.dataLevel + 1,\n    $nextData = 'data' + $dataNxt,\n    $currentBaseId = it.baseId,\n    $nonEmptySchema = (it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all));\n  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';\n  if ($nonEmptySchema) {\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    $it.errSchemaPath = $errSchemaPath;\n    out += ' var ' + ($nextValid) + ' = false; for (var ' + ($idx) + ' = 0; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';\n    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);\n    var $passData = $data + '[' + $idx + ']';\n    $it.dataPathArr[$dataNxt] = $idx;\n    var $code = it.validate($it);\n    $it.baseId = $currentBaseId;\n    if (it.util.varOccurences($code, $nextData) < 2) {\n      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n    } else {\n      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n    }\n    out += ' if (' + ($nextValid) + ') break; }  ';\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' ' + ($closingBraces) + ' if (!' + ($nextValid) + ') {';\n  } else {\n    out += ' if (' + ($data) + '.length == 0) {';\n  }\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('contains') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should contain a valid item\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' } else { ';\n  if ($nonEmptySchema) {\n    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';\n  }\n  if (it.opts.allErrors) {\n    out += ' } ';\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate_dependencies(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $schemaDeps = {},\n    $propertyDeps = {},\n    $ownProperties = it.opts.ownProperties;\n  for ($property in $schema) {\n    if ($property == '__proto__') continue;\n    var $sch = $schema[$property];\n    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;\n    $deps[$property] = $sch;\n  }\n  out += 'var ' + ($errs) + ' = errors;';\n  var $currentErrorPath = it.errorPath;\n  out += 'var missing' + ($lvl) + ';';\n  for (var $property in $propertyDeps) {\n    $deps = $propertyDeps[$property];\n    if ($deps.length) {\n      out += ' if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';\n      if ($ownProperties) {\n        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($property)) + '\\') ';\n      }\n      if ($breakOnError) {\n        out += ' && ( ';\n        var arr1 = $deps;\n        if (arr1) {\n          var $propertyKey, $i = -1,\n            l1 = arr1.length - 1;\n          while ($i < l1) {\n            $propertyKey = arr1[$i += 1];\n            if ($i) {\n              out += ' || ';\n            }\n            var $prop = it.util.getProperty($propertyKey),\n              $useData = $data + $prop;\n            out += ' ( ( ' + ($useData) + ' === undefined ';\n            if ($ownProperties) {\n              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n            }\n            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';\n          }\n        }\n        out += ')) {  ';\n        var $propertyPath = 'missing' + $lvl,\n          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';\n        if (it.opts._errorDataPathProperty) {\n          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;\n        }\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ('dependencies') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \\'' + (it.util.escapeQuotes($property)) + '\\', missingProperty: \\'' + ($missingProperty) + '\\', depsCount: ' + ($deps.length) + ', deps: \\'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(\", \"))) + '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'should have ';\n            if ($deps.length == 1) {\n              out += 'property ' + (it.util.escapeQuotes($deps[0]));\n            } else {\n              out += 'properties ' + (it.util.escapeQuotes($deps.join(\", \")));\n            }\n            out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n      } else {\n        out += ' ) { ';\n        var arr2 = $deps;\n        if (arr2) {\n          var $propertyKey, i2 = -1,\n            l2 = arr2.length - 1;\n          while (i2 < l2) {\n            $propertyKey = arr2[i2 += 1];\n            var $prop = it.util.getProperty($propertyKey),\n              $missingProperty = it.util.escapeQuotes($propertyKey),\n              $useData = $data + $prop;\n            if (it.opts._errorDataPathProperty) {\n              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);\n            }\n            out += ' if ( ' + ($useData) + ' === undefined ';\n            if ($ownProperties) {\n              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n            }\n            out += ') {  var err =   '; /* istanbul ignore else */\n            if (it.createErrors !== false) {\n              out += ' { keyword: \\'' + ('dependencies') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \\'' + (it.util.escapeQuotes($property)) + '\\', missingProperty: \\'' + ($missingProperty) + '\\', depsCount: ' + ($deps.length) + ', deps: \\'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(\", \"))) + '\\' } ';\n              if (it.opts.messages !== false) {\n                out += ' , message: \\'should have ';\n                if ($deps.length == 1) {\n                  out += 'property ' + (it.util.escapeQuotes($deps[0]));\n                } else {\n                  out += 'properties ' + (it.util.escapeQuotes($deps.join(\", \")));\n                }\n                out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\\' ';\n              }\n              if (it.opts.verbose) {\n                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n              }\n              out += ' } ';\n            } else {\n              out += ' {} ';\n            }\n            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';\n          }\n        }\n      }\n      out += ' }   ';\n      if ($breakOnError) {\n        $closingBraces += '}';\n        out += ' else { ';\n      }\n    }\n  }\n  it.errorPath = $currentErrorPath;\n  var $currentBaseId = $it.baseId;\n  for (var $property in $schemaDeps) {\n    var $sch = $schemaDeps[$property];\n    if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {\n      out += ' ' + ($nextValid) + ' = true; if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';\n      if ($ownProperties) {\n        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($property)) + '\\') ';\n      }\n      out += ') { ';\n      $it.schema = $sch;\n      $it.schemaPath = $schemaPath + it.util.getProperty($property);\n      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);\n      out += '  ' + (it.validate($it)) + ' ';\n      $it.baseId = $currentBaseId;\n      out += ' }  ';\n      if ($breakOnError) {\n        out += ' if (' + ($nextValid) + ') { ';\n        $closingBraces += '}';\n      }\n    }\n  }\n  if ($breakOnError) {\n    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate_enum(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $i = 'i' + $lvl,\n    $vSchema = 'schema' + $lvl;\n  if (!$isData) {\n    out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + ';';\n  }\n  out += 'var ' + ($valid) + ';';\n  if ($isData) {\n    out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';\n  }\n  out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<' + ($vSchema) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; }';\n  if ($isData) {\n    out += '  }  ';\n  }\n  out += ' if (!' + ($valid) + ') {   ';\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('enum') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValues: schema' + ($lvl) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be equal to one of the allowed values\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' }';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate_format(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  if (it.opts.format === false) {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n    return out;\n  }\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $unknownFormats = it.opts.unknownFormats,\n    $allowUnknown = Array.isArray($unknownFormats);\n  if ($isData) {\n    var $format = 'format' + $lvl,\n      $isObject = 'isObject' + $lvl,\n      $formatType = 'formatType' + $lvl;\n    out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var ' + ($isObject) + ' = typeof ' + ($format) + ' == \\'object\\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; var ' + ($formatType) + ' = ' + ($isObject) + ' && ' + ($format) + '.type || \\'string\\'; if (' + ($isObject) + ') { ';\n    if (it.async) {\n      out += ' var async' + ($lvl) + ' = ' + ($format) + '.async; ';\n    }\n    out += ' ' + ($format) + ' = ' + ($format) + '.validate; } if (  ';\n    if ($isData) {\n      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'string\\') || ';\n    }\n    out += ' (';\n    if ($unknownFormats != 'ignore') {\n      out += ' (' + ($schemaValue) + ' && !' + ($format) + ' ';\n      if ($allowUnknown) {\n        out += ' && self._opts.unknownFormats.indexOf(' + ($schemaValue) + ') == -1 ';\n      }\n      out += ') || ';\n    }\n    out += ' (' + ($format) + ' && ' + ($formatType) + ' == \\'' + ($ruleType) + '\\' && !(typeof ' + ($format) + ' == \\'function\\' ? ';\n    if (it.async) {\n      out += ' (async' + ($lvl) + ' ? await ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';\n    } else {\n      out += ' ' + ($format) + '(' + ($data) + ') ';\n    }\n    out += ' : ' + ($format) + '.test(' + ($data) + '))))) {';\n  } else {\n    var $format = it.formats[$schema];\n    if (!$format) {\n      if ($unknownFormats == 'ignore') {\n        it.logger.warn('unknown format \"' + $schema + '\" ignored in schema at path \"' + it.errSchemaPath + '\"');\n        if ($breakOnError) {\n          out += ' if (true) { ';\n        }\n        return out;\n      } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {\n        if ($breakOnError) {\n          out += ' if (true) { ';\n        }\n        return out;\n      } else {\n        throw new Error('unknown format \"' + $schema + '\" is used in schema at path \"' + it.errSchemaPath + '\"');\n      }\n    }\n    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;\n    var $formatType = $isObject && $format.type || 'string';\n    if ($isObject) {\n      var $async = $format.async === true;\n      $format = $format.validate;\n    }\n    if ($formatType != $ruleType) {\n      if ($breakOnError) {\n        out += ' if (true) { ';\n      }\n      return out;\n    }\n    if ($async) {\n      if (!it.async) throw new Error('async format in sync schema');\n      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';\n      out += ' if (!(await ' + ($formatRef) + '(' + ($data) + '))) { ';\n    } else {\n      out += ' if (! ';\n      var $formatRef = 'formats' + it.util.getProperty($schema);\n      if ($isObject) $formatRef += '.validate';\n      if (typeof $format == 'function') {\n        out += ' ' + ($formatRef) + '(' + ($data) + ') ';\n      } else {\n        out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';\n      }\n      out += ') { ';\n    }\n  }\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('format') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { format:  ';\n    if ($isData) {\n      out += '' + ($schemaValue);\n    } else {\n      out += '' + (it.util.toQuotedString($schema));\n    }\n    out += '  } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match format \"';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue) + ' + \\'';\n      } else {\n        out += '' + (it.util.escapeQuotes($schema));\n      }\n      out += '\"\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + (it.util.toQuotedString($schema));\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' } ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate_if(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $thenSch = it.schema['then'],\n    $elseSch = it.schema['else'],\n    $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? (typeof $thenSch == 'object' && Object.keys($thenSch).length > 0) || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)),\n    $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? (typeof $elseSch == 'object' && Object.keys($elseSch).length > 0) || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)),\n    $currentBaseId = $it.baseId;\n  if ($thenPresent || $elsePresent) {\n    var $ifClause;\n    $it.createErrors = false;\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    $it.errSchemaPath = $errSchemaPath;\n    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = true;  ';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    out += '  ' + (it.validate($it)) + ' ';\n    $it.baseId = $currentBaseId;\n    $it.createErrors = true;\n    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }  ';\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    if ($thenPresent) {\n      out += ' if (' + ($nextValid) + ') {  ';\n      $it.schema = it.schema['then'];\n      $it.schemaPath = it.schemaPath + '.then';\n      $it.errSchemaPath = it.errSchemaPath + '/then';\n      out += '  ' + (it.validate($it)) + ' ';\n      $it.baseId = $currentBaseId;\n      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';\n      if ($thenPresent && $elsePresent) {\n        $ifClause = 'ifClause' + $lvl;\n        out += ' var ' + ($ifClause) + ' = \\'then\\'; ';\n      } else {\n        $ifClause = '\\'then\\'';\n      }\n      out += ' } ';\n      if ($elsePresent) {\n        out += ' else { ';\n      }\n    } else {\n      out += ' if (!' + ($nextValid) + ') { ';\n    }\n    if ($elsePresent) {\n      $it.schema = it.schema['else'];\n      $it.schemaPath = it.schemaPath + '.else';\n      $it.errSchemaPath = it.errSchemaPath + '/else';\n      out += '  ' + (it.validate($it)) + ' ';\n      $it.baseId = $currentBaseId;\n      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';\n      if ($thenPresent && $elsePresent) {\n        $ifClause = 'ifClause' + $lvl;\n        out += ' var ' + ($ifClause) + ' = \\'else\\'; ';\n      } else {\n        $ifClause = '\\'else\\'';\n      }\n      out += ' } ';\n    }\n    out += ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('if') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { failingKeyword: ' + ($ifClause) + ' } ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should match \"\\' + ' + ($ifClause) + ' + \\'\" schema\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError(vErrors); ';\n      } else {\n        out += ' validate.errors = vErrors; return false; ';\n      }\n    }\n    out += ' }   ';\n    if ($breakOnError) {\n      out += ' else { ';\n    }\n  } else {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate_items(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $idx = 'i' + $lvl,\n    $dataNxt = $it.dataLevel = it.dataLevel + 1,\n    $nextData = 'data' + $dataNxt,\n    $currentBaseId = it.baseId;\n  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';\n  if (Array.isArray($schema)) {\n    var $additionalItems = it.schema.additionalItems;\n    if ($additionalItems === false) {\n      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';\n      var $currErrSchemaPath = $errSchemaPath;\n      $errSchemaPath = it.errSchemaPath + '/additionalItems';\n      out += '  if (!' + ($valid) + ') {   ';\n      var $$outStack = $$outStack || [];\n      $$outStack.push(out);\n      out = ''; /* istanbul ignore else */\n      if (it.createErrors !== false) {\n        out += ' { keyword: \\'' + ('additionalItems') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schema.length) + ' } ';\n        if (it.opts.messages !== false) {\n          out += ' , message: \\'should NOT have more than ' + ($schema.length) + ' items\\' ';\n        }\n        if (it.opts.verbose) {\n          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n        }\n        out += ' } ';\n      } else {\n        out += ' {} ';\n      }\n      var __err = out;\n      out = $$outStack.pop();\n      if (!it.compositeRule && $breakOnError) {\n        /* istanbul ignore if */\n        if (it.async) {\n          out += ' throw new ValidationError([' + (__err) + ']); ';\n        } else {\n          out += ' validate.errors = [' + (__err) + ']; return false; ';\n        }\n      } else {\n        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n      }\n      out += ' } ';\n      $errSchemaPath = $currErrSchemaPath;\n      if ($breakOnError) {\n        $closingBraces += '}';\n        out += ' else { ';\n      }\n    }\n    var arr1 = $schema;\n    if (arr1) {\n      var $sch, $i = -1,\n        l1 = arr1.length - 1;\n      while ($i < l1) {\n        $sch = arr1[$i += 1];\n        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {\n          out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';\n          var $passData = $data + '[' + $i + ']';\n          $it.schema = $sch;\n          $it.schemaPath = $schemaPath + '[' + $i + ']';\n          $it.errSchemaPath = $errSchemaPath + '/' + $i;\n          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);\n          $it.dataPathArr[$dataNxt] = $i;\n          var $code = it.validate($it);\n          $it.baseId = $currentBaseId;\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          out += ' }  ';\n          if ($breakOnError) {\n            out += ' if (' + ($nextValid) + ') { ';\n            $closingBraces += '}';\n          }\n        }\n      }\n    }\n    if (typeof $additionalItems == 'object' && (it.opts.strictKeywords ? (typeof $additionalItems == 'object' && Object.keys($additionalItems).length > 0) || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {\n      $it.schema = $additionalItems;\n      $it.schemaPath = it.schemaPath + '.additionalItems';\n      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';\n      out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var ' + ($idx) + ' = ' + ($schema.length) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';\n      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);\n      var $passData = $data + '[' + $idx + ']';\n      $it.dataPathArr[$dataNxt] = $idx;\n      var $code = it.validate($it);\n      $it.baseId = $currentBaseId;\n      if (it.util.varOccurences($code, $nextData) < 2) {\n        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n      } else {\n        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n      }\n      if ($breakOnError) {\n        out += ' if (!' + ($nextValid) + ') break; ';\n      }\n      out += ' } }  ';\n      if ($breakOnError) {\n        out += ' if (' + ($nextValid) + ') { ';\n        $closingBraces += '}';\n      }\n    }\n  } else if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    $it.errSchemaPath = $errSchemaPath;\n    out += '  for (var ' + ($idx) + ' = ' + (0) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';\n    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);\n    var $passData = $data + '[' + $idx + ']';\n    $it.dataPathArr[$dataNxt] = $idx;\n    var $code = it.validate($it);\n    $it.baseId = $currentBaseId;\n    if (it.util.varOccurences($code, $nextData) < 2) {\n      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n    } else {\n      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n    }\n    if ($breakOnError) {\n      out += ' if (!' + ($nextValid) + ') break; ';\n    }\n    out += ' }';\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate__limit(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $errorKeyword;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $isMax = $keyword == 'maximum',\n    $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',\n    $schemaExcl = it.schema[$exclusiveKeyword],\n    $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,\n    $op = $isMax ? '<' : '>',\n    $notOp = $isMax ? '>' : '<',\n    $errorKeyword = undefined;\n  if (!($isData || typeof $schema == 'number' || $schema === undefined)) {\n    throw new Error($keyword + ' must be number');\n  }\n  if (!($isDataExcl || $schemaExcl === undefined || typeof $schemaExcl == 'number' || typeof $schemaExcl == 'boolean')) {\n    throw new Error($exclusiveKeyword + ' must be number or boolean');\n  }\n  if ($isDataExcl) {\n    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),\n      $exclusive = 'exclusive' + $lvl,\n      $exclType = 'exclType' + $lvl,\n      $exclIsNumber = 'exclIsNumber' + $lvl,\n      $opExpr = 'op' + $lvl,\n      $opStr = '\\' + ' + $opExpr + ' + \\'';\n    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';\n    $schemaValueExcl = 'schemaExcl' + $lvl;\n    out += ' var ' + ($exclusive) + '; var ' + ($exclType) + ' = typeof ' + ($schemaValueExcl) + '; if (' + ($exclType) + ' != \\'boolean\\' && ' + ($exclType) + ' != \\'undefined\\' && ' + ($exclType) + ' != \\'number\\') { ';\n    var $errorKeyword = $exclusiveKeyword;\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = ''; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ($errorKeyword || '_exclusiveLimit') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'' + ($exclusiveKeyword) + ' should be boolean\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError([' + (__err) + ']); ';\n      } else {\n        out += ' validate.errors = [' + (__err) + ']; return false; ';\n      }\n    } else {\n      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' } else if ( ';\n    if ($isData) {\n      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n    }\n    out += ' ' + ($exclType) + ' == \\'number\\' ? ( (' + ($exclusive) + ' = ' + ($schemaValue) + ' === undefined || ' + ($schemaValueExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ') ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValueExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) : ( (' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \\'' + ($op) + '\\' : \\'' + ($op) + '=\\'; ';\n    if ($schema === undefined) {\n      $errorKeyword = $exclusiveKeyword;\n      $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;\n      $schemaValue = $schemaValueExcl;\n      $isData = $isDataExcl;\n    }\n  } else {\n    var $exclIsNumber = typeof $schemaExcl == 'number',\n      $opStr = $op;\n    if ($exclIsNumber && $isData) {\n      var $opExpr = '\\'' + $opStr + '\\'';\n      out += ' if ( ';\n      if ($isData) {\n        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n      }\n      out += ' ( ' + ($schemaValue) + ' === undefined || ' + ($schemaExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ' ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { ';\n    } else {\n      if ($exclIsNumber && $schema === undefined) {\n        $exclusive = true;\n        $errorKeyword = $exclusiveKeyword;\n        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;\n        $schemaValue = $schemaExcl;\n        $notOp += '=';\n      } else {\n        if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);\n        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {\n          $exclusive = true;\n          $errorKeyword = $exclusiveKeyword;\n          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;\n          $notOp += '=';\n        } else {\n          $exclusive = false;\n          $opStr += '=';\n        }\n      }\n      var $opExpr = '\\'' + $opStr + '\\'';\n      out += ' if ( ';\n      if ($isData) {\n        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n      }\n      out += ' ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' || ' + ($data) + ' !== ' + ($data) + ') { ';\n    }\n  }\n  $errorKeyword = $errorKeyword || $keyword;\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ($errorKeyword || '_limit') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be ' + ($opStr) + ' ';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue);\n      } else {\n        out += '' + ($schemaValue) + '\\'';\n      }\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + ($schema);\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' } ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate__limitItems(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $errorKeyword;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  if (!($isData || typeof $schema == 'number')) {\n    throw new Error($keyword + ' must be number');\n  }\n  var $op = $keyword == 'maxItems' ? '>' : '<';\n  out += 'if ( ';\n  if ($isData) {\n    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n  }\n  out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') { ';\n  var $errorKeyword = $keyword;\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ($errorKeyword || '_limitItems') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have ';\n      if ($keyword == 'maxItems') {\n        out += 'more';\n      } else {\n        out += 'fewer';\n      }\n      out += ' than ';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue) + ' + \\'';\n      } else {\n        out += '' + ($schema);\n      }\n      out += ' items\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + ($schema);\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate__limitLength(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $errorKeyword;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  if (!($isData || typeof $schema == 'number')) {\n    throw new Error($keyword + ' must be number');\n  }\n  var $op = $keyword == 'maxLength' ? '>' : '<';\n  out += 'if ( ';\n  if ($isData) {\n    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n  }\n  if (it.opts.unicode === false) {\n    out += ' ' + ($data) + '.length ';\n  } else {\n    out += ' ucs2length(' + ($data) + ') ';\n  }\n  out += ' ' + ($op) + ' ' + ($schemaValue) + ') { ';\n  var $errorKeyword = $keyword;\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ($errorKeyword || '_limitLength') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT be ';\n      if ($keyword == 'maxLength') {\n        out += 'longer';\n      } else {\n        out += 'shorter';\n      }\n      out += ' than ';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue) + ' + \\'';\n      } else {\n        out += '' + ($schema);\n      }\n      out += ' characters\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + ($schema);\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate__limitProperties(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $errorKeyword;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  if (!($isData || typeof $schema == 'number')) {\n    throw new Error($keyword + ' must be number');\n  }\n  var $op = $keyword == 'maxProperties' ? '>' : '<';\n  out += 'if ( ';\n  if ($isData) {\n    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n  }\n  out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') { ';\n  var $errorKeyword = $keyword;\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ($errorKeyword || '_limitProperties') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have ';\n      if ($keyword == 'maxProperties') {\n        out += 'more';\n      } else {\n        out += 'fewer';\n      }\n      out += ' than ';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue) + ' + \\'';\n      } else {\n        out += '' + ($schema);\n      }\n      out += ' properties\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + ($schema);\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate_multipleOf(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  if (!($isData || typeof $schema == 'number')) {\n    throw new Error($keyword + ' must be number');\n  }\n  out += 'var division' + ($lvl) + ';if (';\n  if ($isData) {\n    out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \\'number\\' || ';\n  }\n  out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';\n  if (it.opts.multipleOfPrecision) {\n    out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';\n  } else {\n    out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';\n  }\n  out += ' ) ';\n  if ($isData) {\n    out += '  )  ';\n  }\n  out += ' ) {   ';\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('multipleOf') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { multipleOf: ' + ($schemaValue) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be multiple of ';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue);\n      } else {\n        out += '' + ($schemaValue) + '\\'';\n      }\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + ($schema);\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate_not(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    $it.errSchemaPath = $errSchemaPath;\n    out += ' var ' + ($errs) + ' = errors;  ';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    $it.createErrors = false;\n    var $allErrorsOption;\n    if ($it.opts.allErrors) {\n      $allErrorsOption = $it.opts.allErrors;\n      $it.opts.allErrors = false;\n    }\n    out += ' ' + (it.validate($it)) + ' ';\n    $it.createErrors = true;\n    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' if (' + ($nextValid) + ') {   ';\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = ''; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('not') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT be valid\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError([' + (__err) + ']); ';\n      } else {\n        out += ' validate.errors = [' + (__err) + ']; return false; ';\n      }\n    } else {\n      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';\n    if (it.opts.allErrors) {\n      out += ' } ';\n    }\n  } else {\n    out += '  var err =   '; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('not') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT be valid\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    if ($breakOnError) {\n      out += ' if (false) { ';\n    }\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate_oneOf(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $currentBaseId = $it.baseId,\n    $prevValid = 'prevValid' + $lvl,\n    $passingSchemas = 'passingSchemas' + $lvl;\n  out += 'var ' + ($errs) + ' = errors , ' + ($prevValid) + ' = false , ' + ($valid) + ' = false , ' + ($passingSchemas) + ' = null; ';\n  var $wasComposite = it.compositeRule;\n  it.compositeRule = $it.compositeRule = true;\n  var arr1 = $schema;\n  if (arr1) {\n    var $sch, $i = -1,\n      l1 = arr1.length - 1;\n    while ($i < l1) {\n      $sch = arr1[$i += 1];\n      if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + '[' + $i + ']';\n        $it.errSchemaPath = $errSchemaPath + '/' + $i;\n        out += '  ' + (it.validate($it)) + ' ';\n        $it.baseId = $currentBaseId;\n      } else {\n        out += ' var ' + ($nextValid) + ' = true; ';\n      }\n      if ($i) {\n        out += ' if (' + ($nextValid) + ' && ' + ($prevValid) + ') { ' + ($valid) + ' = false; ' + ($passingSchemas) + ' = [' + ($passingSchemas) + ', ' + ($i) + ']; } else { ';\n        $closingBraces += '}';\n      }\n      out += ' if (' + ($nextValid) + ') { ' + ($valid) + ' = ' + ($prevValid) + ' = true; ' + ($passingSchemas) + ' = ' + ($i) + '; }';\n    }\n  }\n  it.compositeRule = $it.compositeRule = $wasComposite;\n  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('oneOf') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { passingSchemas: ' + ($passingSchemas) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match exactly one schema in oneOf\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError(vErrors); ';\n    } else {\n      out += ' validate.errors = vErrors; return false; ';\n    }\n  }\n  out += '} else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';\n  if (it.opts.allErrors) {\n    out += ' } ';\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate_pattern(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);\n  out += 'if ( ';\n  if ($isData) {\n    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'string\\') || ';\n  }\n  out += ' !' + ($regexp) + '.test(' + ($data) + ') ) {   ';\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('pattern') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { pattern:  ';\n    if ($isData) {\n      out += '' + ($schemaValue);\n    } else {\n      out += '' + (it.util.toQuotedString($schema));\n    }\n    out += '  } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match pattern \"';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue) + ' + \\'';\n      } else {\n        out += '' + (it.util.escapeQuotes($schema));\n      }\n      out += '\"\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + (it.util.toQuotedString($schema));\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate_properties(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $key = 'key' + $lvl,\n    $idx = 'idx' + $lvl,\n    $dataNxt = $it.dataLevel = it.dataLevel + 1,\n    $nextData = 'data' + $dataNxt,\n    $dataProperties = 'dataProperties' + $lvl;\n  var $schemaKeys = Object.keys($schema || {}).filter(notProto),\n    $pProperties = it.schema.patternProperties || {},\n    $pPropertyKeys = Object.keys($pProperties).filter(notProto),\n    $aProperties = it.schema.additionalProperties,\n    $someProperties = $schemaKeys.length || $pPropertyKeys.length,\n    $noAdditional = $aProperties === false,\n    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,\n    $removeAdditional = it.opts.removeAdditional,\n    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,\n    $ownProperties = it.opts.ownProperties,\n    $currentBaseId = it.baseId;\n  var $required = it.schema.required;\n  if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {\n    var $requiredHash = it.util.toHash($required);\n  }\n\n  function notProto(p) {\n    return p !== '__proto__';\n  }\n  out += 'var ' + ($errs) + ' = errors;var ' + ($nextValid) + ' = true;';\n  if ($ownProperties) {\n    out += ' var ' + ($dataProperties) + ' = undefined;';\n  }\n  if ($checkAdditional) {\n    if ($ownProperties) {\n      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';\n    } else {\n      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';\n    }\n    if ($someProperties) {\n      out += ' var isAdditional' + ($lvl) + ' = !(false ';\n      if ($schemaKeys.length) {\n        if ($schemaKeys.length > 8) {\n          out += ' || validate.schema' + ($schemaPath) + '.hasOwnProperty(' + ($key) + ') ';\n        } else {\n          var arr1 = $schemaKeys;\n          if (arr1) {\n            var $propertyKey, i1 = -1,\n              l1 = arr1.length - 1;\n            while (i1 < l1) {\n              $propertyKey = arr1[i1 += 1];\n              out += ' || ' + ($key) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';\n            }\n          }\n        }\n      }\n      if ($pPropertyKeys.length) {\n        var arr2 = $pPropertyKeys;\n        if (arr2) {\n          var $pProperty, $i = -1,\n            l2 = arr2.length - 1;\n          while ($i < l2) {\n            $pProperty = arr2[$i += 1];\n            out += ' || ' + (it.usePattern($pProperty)) + '.test(' + ($key) + ') ';\n          }\n        }\n      }\n      out += ' ); if (isAdditional' + ($lvl) + ') { ';\n    }\n    if ($removeAdditional == 'all') {\n      out += ' delete ' + ($data) + '[' + ($key) + ']; ';\n    } else {\n      var $currentErrorPath = it.errorPath;\n      var $additionalProperty = '\\' + ' + $key + ' + \\'';\n      if (it.opts._errorDataPathProperty) {\n        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);\n      }\n      if ($noAdditional) {\n        if ($removeAdditional) {\n          out += ' delete ' + ($data) + '[' + ($key) + ']; ';\n        } else {\n          out += ' ' + ($nextValid) + ' = false; ';\n          var $currErrSchemaPath = $errSchemaPath;\n          $errSchemaPath = it.errSchemaPath + '/additionalProperties';\n          var $$outStack = $$outStack || [];\n          $$outStack.push(out);\n          out = ''; /* istanbul ignore else */\n          if (it.createErrors !== false) {\n            out += ' { keyword: \\'' + ('additionalProperties') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { additionalProperty: \\'' + ($additionalProperty) + '\\' } ';\n            if (it.opts.messages !== false) {\n              out += ' , message: \\'';\n              if (it.opts._errorDataPathProperty) {\n                out += 'is an invalid additional property';\n              } else {\n                out += 'should NOT have additional properties';\n              }\n              out += '\\' ';\n            }\n            if (it.opts.verbose) {\n              out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n            }\n            out += ' } ';\n          } else {\n            out += ' {} ';\n          }\n          var __err = out;\n          out = $$outStack.pop();\n          if (!it.compositeRule && $breakOnError) {\n            /* istanbul ignore if */\n            if (it.async) {\n              out += ' throw new ValidationError([' + (__err) + ']); ';\n            } else {\n              out += ' validate.errors = [' + (__err) + ']; return false; ';\n            }\n          } else {\n            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n          }\n          $errSchemaPath = $currErrSchemaPath;\n          if ($breakOnError) {\n            out += ' break; ';\n          }\n        }\n      } else if ($additionalIsSchema) {\n        if ($removeAdditional == 'failing') {\n          out += ' var ' + ($errs) + ' = errors;  ';\n          var $wasComposite = it.compositeRule;\n          it.compositeRule = $it.compositeRule = true;\n          $it.schema = $aProperties;\n          $it.schemaPath = it.schemaPath + '.additionalProperties';\n          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';\n          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);\n          var $passData = $data + '[' + $key + ']';\n          $it.dataPathArr[$dataNxt] = $key;\n          var $code = it.validate($it);\n          $it.baseId = $currentBaseId;\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          out += ' if (!' + ($nextValid) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[' + ($key) + ']; }  ';\n          it.compositeRule = $it.compositeRule = $wasComposite;\n        } else {\n          $it.schema = $aProperties;\n          $it.schemaPath = it.schemaPath + '.additionalProperties';\n          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';\n          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);\n          var $passData = $data + '[' + $key + ']';\n          $it.dataPathArr[$dataNxt] = $key;\n          var $code = it.validate($it);\n          $it.baseId = $currentBaseId;\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          if ($breakOnError) {\n            out += ' if (!' + ($nextValid) + ') break; ';\n          }\n        }\n      }\n      it.errorPath = $currentErrorPath;\n    }\n    if ($someProperties) {\n      out += ' } ';\n    }\n    out += ' }  ';\n    if ($breakOnError) {\n      out += ' if (' + ($nextValid) + ') { ';\n      $closingBraces += '}';\n    }\n  }\n  var $useDefaults = it.opts.useDefaults && !it.compositeRule;\n  if ($schemaKeys.length) {\n    var arr3 = $schemaKeys;\n    if (arr3) {\n      var $propertyKey, i3 = -1,\n        l3 = arr3.length - 1;\n      while (i3 < l3) {\n        $propertyKey = arr3[i3 += 1];\n        var $sch = $schema[$propertyKey];\n        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {\n          var $prop = it.util.getProperty($propertyKey),\n            $passData = $data + $prop,\n            $hasDefault = $useDefaults && $sch.default !== undefined;\n          $it.schema = $sch;\n          $it.schemaPath = $schemaPath + $prop;\n          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);\n          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);\n          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);\n          var $code = it.validate($it);\n          $it.baseId = $currentBaseId;\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            $code = it.util.varReplace($code, $nextData, $passData);\n            var $useData = $passData;\n          } else {\n            var $useData = $nextData;\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';\n          }\n          if ($hasDefault) {\n            out += ' ' + ($code) + ' ';\n          } else {\n            if ($requiredHash && $requiredHash[$propertyKey]) {\n              out += ' if ( ' + ($useData) + ' === undefined ';\n              if ($ownProperties) {\n                out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n              }\n              out += ') { ' + ($nextValid) + ' = false; ';\n              var $currentErrorPath = it.errorPath,\n                $currErrSchemaPath = $errSchemaPath,\n                $missingProperty = it.util.escapeQuotes($propertyKey);\n              if (it.opts._errorDataPathProperty) {\n                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);\n              }\n              $errSchemaPath = it.errSchemaPath + '/required';\n              var $$outStack = $$outStack || [];\n              $$outStack.push(out);\n              out = ''; /* istanbul ignore else */\n              if (it.createErrors !== false) {\n                out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n                if (it.opts.messages !== false) {\n                  out += ' , message: \\'';\n                  if (it.opts._errorDataPathProperty) {\n                    out += 'is a required property';\n                  } else {\n                    out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n                  }\n                  out += '\\' ';\n                }\n                if (it.opts.verbose) {\n                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n                }\n                out += ' } ';\n              } else {\n                out += ' {} ';\n              }\n              var __err = out;\n              out = $$outStack.pop();\n              if (!it.compositeRule && $breakOnError) {\n                /* istanbul ignore if */\n                if (it.async) {\n                  out += ' throw new ValidationError([' + (__err) + ']); ';\n                } else {\n                  out += ' validate.errors = [' + (__err) + ']; return false; ';\n                }\n              } else {\n                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n              }\n              $errSchemaPath = $currErrSchemaPath;\n              it.errorPath = $currentErrorPath;\n              out += ' } else { ';\n            } else {\n              if ($breakOnError) {\n                out += ' if ( ' + ($useData) + ' === undefined ';\n                if ($ownProperties) {\n                  out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n                }\n                out += ') { ' + ($nextValid) + ' = true; } else { ';\n              } else {\n                out += ' if (' + ($useData) + ' !== undefined ';\n                if ($ownProperties) {\n                  out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n                }\n                out += ' ) { ';\n              }\n            }\n            out += ' ' + ($code) + ' } ';\n          }\n        }\n        if ($breakOnError) {\n          out += ' if (' + ($nextValid) + ') { ';\n          $closingBraces += '}';\n        }\n      }\n    }\n  }\n  if ($pPropertyKeys.length) {\n    var arr4 = $pPropertyKeys;\n    if (arr4) {\n      var $pProperty, i4 = -1,\n        l4 = arr4.length - 1;\n      while (i4 < l4) {\n        $pProperty = arr4[i4 += 1];\n        var $sch = $pProperties[$pProperty];\n        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {\n          $it.schema = $sch;\n          $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);\n          $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);\n          if ($ownProperties) {\n            out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';\n          } else {\n            out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';\n          }\n          out += ' if (' + (it.usePattern($pProperty)) + '.test(' + ($key) + ')) { ';\n          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);\n          var $passData = $data + '[' + $key + ']';\n          $it.dataPathArr[$dataNxt] = $key;\n          var $code = it.validate($it);\n          $it.baseId = $currentBaseId;\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          if ($breakOnError) {\n            out += ' if (!' + ($nextValid) + ') break; ';\n          }\n          out += ' } ';\n          if ($breakOnError) {\n            out += ' else ' + ($nextValid) + ' = true; ';\n          }\n          out += ' }  ';\n          if ($breakOnError) {\n            out += ' if (' + ($nextValid) + ') { ';\n            $closingBraces += '}';\n          }\n        }\n      }\n    }\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate_propertyNames(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  out += 'var ' + ($errs) + ' = errors;';\n  if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    $it.errSchemaPath = $errSchemaPath;\n    var $key = 'key' + $lvl,\n      $idx = 'idx' + $lvl,\n      $i = 'i' + $lvl,\n      $invalidName = '\\' + ' + $key + ' + \\'',\n      $dataNxt = $it.dataLevel = it.dataLevel + 1,\n      $nextData = 'data' + $dataNxt,\n      $dataProperties = 'dataProperties' + $lvl,\n      $ownProperties = it.opts.ownProperties,\n      $currentBaseId = it.baseId;\n    if ($ownProperties) {\n      out += ' var ' + ($dataProperties) + ' = undefined; ';\n    }\n    if ($ownProperties) {\n      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';\n    } else {\n      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';\n    }\n    out += ' var startErrs' + ($lvl) + ' = errors; ';\n    var $passData = $key;\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    var $code = it.validate($it);\n    $it.baseId = $currentBaseId;\n    if (it.util.varOccurences($code, $nextData) < 2) {\n      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n    } else {\n      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n    }\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' if (!' + ($nextValid) + ') { for (var ' + ($i) + '=startErrs' + ($lvl) + '; ' + ($i) + '<errors; ' + ($i) + '++) { vErrors[' + ($i) + '].propertyName = ' + ($key) + '; }   var err =   '; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('propertyNames') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { propertyName: \\'' + ($invalidName) + '\\' } ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'property name \\\\\\'' + ($invalidName) + '\\\\\\' is invalid\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError(vErrors); ';\n      } else {\n        out += ' validate.errors = vErrors; return false; ';\n      }\n    }\n    if ($breakOnError) {\n      out += ' break; ';\n    }\n    out += ' } }';\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate_required(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $vSchema = 'schema' + $lvl;\n  if (!$isData) {\n    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {\n      var $required = [];\n      var arr1 = $schema;\n      if (arr1) {\n        var $property, i1 = -1,\n          l1 = arr1.length - 1;\n        while (i1 < l1) {\n          $property = arr1[i1 += 1];\n          var $propertySch = it.schema.properties[$property];\n          if (!($propertySch && (it.opts.strictKeywords ? (typeof $propertySch == 'object' && Object.keys($propertySch).length > 0) || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {\n            $required[$required.length] = $property;\n          }\n        }\n      }\n    } else {\n      var $required = $schema;\n    }\n  }\n  if ($isData || $required.length) {\n    var $currentErrorPath = it.errorPath,\n      $loopRequired = $isData || $required.length >= it.opts.loopRequired,\n      $ownProperties = it.opts.ownProperties;\n    if ($breakOnError) {\n      out += ' var missing' + ($lvl) + '; ';\n      if ($loopRequired) {\n        if (!$isData) {\n          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';\n        }\n        var $i = 'i' + $lvl,\n          $propertyPath = 'schema' + $lvl + '[' + $i + ']',\n          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';\n        if (it.opts._errorDataPathProperty) {\n          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);\n        }\n        out += ' var ' + ($valid) + ' = true; ';\n        if ($isData) {\n          out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';\n        }\n        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { ' + ($valid) + ' = ' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] !== undefined ';\n        if ($ownProperties) {\n          out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';\n        }\n        out += '; if (!' + ($valid) + ') break; } ';\n        if ($isData) {\n          out += '  }  ';\n        }\n        out += '  if (!' + ($valid) + ') {   ';\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'';\n            if (it.opts._errorDataPathProperty) {\n              out += 'is a required property';\n            } else {\n              out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n            }\n            out += '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        out += ' } else { ';\n      } else {\n        out += ' if ( ';\n        var arr2 = $required;\n        if (arr2) {\n          var $propertyKey, $i = -1,\n            l2 = arr2.length - 1;\n          while ($i < l2) {\n            $propertyKey = arr2[$i += 1];\n            if ($i) {\n              out += ' || ';\n            }\n            var $prop = it.util.getProperty($propertyKey),\n              $useData = $data + $prop;\n            out += ' ( ( ' + ($useData) + ' === undefined ';\n            if ($ownProperties) {\n              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n            }\n            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';\n          }\n        }\n        out += ') {  ';\n        var $propertyPath = 'missing' + $lvl,\n          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';\n        if (it.opts._errorDataPathProperty) {\n          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;\n        }\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'';\n            if (it.opts._errorDataPathProperty) {\n              out += 'is a required property';\n            } else {\n              out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n            }\n            out += '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        out += ' } else { ';\n      }\n    } else {\n      if ($loopRequired) {\n        if (!$isData) {\n          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';\n        }\n        var $i = 'i' + $lvl,\n          $propertyPath = 'schema' + $lvl + '[' + $i + ']',\n          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';\n        if (it.opts._errorDataPathProperty) {\n          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);\n        }\n        if ($isData) {\n          out += ' if (' + ($vSchema) + ' && !Array.isArray(' + ($vSchema) + ')) {  var err =   '; /* istanbul ignore else */\n          if (it.createErrors !== false) {\n            out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n            if (it.opts.messages !== false) {\n              out += ' , message: \\'';\n              if (it.opts._errorDataPathProperty) {\n                out += 'is a required property';\n              } else {\n                out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n              }\n              out += '\\' ';\n            }\n            if (it.opts.verbose) {\n              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n            }\n            out += ' } ';\n          } else {\n            out += ' {} ';\n          }\n          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + ($vSchema) + ' !== undefined) { ';\n        }\n        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { if (' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] === undefined ';\n        if ($ownProperties) {\n          out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';\n        }\n        out += ') {  var err =   '; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'';\n            if (it.opts._errorDataPathProperty) {\n              out += 'is a required property';\n            } else {\n              out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n            }\n            out += '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';\n        if ($isData) {\n          out += '  }  ';\n        }\n      } else {\n        var arr3 = $required;\n        if (arr3) {\n          var $propertyKey, i3 = -1,\n            l3 = arr3.length - 1;\n          while (i3 < l3) {\n            $propertyKey = arr3[i3 += 1];\n            var $prop = it.util.getProperty($propertyKey),\n              $missingProperty = it.util.escapeQuotes($propertyKey),\n              $useData = $data + $prop;\n            if (it.opts._errorDataPathProperty) {\n              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);\n            }\n            out += ' if ( ' + ($useData) + ' === undefined ';\n            if ($ownProperties) {\n              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n            }\n            out += ') {  var err =   '; /* istanbul ignore else */\n            if (it.createErrors !== false) {\n              out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n              if (it.opts.messages !== false) {\n                out += ' , message: \\'';\n                if (it.opts._errorDataPathProperty) {\n                  out += 'is a required property';\n                } else {\n                  out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n                }\n                out += '\\' ';\n              }\n              if (it.opts.verbose) {\n                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n              }\n              out += ' } ';\n            } else {\n              out += ' {} ';\n            }\n            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';\n          }\n        }\n      }\n    }\n    it.errorPath = $currentErrorPath;\n  } else if ($breakOnError) {\n    out += ' if (true) {';\n  }\n  return out;\n}\n", "'use strict';\nmodule.exports = function generate_uniqueItems(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  if (($schema || $isData) && it.opts.uniqueItems !== false) {\n    if ($isData) {\n      out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \\'boolean\\') ' + ($valid) + ' = false; else { ';\n    }\n    out += ' var i = ' + ($data) + '.length , ' + ($valid) + ' = true , j; if (i > 1) { ';\n    var $itemType = it.schema.items && it.schema.items.type,\n      $typeIsArray = Array.isArray($itemType);\n    if (!$itemType || $itemType == 'object' || $itemType == 'array' || ($typeIsArray && ($itemType.indexOf('object') >= 0 || $itemType.indexOf('array') >= 0))) {\n      out += ' outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } ';\n    } else {\n      out += ' var itemIndices = {}, item; for (;i--;) { var item = ' + ($data) + '[i]; ';\n      var $method = 'checkDataType' + ($typeIsArray ? 's' : '');\n      out += ' if (' + (it.util[$method]($itemType, 'item', it.opts.strictNumbers, true)) + ') continue; ';\n      if ($typeIsArray) {\n        out += ' if (typeof item == \\'string\\') item = \\'\"\\' + item; ';\n      }\n      out += ' if (typeof itemIndices[item] == \\'number\\') { ' + ($valid) + ' = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ';\n    }\n    out += ' } ';\n    if ($isData) {\n      out += '  }  ';\n    }\n    out += ' if (!' + ($valid) + ') {   ';\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = ''; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('uniqueItems') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { i: i, j: j } ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT have duplicate items (items ## \\' + j + \\' and \\' + i + \\' are identical)\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema:  ';\n        if ($isData) {\n          out += 'validate.schema' + ($schemaPath);\n        } else {\n          out += '' + ($schema);\n        }\n        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError([' + (__err) + ']); ';\n      } else {\n        out += ' validate.errors = [' + (__err) + ']; return false; ';\n      }\n    } else {\n      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' } ';\n    if ($breakOnError) {\n      out += ' else { ';\n    }\n  } else {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  }\n  return out;\n}\n", "'use strict';\n\n//all requires must be explicit because browserify won't work with dynamic requires\nmodule.exports = {\n  '$ref': require('./ref'),\n  allOf: require('./allOf'),\n  anyOf: require('./anyOf'),\n  '$comment': require('./comment'),\n  const: require('./const'),\n  contains: require('./contains'),\n  dependencies: require('./dependencies'),\n  'enum': require('./enum'),\n  format: require('./format'),\n  'if': require('./if'),\n  items: require('./items'),\n  maximum: require('./_limit'),\n  minimum: require('./_limit'),\n  maxItems: require('./_limitItems'),\n  minItems: require('./_limitItems'),\n  maxLength: require('./_limitLength'),\n  minLength: require('./_limitLength'),\n  maxProperties: require('./_limitProperties'),\n  minProperties: require('./_limitProperties'),\n  multipleOf: require('./multipleOf'),\n  not: require('./not'),\n  oneOf: require('./oneOf'),\n  pattern: require('./pattern'),\n  properties: require('./properties'),\n  propertyNames: require('./propertyNames'),\n  required: require('./required'),\n  uniqueItems: require('./uniqueItems'),\n  validate: require('./validate')\n};\n", "'use strict';\n\nvar ruleModules = require('../dotjs')\n  , toHash = require('./util').toHash;\n\nmodule.exports = function rules() {\n  var RULES = [\n    { type: 'number',\n      rules: [ { 'maximum': ['exclusiveMaximum'] },\n               { 'minimum': ['exclusiveMinimum'] }, 'multipleOf', 'format'] },\n    { type: 'string',\n      rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },\n    { type: 'array',\n      rules: [ 'maxItems', 'minItems', 'items', 'contains', 'uniqueItems' ] },\n    { type: 'object',\n      rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames',\n               { 'properties': ['additionalProperties', 'patternProperties'] } ] },\n    { rules: [ '$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf', 'if' ] }\n  ];\n\n  var ALL = [ 'type', '$comment' ];\n  var KEYWORDS = [\n    '$schema', '$id', 'id', '$data', '$async', 'title',\n    'description', 'default', 'definitions',\n    'examples', 'readOnly', 'writeOnly',\n    'contentMediaType', 'contentEncoding',\n    'additionalItems', 'then', 'else'\n  ];\n  var TYPES = [ 'number', 'integer', 'string', 'array', 'object', 'boolean', 'null' ];\n  RULES.all = toHash(ALL);\n  RULES.types = toHash(TYPES);\n\n  RULES.forEach(function (group) {\n    group.rules = group.rules.map(function (keyword) {\n      var implKeywords;\n      if (typeof keyword == 'object') {\n        var key = Object.keys(keyword)[0];\n        implKeywords = keyword[key];\n        keyword = key;\n        implKeywords.forEach(function (k) {\n          ALL.push(k);\n          RULES.all[k] = true;\n        });\n      }\n      ALL.push(keyword);\n      var rule = RULES.all[keyword] = {\n        keyword: keyword,\n        code: ruleModules[keyword],\n        implements: implKeywords\n      };\n      return rule;\n    });\n\n    RULES.all.$comment = {\n      keyword: '$comment',\n      code: ruleModules.$comment\n    };\n\n    if (group.type) RULES.types[group.type] = group;\n  });\n\n  RULES.keywords = toHash(ALL.concat(KEYWORDS));\n  RULES.custom = {};\n\n  return RULES;\n};\n", "'use strict';\n\nvar KEYWORDS = [\n  'multipleOf',\n  'maximum',\n  'exclusiveMaximum',\n  'minimum',\n  'exclusiveMinimum',\n  'maxLength',\n  'minLength',\n  'pattern',\n  'additionalItems',\n  'maxItems',\n  'minItems',\n  'uniqueItems',\n  'maxProperties',\n  'minProperties',\n  'required',\n  'additionalProperties',\n  'enum',\n  'format',\n  'const'\n];\n\nmodule.exports = function (metaSchema, keywordsJsonPointers) {\n  for (var i=0; i<keywordsJsonPointers.length; i++) {\n    metaSchema = JSON.parse(JSON.stringify(metaSchema));\n    var segments = keywordsJsonPointers[i].split('/');\n    var keywords = metaSchema;\n    var j;\n    for (j=1; j<segments.length; j++)\n      keywords = keywords[segments[j]];\n\n    for (j=0; j<KEYWORDS.length; j++) {\n      var key = KEYWORDS[j];\n      var schema = keywords[key];\n      if (schema) {\n        keywords[key] = {\n          anyOf: [\n            schema,\n            { $ref: 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#' }\n          ]\n        };\n      }\n    }\n  }\n\n  return metaSchema;\n};\n", "'use strict';\n\nvar MissingRefError = require('./error_classes').MissingRef;\n\nmodule.exports = compileAsync;\n\n\n/**\n * Creates validating function for passed schema with asynchronous loading of missing schemas.\n * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n * @this  Ajv\n * @param {Object}   schema schema object\n * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped\n * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.\n * @return {Promise} promise that resolves with a validating function.\n */\nfunction compileAsync(schema, meta, callback) {\n  /* eslint no-shadow: 0 */\n  /* global Promise */\n  /* jshint validthis: true */\n  var self = this;\n  if (typeof this._opts.loadSchema != 'function')\n    throw new Error('options.loadSchema should be a function');\n\n  if (typeof meta == 'function') {\n    callback = meta;\n    meta = undefined;\n  }\n\n  var p = loadMetaSchemaOf(schema).then(function () {\n    var schemaObj = self._addSchema(schema, undefined, meta);\n    return schemaObj.validate || _compileAsync(schemaObj);\n  });\n\n  if (callback) {\n    p.then(\n      function(v) { callback(null, v); },\n      callback\n    );\n  }\n\n  return p;\n\n\n  function loadMetaSchemaOf(sch) {\n    var $schema = sch.$schema;\n    return $schema && !self.getSchema($schema)\n            ? compileAsync.call(self, { $ref: $schema }, true)\n            : Promise.resolve();\n  }\n\n\n  function _compileAsync(schemaObj) {\n    try { return self._compile(schemaObj); }\n    catch(e) {\n      if (e instanceof MissingRefError) return loadMissingSchema(e);\n      throw e;\n    }\n\n\n    function loadMissingSchema(e) {\n      var ref = e.missingSchema;\n      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');\n\n      var schemaPromise = self._loadingSchemas[ref];\n      if (!schemaPromise) {\n        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);\n        schemaPromise.then(removePromise, removePromise);\n      }\n\n      return schemaPromise.then(function (sch) {\n        if (!added(ref)) {\n          return loadMetaSchemaOf(sch).then(function () {\n            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);\n          });\n        }\n      }).then(function() {\n        return _compileAsync(schemaObj);\n      });\n\n      function removePromise() {\n        delete self._loadingSchemas[ref];\n      }\n\n      function added(ref) {\n        return self._refs[ref] || self._schemas[ref];\n      }\n    }\n  }\n}\n", "'use strict';\nmodule.exports = function generate_custom(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $errorKeyword;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $rule = this,\n    $definition = 'definition' + $lvl,\n    $rDef = $rule.definition,\n    $closingBraces = '';\n  var $compile, $inline, $macro, $ruleValidate, $validateCode;\n  if ($isData && $rDef.$data) {\n    $validateCode = 'keywordValidate' + $lvl;\n    var $validateSchema = $rDef.validateSchema;\n    out += ' var ' + ($definition) + ' = RULES.custom[\\'' + ($keyword) + '\\'].definition; var ' + ($validateCode) + ' = ' + ($definition) + '.validate;';\n  } else {\n    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);\n    if (!$ruleValidate) return;\n    $schemaValue = 'validate.schema' + $schemaPath;\n    $validateCode = $ruleValidate.code;\n    $compile = $rDef.compile;\n    $inline = $rDef.inline;\n    $macro = $rDef.macro;\n  }\n  var $ruleErrs = $validateCode + '.errors',\n    $i = 'i' + $lvl,\n    $ruleErr = 'ruleErr' + $lvl,\n    $asyncKeyword = $rDef.async;\n  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');\n  if (!($inline || $macro)) {\n    out += '' + ($ruleErrs) + ' = null;';\n  }\n  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';\n  if ($isData && $rDef.$data) {\n    $closingBraces += '}';\n    out += ' if (' + ($schemaValue) + ' === undefined) { ' + ($valid) + ' = true; } else { ';\n    if ($validateSchema) {\n      $closingBraces += '}';\n      out += ' ' + ($valid) + ' = ' + ($definition) + '.validateSchema(' + ($schemaValue) + '); if (' + ($valid) + ') { ';\n    }\n  }\n  if ($inline) {\n    if ($rDef.statements) {\n      out += ' ' + ($ruleValidate.validate) + ' ';\n    } else {\n      out += ' ' + ($valid) + ' = ' + ($ruleValidate.validate) + '; ';\n    }\n  } else if ($macro) {\n    var $it = it.util.copy(it);\n    var $closingBraces = '';\n    $it.level++;\n    var $nextValid = 'valid' + $it.level;\n    $it.schema = $ruleValidate.validate;\n    $it.schemaPath = '';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    var $code = it.validate($it).replace(/validate\\.schema/g, $validateCode);\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' ' + ($code);\n  } else {\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = '';\n    out += '  ' + ($validateCode) + '.call( ';\n    if (it.opts.passContext) {\n      out += 'this';\n    } else {\n      out += 'self';\n    }\n    if ($compile || $rDef.schema === false) {\n      out += ' , ' + ($data) + ' ';\n    } else {\n      out += ' , ' + ($schemaValue) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';\n    }\n    out += ' , (dataPath || \\'\\')';\n    if (it.errorPath != '\"\"') {\n      out += ' + ' + (it.errorPath);\n    }\n    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',\n      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';\n    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ' , rootData )  ';\n    var def_callRuleValidate = out;\n    out = $$outStack.pop();\n    if ($rDef.errors === false) {\n      out += ' ' + ($valid) + ' = ';\n      if ($asyncKeyword) {\n        out += 'await ';\n      }\n      out += '' + (def_callRuleValidate) + '; ';\n    } else {\n      if ($asyncKeyword) {\n        $ruleErrs = 'customErrors' + $lvl;\n        out += ' var ' + ($ruleErrs) + ' = null; try { ' + ($valid) + ' = await ' + (def_callRuleValidate) + '; } catch (e) { ' + ($valid) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; } ';\n      } else {\n        out += ' ' + ($ruleErrs) + ' = null; ' + ($valid) + ' = ' + (def_callRuleValidate) + '; ';\n      }\n    }\n  }\n  if ($rDef.modifying) {\n    out += ' if (' + ($parentData) + ') ' + ($data) + ' = ' + ($parentData) + '[' + ($parentDataProperty) + '];';\n  }\n  out += '' + ($closingBraces);\n  if ($rDef.valid) {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  } else {\n    out += ' if ( ';\n    if ($rDef.valid === undefined) {\n      out += ' !';\n      if ($macro) {\n        out += '' + ($nextValid);\n      } else {\n        out += '' + ($valid);\n      }\n    } else {\n      out += ' ' + (!$rDef.valid) + ' ';\n    }\n    out += ') { ';\n    $errorKeyword = $rule.keyword;\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = '';\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = ''; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ($errorKeyword || 'custom') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \\'' + ($rule.keyword) + '\\' } ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should pass \"' + ($rule.keyword) + '\" keyword validation\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError([' + (__err) + ']); ';\n      } else {\n        out += ' validate.errors = [' + (__err) + ']; return false; ';\n      }\n    } else {\n      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    var def_customError = out;\n    out = $$outStack.pop();\n    if ($inline) {\n      if ($rDef.errors) {\n        if ($rDef.errors != 'full') {\n          out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \\'\\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = \"' + ($errSchemaPath) + '\"; } ';\n          if (it.opts.verbose) {\n            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';\n          }\n          out += ' } ';\n        }\n      } else {\n        if ($rDef.errors === false) {\n          out += ' ' + (def_customError) + ' ';\n        } else {\n          out += ' if (' + ($errs) + ' == errors) { ' + (def_customError) + ' } else {  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \\'\\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = \"' + ($errSchemaPath) + '\"; } ';\n          if (it.opts.verbose) {\n            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';\n          }\n          out += ' } } ';\n        }\n      }\n    } else if ($macro) {\n      out += '   var err =   '; /* istanbul ignore else */\n      if (it.createErrors !== false) {\n        out += ' { keyword: \\'' + ($errorKeyword || 'custom') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \\'' + ($rule.keyword) + '\\' } ';\n        if (it.opts.messages !== false) {\n          out += ' , message: \\'should pass \"' + ($rule.keyword) + '\" keyword validation\\' ';\n        }\n        if (it.opts.verbose) {\n          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n        }\n        out += ' } ';\n      } else {\n        out += ' {} ';\n      }\n      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n      if (!it.compositeRule && $breakOnError) {\n        /* istanbul ignore if */\n        if (it.async) {\n          out += ' throw new ValidationError(vErrors); ';\n        } else {\n          out += ' validate.errors = vErrors; return false; ';\n        }\n      }\n    } else {\n      if ($rDef.errors === false) {\n        out += ' ' + (def_customError) + ' ';\n      } else {\n        out += ' if (Array.isArray(' + ($ruleErrs) + ')) { if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors = vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \\'\\') + ' + (it.errorPath) + ';  ' + ($ruleErr) + '.schemaPath = \"' + ($errSchemaPath) + '\";  ';\n        if (it.opts.verbose) {\n          out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';\n        }\n        out += ' } } else { ' + (def_customError) + ' } ';\n      }\n    }\n    out += ' } ';\n    if ($breakOnError) {\n      out += ' else { ';\n    }\n  }\n  return out;\n}\n", "{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"$id\": \"http://json-schema.org/draft-07/schema#\",\n    \"title\": \"Core schema meta-schema\",\n    \"definitions\": {\n        \"schemaArray\": {\n            \"type\": \"array\",\n            \"minItems\": 1,\n            \"items\": { \"$ref\": \"#\" }\n        },\n        \"nonNegativeInteger\": {\n            \"type\": \"integer\",\n            \"minimum\": 0\n        },\n        \"nonNegativeIntegerDefault0\": {\n            \"allOf\": [\n                { \"$ref\": \"#/definitions/nonNegativeInteger\" },\n                { \"default\": 0 }\n            ]\n        },\n        \"simpleTypes\": {\n            \"enum\": [\n                \"array\",\n                \"boolean\",\n                \"integer\",\n                \"null\",\n                \"number\",\n                \"object\",\n                \"string\"\n            ]\n        },\n        \"stringArray\": {\n            \"type\": \"array\",\n            \"items\": { \"type\": \"string\" },\n            \"uniqueItems\": true,\n            \"default\": []\n        }\n    },\n    \"type\": [\"object\", \"boolean\"],\n    \"properties\": {\n        \"$id\": {\n            \"type\": \"string\",\n            \"format\": \"uri-reference\"\n        },\n        \"$schema\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n        },\n        \"$ref\": {\n            \"type\": \"string\",\n            \"format\": \"uri-reference\"\n        },\n        \"$comment\": {\n            \"type\": \"string\"\n        },\n        \"title\": {\n            \"type\": \"string\"\n        },\n        \"description\": {\n            \"type\": \"string\"\n        },\n        \"default\": true,\n        \"readOnly\": {\n            \"type\": \"boolean\",\n            \"default\": false\n        },\n        \"examples\": {\n            \"type\": \"array\",\n            \"items\": true\n        },\n        \"multipleOf\": {\n            \"type\": \"number\",\n            \"exclusiveMinimum\": 0\n        },\n        \"maximum\": {\n            \"type\": \"number\"\n        },\n        \"exclusiveMaximum\": {\n            \"type\": \"number\"\n        },\n        \"minimum\": {\n            \"type\": \"number\"\n        },\n        \"exclusiveMinimum\": {\n            \"type\": \"number\"\n        },\n        \"maxLength\": { \"$ref\": \"#/definitions/nonNegativeInteger\" },\n        \"minLength\": { \"$ref\": \"#/definitions/nonNegativeIntegerDefault0\" },\n        \"pattern\": {\n            \"type\": \"string\",\n            \"format\": \"regex\"\n        },\n        \"additionalItems\": { \"$ref\": \"#\" },\n        \"items\": {\n            \"anyOf\": [\n                { \"$ref\": \"#\" },\n                { \"$ref\": \"#/definitions/schemaArray\" }\n            ],\n            \"default\": true\n        },\n        \"maxItems\": { \"$ref\": \"#/definitions/nonNegativeInteger\" },\n        \"minItems\": { \"$ref\": \"#/definitions/nonNegativeIntegerDefault0\" },\n        \"uniqueItems\": {\n            \"type\": \"boolean\",\n            \"default\": false\n        },\n        \"contains\": { \"$ref\": \"#\" },\n        \"maxProperties\": { \"$ref\": \"#/definitions/nonNegativeInteger\" },\n        \"minProperties\": { \"$ref\": \"#/definitions/nonNegativeIntegerDefault0\" },\n        \"required\": { \"$ref\": \"#/definitions/stringArray\" },\n        \"additionalProperties\": { \"$ref\": \"#\" },\n        \"definitions\": {\n            \"type\": \"object\",\n            \"additionalProperties\": { \"$ref\": \"#\" },\n            \"default\": {}\n        },\n        \"properties\": {\n            \"type\": \"object\",\n            \"additionalProperties\": { \"$ref\": \"#\" },\n            \"default\": {}\n        },\n        \"patternProperties\": {\n            \"type\": \"object\",\n            \"additionalProperties\": { \"$ref\": \"#\" },\n            \"propertyNames\": { \"format\": \"regex\" },\n            \"default\": {}\n        },\n        \"dependencies\": {\n            \"type\": \"object\",\n            \"additionalProperties\": {\n                \"anyOf\": [\n                    { \"$ref\": \"#\" },\n                    { \"$ref\": \"#/definitions/stringArray\" }\n                ]\n            }\n        },\n        \"propertyNames\": { \"$ref\": \"#\" },\n        \"const\": true,\n        \"enum\": {\n            \"type\": \"array\",\n            \"items\": true,\n            \"minItems\": 1,\n            \"uniqueItems\": true\n        },\n        \"type\": {\n            \"anyOf\": [\n                { \"$ref\": \"#/definitions/simpleTypes\" },\n                {\n                    \"type\": \"array\",\n                    \"items\": { \"$ref\": \"#/definitions/simpleTypes\" },\n                    \"minItems\": 1,\n                    \"uniqueItems\": true\n                }\n            ]\n        },\n        \"format\": { \"type\": \"string\" },\n        \"contentMediaType\": { \"type\": \"string\" },\n        \"contentEncoding\": { \"type\": \"string\" },\n        \"if\": {\"$ref\": \"#\"},\n        \"then\": {\"$ref\": \"#\"},\n        \"else\": {\"$ref\": \"#\"},\n        \"allOf\": { \"$ref\": \"#/definitions/schemaArray\" },\n        \"anyOf\": { \"$ref\": \"#/definitions/schemaArray\" },\n        \"oneOf\": { \"$ref\": \"#/definitions/schemaArray\" },\n        \"not\": { \"$ref\": \"#\" }\n    },\n    \"default\": true\n}\n", "'use strict';\n\nvar metaSchema = require('./refs/json-schema-draft-07.json');\n\nmodule.exports = {\n  $id: 'https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js',\n  definitions: {\n    simpleTypes: metaSchema.definitions.simpleTypes\n  },\n  type: 'object',\n  dependencies: {\n    schema: ['validate'],\n    $data: ['validate'],\n    statements: ['inline'],\n    valid: {not: {required: ['macro']}}\n  },\n  properties: {\n    type: metaSchema.properties.type,\n    schema: {type: 'boolean'},\n    statements: {type: 'boolean'},\n    dependencies: {\n      type: 'array',\n      items: {type: 'string'}\n    },\n    metaSchema: {type: 'object'},\n    modifying: {type: 'boolean'},\n    valid: {type: 'boolean'},\n    $data: {type: 'boolean'},\n    async: {type: 'boolean'},\n    errors: {\n      anyOf: [\n        {type: 'boolean'},\n        {const: 'full'}\n      ]\n    }\n  }\n};\n", "'use strict';\n\nvar IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;\nvar customRuleCode = require('./dotjs/custom');\nvar definitionSchema = require('./definition_schema');\n\nmodule.exports = {\n  add: addKeyword,\n  get: getKeyword,\n  remove: removeKeyword,\n  validate: validateKeyword\n};\n\n\n/**\n * Define custom keyword\n * @this  Ajv\n * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).\n * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.\n * @return {Ajv} this for method chaining\n */\nfunction addKeyword(keyword, definition) {\n  /* jshint validthis: true */\n  /* eslint no-shadow: 0 */\n  var RULES = this.RULES;\n  if (RULES.keywords[keyword])\n    throw new Error('Keyword ' + keyword + ' is already defined');\n\n  if (!IDENTIFIER.test(keyword))\n    throw new Error('Keyword ' + keyword + ' is not a valid identifier');\n\n  if (definition) {\n    this.validateKeyword(definition, true);\n\n    var dataType = definition.type;\n    if (Array.isArray(dataType)) {\n      for (var i=0; i<dataType.length; i++)\n        _addRule(keyword, dataType[i], definition);\n    } else {\n      _addRule(keyword, dataType, definition);\n    }\n\n    var metaSchema = definition.metaSchema;\n    if (metaSchema) {\n      if (definition.$data && this._opts.$data) {\n        metaSchema = {\n          anyOf: [\n            metaSchema,\n            { '$ref': 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#' }\n          ]\n        };\n      }\n      definition.validateSchema = this.compile(metaSchema, true);\n    }\n  }\n\n  RULES.keywords[keyword] = RULES.all[keyword] = true;\n\n\n  function _addRule(keyword, dataType, definition) {\n    var ruleGroup;\n    for (var i=0; i<RULES.length; i++) {\n      var rg = RULES[i];\n      if (rg.type == dataType) {\n        ruleGroup = rg;\n        break;\n      }\n    }\n\n    if (!ruleGroup) {\n      ruleGroup = { type: dataType, rules: [] };\n      RULES.push(ruleGroup);\n    }\n\n    var rule = {\n      keyword: keyword,\n      definition: definition,\n      custom: true,\n      code: customRuleCode,\n      implements: definition.implements\n    };\n    ruleGroup.rules.push(rule);\n    RULES.custom[keyword] = rule;\n  }\n\n  return this;\n}\n\n\n/**\n * Get keyword\n * @this  Ajv\n * @param {String} keyword pre-defined or custom keyword.\n * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.\n */\nfunction getKeyword(keyword) {\n  /* jshint validthis: true */\n  var rule = this.RULES.custom[keyword];\n  return rule ? rule.definition : this.RULES.keywords[keyword] || false;\n}\n\n\n/**\n * Remove keyword\n * @this  Ajv\n * @param {String} keyword pre-defined or custom keyword.\n * @return {Ajv} this for method chaining\n */\nfunction removeKeyword(keyword) {\n  /* jshint validthis: true */\n  var RULES = this.RULES;\n  delete RULES.keywords[keyword];\n  delete RULES.all[keyword];\n  delete RULES.custom[keyword];\n  for (var i=0; i<RULES.length; i++) {\n    var rules = RULES[i].rules;\n    for (var j=0; j<rules.length; j++) {\n      if (rules[j].keyword == keyword) {\n        rules.splice(j, 1);\n        break;\n      }\n    }\n  }\n  return this;\n}\n\n\n/**\n * Validate keyword definition\n * @this  Ajv\n * @param {Object} definition keyword definition object.\n * @param {Boolean} throwError true to throw exception if definition is invalid\n * @return {boolean} validation result\n */\nfunction validateKeyword(definition, throwError) {\n  validateKeyword.errors = null;\n  var v = this._validateKeyword = this._validateKeyword\n                                  || this.compile(definitionSchema, true);\n\n  if (v(definition)) return true;\n  validateKeyword.errors = v.errors;\n  if (throwError)\n    throw new Error('custom keyword definition is invalid: '  + this.errorsText(v.errors));\n  else\n    return false;\n}\n", "{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"$id\": \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n    \"description\": \"Meta-schema for $data reference (JSON Schema extension proposal)\",\n    \"type\": \"object\",\n    \"required\": [ \"$data\" ],\n    \"properties\": {\n        \"$data\": {\n            \"type\": \"string\",\n            \"anyOf\": [\n                { \"format\": \"relative-json-pointer\" }, \n                { \"format\": \"json-pointer\" }\n            ]\n        }\n    },\n    \"additionalProperties\": false\n}\n", "'use strict';\n\nvar compileSchema = require('./compile')\n  , resolve = require('./compile/resolve')\n  , Cache = require('./cache')\n  , SchemaObject = require('./compile/schema_obj')\n  , stableStringify = require('fast-json-stable-stringify')\n  , formats = require('./compile/formats')\n  , rules = require('./compile/rules')\n  , $dataMetaSchema = require('./data')\n  , util = require('./compile/util');\n\nmodule.exports = Ajv;\n\nAjv.prototype.validate = validate;\nAjv.prototype.compile = compile;\nAjv.prototype.addSchema = addSchema;\nAjv.prototype.addMetaSchema = addMetaSchema;\nAjv.prototype.validateSchema = validateSchema;\nAjv.prototype.getSchema = getSchema;\nAjv.prototype.removeSchema = removeSchema;\nAjv.prototype.addFormat = addFormat;\nAjv.prototype.errorsText = errorsText;\n\nAjv.prototype._addSchema = _addSchema;\nAjv.prototype._compile = _compile;\n\nAjv.prototype.compileAsync = require('./compile/async');\nvar customKeyword = require('./keyword');\nAjv.prototype.addKeyword = customKeyword.add;\nAjv.prototype.getKeyword = customKeyword.get;\nAjv.prototype.removeKeyword = customKeyword.remove;\nAjv.prototype.validateKeyword = customKeyword.validate;\n\nvar errorClasses = require('./compile/error_classes');\nAjv.ValidationError = errorClasses.Validation;\nAjv.MissingRefError = errorClasses.MissingRef;\nAjv.$dataMetaSchema = $dataMetaSchema;\n\nvar META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';\n\nvar META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes', 'strictDefaults' ];\nvar META_SUPPORT_DATA = ['/properties'];\n\n/**\n * Creates validator instance.\n * Usage: `Ajv(opts)`\n * @param {Object} opts optional options\n * @return {Object} ajv instance\n */\nfunction Ajv(opts) {\n  if (!(this instanceof Ajv)) return new Ajv(opts);\n  opts = this._opts = util.copy(opts) || {};\n  setLogger(this);\n  this._schemas = {};\n  this._refs = {};\n  this._fragments = {};\n  this._formats = formats(opts.format);\n\n  this._cache = opts.cache || new Cache;\n  this._loadingSchemas = {};\n  this._compilations = [];\n  this.RULES = rules();\n  this._getId = chooseGetId(opts);\n\n  opts.loopRequired = opts.loopRequired || Infinity;\n  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;\n  if (opts.serialize === undefined) opts.serialize = stableStringify;\n  this._metaOpts = getMetaSchemaOptions(this);\n\n  if (opts.formats) addInitialFormats(this);\n  if (opts.keywords) addInitialKeywords(this);\n  addDefaultMetaSchema(this);\n  if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);\n  if (opts.nullable) this.addKeyword('nullable', {metaSchema: {type: 'boolean'}});\n  addInitialSchemas(this);\n}\n\n\n\n/**\n * Validate data using schema\n * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.\n * @this   Ajv\n * @param  {String|Object} schemaKeyRef key, ref or schema object\n * @param  {Any} data to be validated\n * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).\n */\nfunction validate(schemaKeyRef, data) {\n  var v;\n  if (typeof schemaKeyRef == 'string') {\n    v = this.getSchema(schemaKeyRef);\n    if (!v) throw new Error('no schema with key or ref \"' + schemaKeyRef + '\"');\n  } else {\n    var schemaObj = this._addSchema(schemaKeyRef);\n    v = schemaObj.validate || this._compile(schemaObj);\n  }\n\n  var valid = v(data);\n  if (v.$async !== true) this.errors = v.errors;\n  return valid;\n}\n\n\n/**\n * Create validating function for passed schema.\n * @this   Ajv\n * @param  {Object} schema schema object\n * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.\n * @return {Function} validating function\n */\nfunction compile(schema, _meta) {\n  var schemaObj = this._addSchema(schema, undefined, _meta);\n  return schemaObj.validate || this._compile(schemaObj);\n}\n\n\n/**\n * Adds schema to the instance.\n * @this   Ajv\n * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.\n * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.\n * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n * @return {Ajv} this for method chaining\n */\nfunction addSchema(schema, key, _skipValidation, _meta) {\n  if (Array.isArray(schema)){\n    for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);\n    return this;\n  }\n  var id = this._getId(schema);\n  if (id !== undefined && typeof id != 'string')\n    throw new Error('schema id must be string');\n  key = resolve.normalizeId(key || id);\n  checkUnique(this, key);\n  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);\n  return this;\n}\n\n\n/**\n * Add schema that will be used to validate other schemas\n * options in META_IGNORE_OPTIONS are alway set to false\n * @this   Ajv\n * @param {Object} schema schema object\n * @param {String} key optional schema key\n * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema\n * @return {Ajv} this for method chaining\n */\nfunction addMetaSchema(schema, key, skipValidation) {\n  this.addSchema(schema, key, skipValidation, true);\n  return this;\n}\n\n\n/**\n * Validate schema\n * @this   Ajv\n * @param {Object} schema schema to validate\n * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid\n * @return {Boolean} true if schema is valid\n */\nfunction validateSchema(schema, throwOrLogError) {\n  var $schema = schema.$schema;\n  if ($schema !== undefined && typeof $schema != 'string')\n    throw new Error('$schema must be a string');\n  $schema = $schema || this._opts.defaultMeta || defaultMeta(this);\n  if (!$schema) {\n    this.logger.warn('meta-schema not available');\n    this.errors = null;\n    return true;\n  }\n  var valid = this.validate($schema, schema);\n  if (!valid && throwOrLogError) {\n    var message = 'schema is invalid: ' + this.errorsText();\n    if (this._opts.validateSchema == 'log') this.logger.error(message);\n    else throw new Error(message);\n  }\n  return valid;\n}\n\n\nfunction defaultMeta(self) {\n  var meta = self._opts.meta;\n  self._opts.defaultMeta = typeof meta == 'object'\n                            ? self._getId(meta) || meta\n                            : self.getSchema(META_SCHEMA_ID)\n                              ? META_SCHEMA_ID\n                              : undefined;\n  return self._opts.defaultMeta;\n}\n\n\n/**\n * Get compiled schema from the instance by `key` or `ref`.\n * @this   Ajv\n * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).\n * @return {Function} schema validating function (with property `schema`).\n */\nfunction getSchema(keyRef) {\n  var schemaObj = _getSchemaObj(this, keyRef);\n  switch (typeof schemaObj) {\n    case 'object': return schemaObj.validate || this._compile(schemaObj);\n    case 'string': return this.getSchema(schemaObj);\n    case 'undefined': return _getSchemaFragment(this, keyRef);\n  }\n}\n\n\nfunction _getSchemaFragment(self, ref) {\n  var res = resolve.schema.call(self, { schema: {} }, ref);\n  if (res) {\n    var schema = res.schema\n      , root = res.root\n      , baseId = res.baseId;\n    var v = compileSchema.call(self, schema, root, undefined, baseId);\n    self._fragments[ref] = new SchemaObject({\n      ref: ref,\n      fragment: true,\n      schema: schema,\n      root: root,\n      baseId: baseId,\n      validate: v\n    });\n    return v;\n  }\n}\n\n\nfunction _getSchemaObj(self, keyRef) {\n  keyRef = resolve.normalizeId(keyRef);\n  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];\n}\n\n\n/**\n * Remove cached schema(s).\n * If no parameter is passed all schemas but meta-schemas are removed.\n * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n * @this   Ajv\n * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object\n * @return {Ajv} this for method chaining\n */\nfunction removeSchema(schemaKeyRef) {\n  if (schemaKeyRef instanceof RegExp) {\n    _removeAllSchemas(this, this._schemas, schemaKeyRef);\n    _removeAllSchemas(this, this._refs, schemaKeyRef);\n    return this;\n  }\n  switch (typeof schemaKeyRef) {\n    case 'undefined':\n      _removeAllSchemas(this, this._schemas);\n      _removeAllSchemas(this, this._refs);\n      this._cache.clear();\n      return this;\n    case 'string':\n      var schemaObj = _getSchemaObj(this, schemaKeyRef);\n      if (schemaObj) this._cache.del(schemaObj.cacheKey);\n      delete this._schemas[schemaKeyRef];\n      delete this._refs[schemaKeyRef];\n      return this;\n    case 'object':\n      var serialize = this._opts.serialize;\n      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;\n      this._cache.del(cacheKey);\n      var id = this._getId(schemaKeyRef);\n      if (id) {\n        id = resolve.normalizeId(id);\n        delete this._schemas[id];\n        delete this._refs[id];\n      }\n  }\n  return this;\n}\n\n\nfunction _removeAllSchemas(self, schemas, regex) {\n  for (var keyRef in schemas) {\n    var schemaObj = schemas[keyRef];\n    if (!schemaObj.meta && (!regex || regex.test(keyRef))) {\n      self._cache.del(schemaObj.cacheKey);\n      delete schemas[keyRef];\n    }\n  }\n}\n\n\n/* @this   Ajv */\nfunction _addSchema(schema, skipValidation, meta, shouldAddSchema) {\n  if (typeof schema != 'object' && typeof schema != 'boolean')\n    throw new Error('schema should be object or boolean');\n  var serialize = this._opts.serialize;\n  var cacheKey = serialize ? serialize(schema) : schema;\n  var cached = this._cache.get(cacheKey);\n  if (cached) return cached;\n\n  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;\n\n  var id = resolve.normalizeId(this._getId(schema));\n  if (id && shouldAddSchema) checkUnique(this, id);\n\n  var willValidate = this._opts.validateSchema !== false && !skipValidation;\n  var recursiveMeta;\n  if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))\n    this.validateSchema(schema, true);\n\n  var localRefs = resolve.ids.call(this, schema);\n\n  var schemaObj = new SchemaObject({\n    id: id,\n    schema: schema,\n    localRefs: localRefs,\n    cacheKey: cacheKey,\n    meta: meta\n  });\n\n  if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;\n  this._cache.put(cacheKey, schemaObj);\n\n  if (willValidate && recursiveMeta) this.validateSchema(schema, true);\n\n  return schemaObj;\n}\n\n\n/* @this   Ajv */\nfunction _compile(schemaObj, root) {\n  if (schemaObj.compiling) {\n    schemaObj.validate = callValidate;\n    callValidate.schema = schemaObj.schema;\n    callValidate.errors = null;\n    callValidate.root = root ? root : callValidate;\n    if (schemaObj.schema.$async === true)\n      callValidate.$async = true;\n    return callValidate;\n  }\n  schemaObj.compiling = true;\n\n  var currentOpts;\n  if (schemaObj.meta) {\n    currentOpts = this._opts;\n    this._opts = this._metaOpts;\n  }\n\n  var v;\n  try { v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); }\n  catch(e) {\n    delete schemaObj.validate;\n    throw e;\n  }\n  finally {\n    schemaObj.compiling = false;\n    if (schemaObj.meta) this._opts = currentOpts;\n  }\n\n  schemaObj.validate = v;\n  schemaObj.refs = v.refs;\n  schemaObj.refVal = v.refVal;\n  schemaObj.root = v.root;\n  return v;\n\n\n  /* @this   {*} - custom context, see passContext option */\n  function callValidate() {\n    /* jshint validthis: true */\n    var _validate = schemaObj.validate;\n    var result = _validate.apply(this, arguments);\n    callValidate.errors = _validate.errors;\n    return result;\n  }\n}\n\n\nfunction chooseGetId(opts) {\n  switch (opts.schemaId) {\n    case 'auto': return _get$IdOrId;\n    case 'id': return _getId;\n    default: return _get$Id;\n  }\n}\n\n/* @this   Ajv */\nfunction _getId(schema) {\n  if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);\n  return schema.id;\n}\n\n/* @this   Ajv */\nfunction _get$Id(schema) {\n  if (schema.id) this.logger.warn('schema id ignored', schema.id);\n  return schema.$id;\n}\n\n\nfunction _get$IdOrId(schema) {\n  if (schema.$id && schema.id && schema.$id != schema.id)\n    throw new Error('schema $id is different from id');\n  return schema.$id || schema.id;\n}\n\n\n/**\n * Convert array of error message objects to string\n * @this   Ajv\n * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.\n * @param  {Object} options optional options with properties `separator` and `dataVar`.\n * @return {String} human readable string with all errors descriptions\n */\nfunction errorsText(errors, options) {\n  errors = errors || this.errors;\n  if (!errors) return 'No errors';\n  options = options || {};\n  var separator = options.separator === undefined ? ', ' : options.separator;\n  var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;\n\n  var text = '';\n  for (var i=0; i<errors.length; i++) {\n    var e = errors[i];\n    if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;\n  }\n  return text.slice(0, -separator.length);\n}\n\n\n/**\n * Add custom format\n * @this   Ajv\n * @param {String} name format name\n * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)\n * @return {Ajv} this for method chaining\n */\nfunction addFormat(name, format) {\n  if (typeof format == 'string') format = new RegExp(format);\n  this._formats[name] = format;\n  return this;\n}\n\n\nfunction addDefaultMetaSchema(self) {\n  var $dataSchema;\n  if (self._opts.$data) {\n    $dataSchema = require('./refs/data.json');\n    self.addMetaSchema($dataSchema, $dataSchema.$id, true);\n  }\n  if (self._opts.meta === false) return;\n  var metaSchema = require('./refs/json-schema-draft-07.json');\n  if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);\n  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);\n  self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;\n}\n\n\nfunction addInitialSchemas(self) {\n  var optsSchemas = self._opts.schemas;\n  if (!optsSchemas) return;\n  if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);\n  else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);\n}\n\n\nfunction addInitialFormats(self) {\n  for (var name in self._opts.formats) {\n    var format = self._opts.formats[name];\n    self.addFormat(name, format);\n  }\n}\n\n\nfunction addInitialKeywords(self) {\n  for (var name in self._opts.keywords) {\n    var keyword = self._opts.keywords[name];\n    self.addKeyword(name, keyword);\n  }\n}\n\n\nfunction checkUnique(self, id) {\n  if (self._schemas[id] || self._refs[id])\n    throw new Error('schema with key or id \"' + id + '\" already exists');\n}\n\n\nfunction getMetaSchemaOptions(self) {\n  var metaOpts = util.copy(self._opts);\n  for (var i=0; i<META_IGNORE_OPTIONS.length; i++)\n    delete metaOpts[META_IGNORE_OPTIONS[i]];\n  return metaOpts;\n}\n\n\nfunction setLogger(self) {\n  var logger = self._opts.logger;\n  if (logger === false) {\n    self.logger = {log: noop, warn: noop, error: noop};\n  } else {\n    if (logger === undefined) logger = console;\n    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error))\n      throw new Error('logger must implement log, warn and error methods');\n    self.logger = logger;\n  }\n}\n\n\nfunction noop() {}\n", "'use strict'\n\nconst hasBuffer = typeof Buffer !== 'undefined'\nconst suspectProtoRx = /\"(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])(?:p|\\\\u0070)(?:r|\\\\u0072)(?:o|\\\\u006[Ff])(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])\"\\s*:/\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/\n\nfunction _parse (text, reviver, options) {\n  // Normalize arguments\n  if (options == null) {\n    if (reviver !== null && typeof reviver === 'object') {\n      options = reviver\n      reviver = undefined\n    }\n  }\n\n  if (hasBuffer && Buffer.isBuffer(text)) {\n    text = text.toString()\n  }\n\n  // BOM checker\n  if (text && text.charCodeAt(0) === 0xFEFF) {\n    text = text.slice(1)\n  }\n\n  // Parse normally, allowing exceptions\n  const obj = JSON.parse(text, reviver)\n\n  // Ignore null and non-objects\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  const protoAction = (options && options.protoAction) || 'error'\n  const constructorAction = (options && options.constructorAction) || 'error'\n\n  // options: 'error' (default) / 'remove' / 'ignore'\n  if (protoAction === 'ignore' && constructorAction === 'ignore') {\n    return obj\n  }\n\n  if (protoAction !== 'ignore' && constructorAction !== 'ignore') {\n    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {\n    if (suspectProtoRx.test(text) === false) {\n      return obj\n    }\n  } else {\n    if (suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  }\n\n  // Scan result for proto keys\n  return filter(obj, { protoAction, constructorAction, safe: options && options.safe })\n}\n\nfunction filter (obj, { protoAction = 'error', constructorAction = 'error', safe } = {}) {\n  let next = [obj]\n\n  while (next.length) {\n    const nodes = next\n    next = []\n\n    for (const node of nodes) {\n      if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (protoAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.__proto__ // eslint-disable-line no-proto\n      }\n\n      if (constructorAction !== 'ignore' &&\n          Object.prototype.hasOwnProperty.call(node, 'constructor') &&\n          Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (constructorAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.constructor\n      }\n\n      for (const key in node) {\n        const value = node[key]\n        if (value && typeof value === 'object') {\n          next.push(value)\n        }\n      }\n    }\n  }\n  return obj\n}\n\nfunction parse (text, reviver, options) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, options)\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nfunction safeParse (text, reviver) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, { safe: true })\n  } catch (_e) {\n    return null\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nmodule.exports = parse\nmodule.exports.default = parse\nmodule.exports.parse = parse\nmodule.exports.safeParse = safeParse\nmodule.exports.scan = filter\n", "\"use strict\";\n\n// ref: https://github.com/tc39/proposal-global\nvar getGlobal = function() {\n    // the only reliable means to get the global object is\n    // `Function('return this')()`\n    // However, this causes CSP violations in Chrome apps.\n    if (typeof self !== 'undefined') { return self; }\n    if (typeof window !== 'undefined') { return window; }\n    if (typeof global !== 'undefined') { return global; }\n    throw new Error('unable to locate global object');\n}\n\nvar globalObject = getGlobal();\n\nexport const fetch = globalObject.fetch;\n\nexport default globalObject.fetch.bind(globalObject);\n\nexport const Headers = globalObject.Headers;\nexport const Request = globalObject.Request;\nexport const Response = globalObject.Response;\n", "/**\n * Error format\n *\n * {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}\n */\nexport default class PostgrestError extends Error {\n  details: string\n  hint: string\n  code: string\n\n  constructor(context: { message: string; details: string; hint: string; code: string }) {\n    super(context.message)\n    this.name = 'PostgrestError'\n    this.details = context.details\n    this.hint = context.hint\n    this.code = context.code\n  }\n}\n", "// @ts-ignore\nimport nodeFetch from '@supabase/node-fetch'\n\nimport type {\n  Fetch,\n  PostgrestSingleResponse,\n  PostgrestResponseSuccess,\n  CheckMatchingArrayTypes,\n  MergePartialResult,\n  IsValidResultOverride,\n} from './types'\nimport PostgrestError from './PostgrestError'\nimport { ContainsNull } from './select-query-parser/types'\n\nexport default abstract class PostgrestBuilder<Result, ThrowOnError extends boolean = false>\n  implements\n    PromiseLike<\n      ThrowOnError extends true ? PostgrestResponseSuccess<Result> : PostgrestSingleResponse<Result>\n    >\n{\n  protected method: 'GET' | 'HEAD' | 'POST' | 'PATCH' | 'DELETE'\n  protected url: URL\n  protected headers: Record<string, string>\n  protected schema?: string\n  protected body?: unknown\n  protected shouldThrowOnError = false\n  protected signal?: AbortSignal\n  protected fetch: Fetch\n  protected isMaybeSingle: boolean\n\n  constructor(builder: PostgrestBuilder<Result>) {\n    this.method = builder.method\n    this.url = builder.url\n    this.headers = builder.headers\n    this.schema = builder.schema\n    this.body = builder.body\n    this.shouldThrowOnError = builder.shouldThrowOnError\n    this.signal = builder.signal\n    this.isMaybeSingle = builder.isMaybeSingle\n\n    if (builder.fetch) {\n      this.fetch = builder.fetch\n    } else if (typeof fetch === 'undefined') {\n      this.fetch = nodeFetch\n    } else {\n      this.fetch = fetch\n    }\n  }\n\n  /**\n   * If there's an error with the query, throwOnError will reject the promise by\n   * throwing the error instead of returning it as part of a successful response.\n   *\n   * {@link https://github.com/supabase/supabase-js/issues/92}\n   */\n  throwOnError(): this & PostgrestBuilder<Result, true> {\n    this.shouldThrowOnError = true\n    return this as this & PostgrestBuilder<Result, true>\n  }\n\n  /**\n   * Set an HTTP header for the request.\n   */\n  setHeader(name: string, value: string): this {\n    this.headers = { ...this.headers }\n    this.headers[name] = value\n    return this\n  }\n\n  then<\n    TResult1 = ThrowOnError extends true\n      ? PostgrestResponseSuccess<Result>\n      : PostgrestSingleResponse<Result>,\n    TResult2 = never\n  >(\n    onfulfilled?:\n      | ((\n          value: ThrowOnError extends true\n            ? PostgrestResponseSuccess<Result>\n            : PostgrestSingleResponse<Result>\n        ) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n  ): PromiseLike<TResult1 | TResult2> {\n    // https://postgrest.org/en/stable/api.html#switching-schemas\n    if (this.schema === undefined) {\n      // skip\n    } else if (['GET', 'HEAD'].includes(this.method)) {\n      this.headers['Accept-Profile'] = this.schema\n    } else {\n      this.headers['Content-Profile'] = this.schema\n    }\n    if (this.method !== 'GET' && this.method !== 'HEAD') {\n      this.headers['Content-Type'] = 'application/json'\n    }\n\n    // NOTE: Invoke w/o `this` to avoid illegal invocation error.\n    // https://github.com/supabase/postgrest-js/pull/247\n    const _fetch = this.fetch\n    let res = _fetch(this.url.toString(), {\n      method: this.method,\n      headers: this.headers,\n      body: JSON.stringify(this.body),\n      signal: this.signal,\n    }).then(async (res) => {\n      let error = null\n      let data = null\n      let count: number | null = null\n      let status = res.status\n      let statusText = res.statusText\n\n      if (res.ok) {\n        if (this.method !== 'HEAD') {\n          const body = await res.text()\n          if (body === '') {\n            // Prefer: return=minimal\n          } else if (this.headers['Accept'] === 'text/csv') {\n            data = body\n          } else if (\n            this.headers['Accept'] &&\n            this.headers['Accept'].includes('application/vnd.pgrst.plan+text')\n          ) {\n            data = body\n          } else {\n            data = JSON.parse(body)\n          }\n        }\n\n        const countHeader = this.headers['Prefer']?.match(/count=(exact|planned|estimated)/)\n        const contentRange = res.headers.get('content-range')?.split('/')\n        if (countHeader && contentRange && contentRange.length > 1) {\n          count = parseInt(contentRange[1])\n        }\n\n        // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n        // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n        if (this.isMaybeSingle && this.method === 'GET' && Array.isArray(data)) {\n          if (data.length > 1) {\n            error = {\n              // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553\n              code: 'PGRST116',\n              details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,\n              hint: null,\n              message: 'JSON object requested, multiple (or no) rows returned',\n            }\n            data = null\n            count = null\n            status = 406\n            statusText = 'Not Acceptable'\n          } else if (data.length === 1) {\n            data = data[0]\n          } else {\n            data = null\n          }\n        }\n      } else {\n        const body = await res.text()\n\n        try {\n          error = JSON.parse(body)\n\n          // Workaround for https://github.com/supabase/postgrest-js/issues/295\n          if (Array.isArray(error) && res.status === 404) {\n            data = []\n            error = null\n            status = 200\n            statusText = 'OK'\n          }\n        } catch {\n          // Workaround for https://github.com/supabase/postgrest-js/issues/295\n          if (res.status === 404 && body === '') {\n            status = 204\n            statusText = 'No Content'\n          } else {\n            error = {\n              message: body,\n            }\n          }\n        }\n\n        if (error && this.isMaybeSingle && error?.details?.includes('0 rows')) {\n          error = null\n          status = 200\n          statusText = 'OK'\n        }\n\n        if (error && this.shouldThrowOnError) {\n          throw new PostgrestError(error)\n        }\n      }\n\n      const postgrestResponse = {\n        error,\n        data,\n        count,\n        status,\n        statusText,\n      }\n\n      return postgrestResponse\n    })\n    if (!this.shouldThrowOnError) {\n      res = res.catch((fetchError) => ({\n        error: {\n          message: `${fetchError?.name ?? 'FetchError'}: ${fetchError?.message}`,\n          details: `${fetchError?.stack ?? ''}`,\n          hint: '',\n          code: `${fetchError?.code ?? ''}`,\n        },\n        data: null,\n        count: null,\n        status: 0,\n        statusText: '',\n      }))\n    }\n\n    return res.then(onfulfilled, onrejected)\n  }\n\n  /**\n   * Override the type of the returned `data`.\n   *\n   * @typeParam NewResult - The new result type to override with\n   * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n   */\n  returns<NewResult>(): PostgrestBuilder<CheckMatchingArrayTypes<Result, NewResult>, ThrowOnError> {\n    /* istanbul ignore next */\n    return this as unknown as PostgrestBuilder<\n      CheckMatchingArrayTypes<Result, NewResult>,\n      ThrowOnError\n    >\n  }\n\n  /**\n   * Override the type of the returned `data` field in the response.\n   *\n   * @typeParam NewResult - The new type to cast the response data to\n   * @typeParam Options - Optional type configuration (defaults to { merge: true })\n   * @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)\n   * @example\n   * ```typescript\n   * // Merge with existing types (default behavior)\n   * const query = supabase\n   *   .from('users')\n   *   .select()\n   *   .overrideTypes<{ custom_field: string }>()\n   *\n   * // Replace existing types completely\n   * const replaceQuery = supabase\n   *   .from('users')\n   *   .select()\n   *   .overrideTypes<{ id: number; name: string }, { merge: false }>()\n   * ```\n   * @returns A PostgrestBuilder instance with the new type\n   */\n  overrideTypes<\n    NewResult,\n    Options extends { merge?: boolean } = { merge: true }\n  >(): PostgrestBuilder<\n    IsValidResultOverride<Result, NewResult, false, false> extends true\n      ? // Preserve the optionality of the result if the overriden type is an object (case of chaining with `maybeSingle`)\n        ContainsNull<Result> extends true\n        ? MergePartialResult<NewResult, NonNullable<Result>, Options> | null\n        : MergePartialResult<NewResult, Result, Options>\n      : CheckMatchingArrayTypes<Result, NewResult>,\n    ThrowOnError\n  > {\n    return this as unknown as PostgrestBuilder<\n      IsValidResultOverride<Result, NewResult, false, false> extends true\n        ? // Preserve the optionality of the result if the overriden type is an object (case of chaining with `maybeSingle`)\n          ContainsNull<Result> extends true\n          ? MergePartialResult<NewResult, NonNullable<Result>, Options> | null\n          : MergePartialResult<NewResult, Result, Options>\n        : CheckMatchingArrayTypes<Result, NewResult>,\n      ThrowOnError\n    >\n  }\n}\n", "import PostgrestBuilder from './PostgrestBuilder'\nimport { GetResult } from './select-query-parser/result'\nimport { GenericSchema, CheckMatchingArrayTypes } from './types'\n\nexport default class PostgrestTransformBuilder<\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  Result,\n  RelationName = unknown,\n  Relationships = unknown\n> extends PostgrestBuilder<Result> {\n  /**\n   * Perform a SELECT on the query result.\n   *\n   * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n   * return modified rows. By calling this method, modified rows are returned in\n   * `data`.\n   *\n   * @param columns - The columns to retrieve, separated by commas\n   */\n  select<\n    Query extends string = '*',\n    NewResultOne = GetResult<Schema, Row, RelationName, Relationships, Query>\n  >(\n    columns?: Query\n  ): PostgrestTransformBuilder<Schema, Row, NewResultOne[], RelationName, Relationships> {\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = (columns ?? '*')\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n    if (this.headers['Prefer']) {\n      this.headers['Prefer'] += ','\n    }\n    this.headers['Prefer'] += 'return=representation'\n    return this as unknown as PostgrestTransformBuilder<\n      Schema,\n      Row,\n      NewResultOne[],\n      RelationName,\n      Relationships\n    >\n  }\n\n  order<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    options?: { ascending?: boolean; nullsFirst?: boolean; referencedTable?: undefined }\n  ): this\n  order(\n    column: string,\n    options?: { ascending?: boolean; nullsFirst?: boolean; referencedTable?: string }\n  ): this\n  /**\n   * @deprecated Use `options.referencedTable` instead of `options.foreignTable`\n   */\n  order<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    options?: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: undefined }\n  ): this\n  /**\n   * @deprecated Use `options.referencedTable` instead of `options.foreignTable`\n   */\n  order(\n    column: string,\n    options?: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: string }\n  ): this\n  /**\n   * Order the query result by `column`.\n   *\n   * You can call this method multiple times to order by multiple columns.\n   *\n   * You can order referenced tables, but it only affects the ordering of the\n   * parent table if you use `!inner` in the query.\n   *\n   * @param column - The column to order by\n   * @param options - Named parameters\n   * @param options.ascending - If `true`, the result will be in ascending order\n   * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n   * `null`s appear last.\n   * @param options.referencedTable - Set this to order a referenced table by\n   * its columns\n   * @param options.foreignTable - Deprecated, use `options.referencedTable`\n   * instead\n   */\n  order(\n    column: string,\n    {\n      ascending = true,\n      nullsFirst,\n      foreignTable,\n      referencedTable = foreignTable,\n    }: {\n      ascending?: boolean\n      nullsFirst?: boolean\n      foreignTable?: string\n      referencedTable?: string\n    } = {}\n  ): this {\n    const key = referencedTable ? `${referencedTable}.order` : 'order'\n    const existingOrder = this.url.searchParams.get(key)\n\n    this.url.searchParams.set(\n      key,\n      `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}${\n        nullsFirst === undefined ? '' : nullsFirst ? '.nullsfirst' : '.nullslast'\n      }`\n    )\n    return this\n  }\n\n  /**\n   * Limit the query result by `count`.\n   *\n   * @param count - The maximum number of rows to return\n   * @param options - Named parameters\n   * @param options.referencedTable - Set this to limit rows of referenced\n   * tables instead of the parent table\n   * @param options.foreignTable - Deprecated, use `options.referencedTable`\n   * instead\n   */\n  limit(\n    count: number,\n    {\n      foreignTable,\n      referencedTable = foreignTable,\n    }: { foreignTable?: string; referencedTable?: string } = {}\n  ): this {\n    const key = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`\n    this.url.searchParams.set(key, `${count}`)\n    return this\n  }\n\n  /**\n   * Limit the query result by starting at an offset `from` and ending at the offset `to`.\n   * Only records within this range are returned.\n   * This respects the query order and if there is no order clause the range could behave unexpectedly.\n   * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third\n   * and fourth rows of the query.\n   *\n   * @param from - The starting index from which to limit the result\n   * @param to - The last index to which to limit the result\n   * @param options - Named parameters\n   * @param options.referencedTable - Set this to limit rows of referenced\n   * tables instead of the parent table\n   * @param options.foreignTable - Deprecated, use `options.referencedTable`\n   * instead\n   */\n  range(\n    from: number,\n    to: number,\n    {\n      foreignTable,\n      referencedTable = foreignTable,\n    }: { foreignTable?: string; referencedTable?: string } = {}\n  ): this {\n    const keyOffset =\n      typeof referencedTable === 'undefined' ? 'offset' : `${referencedTable}.offset`\n    const keyLimit = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`\n    this.url.searchParams.set(keyOffset, `${from}`)\n    // Range is inclusive, so add 1\n    this.url.searchParams.set(keyLimit, `${to - from + 1}`)\n    return this\n  }\n\n  /**\n   * Set the AbortSignal for the fetch request.\n   *\n   * @param signal - The AbortSignal to use for the fetch request\n   */\n  abortSignal(signal: AbortSignal): this {\n    this.signal = signal\n    return this\n  }\n\n  /**\n   * Return `data` as a single object instead of an array of objects.\n   *\n   * Query result must be one row (e.g. using `.limit(1)`), otherwise this\n   * returns an error.\n   */\n  single<\n    ResultOne = Result extends (infer ResultOne)[] ? ResultOne : never\n  >(): PostgrestBuilder<ResultOne> {\n    this.headers['Accept'] = 'application/vnd.pgrst.object+json'\n    return this as unknown as PostgrestBuilder<ResultOne>\n  }\n\n  /**\n   * Return `data` as a single object instead of an array of objects.\n   *\n   * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n   * this returns an error.\n   */\n  maybeSingle<\n    ResultOne = Result extends (infer ResultOne)[] ? ResultOne : never\n  >(): PostgrestBuilder<ResultOne | null> {\n    // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n    // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n    if (this.method === 'GET') {\n      this.headers['Accept'] = 'application/json'\n    } else {\n      this.headers['Accept'] = 'application/vnd.pgrst.object+json'\n    }\n    this.isMaybeSingle = true\n    return this as unknown as PostgrestBuilder<ResultOne | null>\n  }\n\n  /**\n   * Return `data` as a string in CSV format.\n   */\n  csv(): PostgrestBuilder<string> {\n    this.headers['Accept'] = 'text/csv'\n    return this as unknown as PostgrestBuilder<string>\n  }\n\n  /**\n   * Return `data` as an object in [GeoJSON](https://geojson.org) format.\n   */\n  geojson(): PostgrestBuilder<Record<string, unknown>> {\n    this.headers['Accept'] = 'application/geo+json'\n    return this as unknown as PostgrestBuilder<Record<string, unknown>>\n  }\n\n  /**\n   * Return `data` as the EXPLAIN plan for the query.\n   *\n   * You need to enable the\n   * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)\n   * setting before using this method.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.analyze - If `true`, the query will be executed and the\n   * actual run time will be returned\n   *\n   * @param options.verbose - If `true`, the query identifier will be returned\n   * and `data` will include the output columns of the query\n   *\n   * @param options.settings - If `true`, include information on configuration\n   * parameters that affect query planning\n   *\n   * @param options.buffers - If `true`, include information on buffer usage\n   *\n   * @param options.wal - If `true`, include information on WAL record generation\n   *\n   * @param options.format - The format of the output, can be `\"text\"` (default)\n   * or `\"json\"`\n   */\n  explain({\n    analyze = false,\n    verbose = false,\n    settings = false,\n    buffers = false,\n    wal = false,\n    format = 'text',\n  }: {\n    analyze?: boolean\n    verbose?: boolean\n    settings?: boolean\n    buffers?: boolean\n    wal?: boolean\n    format?: 'json' | 'text'\n  } = {}): PostgrestBuilder<Record<string, unknown>[]> | PostgrestBuilder<string> {\n    const options = [\n      analyze ? 'analyze' : null,\n      verbose ? 'verbose' : null,\n      settings ? 'settings' : null,\n      buffers ? 'buffers' : null,\n      wal ? 'wal' : null,\n    ]\n      .filter(Boolean)\n      .join('|')\n    // An Accept header can carry multiple media types but postgrest-js always sends one\n    const forMediatype = this.headers['Accept'] ?? 'application/json'\n    this.headers[\n      'Accept'\n    ] = `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`\n    if (format === 'json') return this as unknown as PostgrestBuilder<Record<string, unknown>[]>\n    else return this as unknown as PostgrestBuilder<string>\n  }\n\n  /**\n   * Rollback the query.\n   *\n   * `data` will still be returned, but the query is not committed.\n   */\n  rollback(): this {\n    if ((this.headers['Prefer'] ?? '').trim().length > 0) {\n      this.headers['Prefer'] += ',tx=rollback'\n    } else {\n      this.headers['Prefer'] = 'tx=rollback'\n    }\n    return this\n  }\n\n  /**\n   * Override the type of the returned `data`.\n   *\n   * @typeParam NewResult - The new result type to override with\n   * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n   */\n  returns<NewResult>(): PostgrestTransformBuilder<\n    Schema,\n    Row,\n    CheckMatchingArrayTypes<Result, NewResult>,\n    RelationName,\n    Relationships\n  > {\n    return this as unknown as PostgrestTransformBuilder<\n      Schema,\n      Row,\n      CheckMatchingArrayTypes<Result, NewResult>,\n      RelationName,\n      Relationships\n    >\n  }\n}\n", "import PostgrestTransformBuilder from './PostgrestTransformBuilder'\nimport { JsonPathToAccessor, JsonPathToType } from './select-query-parser/utils'\nimport { GenericSchema } from './types'\n\ntype FilterOperator =\n  | 'eq'\n  | 'neq'\n  | 'gt'\n  | 'gte'\n  | 'lt'\n  | 'lte'\n  | 'like'\n  | 'ilike'\n  | 'is'\n  | 'in'\n  | 'cs'\n  | 'cd'\n  | 'sl'\n  | 'sr'\n  | 'nxl'\n  | 'nxr'\n  | 'adj'\n  | 'ov'\n  | 'fts'\n  | 'plfts'\n  | 'phfts'\n  | 'wfts'\n\nexport type IsStringOperator<Path extends string> = Path extends `${string}->>${string}`\n  ? true\n  : false\n\n// Match relationship filters with `table.column` syntax and resolve underlying\n// column value. If not matched, fallback to generic type.\n// TODO: Validate the relationship itself ala select-query-parser. Currently we\n// assume that all tables have valid relationships to each other, despite\n// nonexistent foreign keys.\ntype ResolveFilterValue<\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  ColumnName extends string\n> = ColumnName extends `${infer RelationshipTable}.${infer Remainder}`\n  ? Remainder extends `${infer _}.${infer _}`\n    ? ResolveFilterValue<Schema, Row, Remainder>\n    : ResolveFilterRelationshipValue<Schema, RelationshipTable, Remainder>\n  : ColumnName extends keyof Row\n  ? Row[ColumnName]\n  : // If the column selection is a jsonpath like `data->value` or `data->>value` we attempt to match\n  // the expected type with the parsed custom json type\n  IsStringOperator<ColumnName> extends true\n  ? string\n  : JsonPathToType<Row, JsonPathToAccessor<ColumnName>> extends infer JsonPathValue\n  ? JsonPathValue extends never\n    ? never\n    : JsonPathValue\n  : never\n\ntype ResolveFilterRelationshipValue<\n  Schema extends GenericSchema,\n  RelationshipTable extends string,\n  RelationshipColumn extends string\n> = Schema['Tables'] & Schema['Views'] extends infer TablesAndViews\n  ? RelationshipTable extends keyof TablesAndViews\n    ? 'Row' extends keyof TablesAndViews[RelationshipTable]\n      ? RelationshipColumn extends keyof TablesAndViews[RelationshipTable]['Row']\n        ? TablesAndViews[RelationshipTable]['Row'][RelationshipColumn]\n        : unknown\n      : unknown\n    : unknown\n  : never\n\nexport default class PostgrestFilterBuilder<\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  Result,\n  RelationName = unknown,\n  Relationships = unknown\n> extends PostgrestTransformBuilder<Schema, Row, Result, RelationName, Relationships> {\n  /**\n   * Match only rows where `column` is equal to `value`.\n   *\n   * To check if the value of `column` is NULL, you should use `.is()` instead.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  eq<ColumnName extends string>(\n    column: ColumnName,\n    value: ResolveFilterValue<Schema, Row, ColumnName> extends never\n      ? NonNullable<unknown>\n      : // We want to infer the type before wrapping it into a `NonNullable` to avoid too deep\n      // type resolution error\n      ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n      ? NonNullable<ResolvedFilterValue>\n      : // We should never enter this case as all the branches are covered above\n        never\n  ): this {\n    this.url.searchParams.append(column, `eq.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` is not equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  neq<ColumnName extends string>(\n    column: ColumnName,\n    value: ResolveFilterValue<Schema, Row, ColumnName> extends never\n      ? unknown\n      : ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n      ? ResolvedFilterValue\n      : never\n  ): this {\n    this.url.searchParams.append(column, `neq.${value}`)\n    return this\n  }\n\n  gt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  gt(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is greater than `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  gt(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `gt.${value}`)\n    return this\n  }\n\n  gte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  gte(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is greater than or equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  gte(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `gte.${value}`)\n    return this\n  }\n\n  lt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  lt(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is less than `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  lt(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `lt.${value}`)\n    return this\n  }\n\n  lte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  lte(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is less than or equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  lte(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `lte.${value}`)\n    return this\n  }\n\n  like<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  like(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches `pattern` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param pattern - The pattern to match with\n   */\n  like(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `like.${pattern}`)\n    return this\n  }\n\n  likeAllOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  likeAllOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches all of `patterns` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  likeAllOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `like(all).{${patterns.join(',')}}`)\n    return this\n  }\n\n  likeAnyOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  likeAnyOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches any of `patterns` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  likeAnyOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `like(any).{${patterns.join(',')}}`)\n    return this\n  }\n\n  ilike<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  ilike(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches `pattern` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param pattern - The pattern to match with\n   */\n  ilike(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `ilike.${pattern}`)\n    return this\n  }\n\n  ilikeAllOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  ilikeAllOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches all of `patterns` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  ilikeAllOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `ilike(all).{${patterns.join(',')}}`)\n    return this\n  }\n\n  ilikeAnyOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  ilikeAnyOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches any of `patterns` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  ilikeAnyOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `ilike(any).{${patterns.join(',')}}`)\n    return this\n  }\n\n  is<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: Row[ColumnName] & (boolean | null)\n  ): this\n  is(column: string, value: boolean | null): this\n  /**\n   * Match only rows where `column` IS `value`.\n   *\n   * For non-boolean columns, this is only relevant for checking if the value of\n   * `column` is NULL by setting `value` to `null`.\n   *\n   * For boolean columns, you can also set `value` to `true` or `false` and it\n   * will behave the same way as `.eq()`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  is(column: string, value: boolean | null): this {\n    this.url.searchParams.append(column, `is.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` is included in the `values` array.\n   *\n   * @param column - The column to filter on\n   * @param values - The values array to filter with\n   */\n  in<ColumnName extends string>(\n    column: ColumnName,\n    values: ReadonlyArray<\n      ResolveFilterValue<Schema, Row, ColumnName> extends never\n        ? unknown\n        : // We want to infer the type before wrapping it into a `NonNullable` to avoid too deep\n        // type resolution error\n        ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n        ? ResolvedFilterValue\n        : // We should never enter this case as all the branches are covered above\n          never\n    >\n  ): this {\n    const cleanedValues = Array.from(new Set(values))\n      .map((s) => {\n        // handle postgrest reserved characters\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n        if (typeof s === 'string' && new RegExp('[,()]').test(s)) return `\"${s}\"`\n        else return `${s}`\n      })\n      .join(',')\n    this.url.searchParams.append(column, `in.(${cleanedValues})`)\n    return this\n  }\n\n  contains<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | ReadonlyArray<Row[ColumnName]> | Record<string, unknown>\n  ): this\n  contains(column: string, value: string | readonly unknown[] | Record<string, unknown>): this\n  /**\n   * Only relevant for jsonb, array, and range columns. Match only rows where\n   * `column` contains every element appearing in `value`.\n   *\n   * @param column - The jsonb, array, or range column to filter on\n   * @param value - The jsonb, array, or range value to filter with\n   */\n  contains(column: string, value: string | readonly unknown[] | Record<string, unknown>): this {\n    if (typeof value === 'string') {\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n      // keep it simple and accept a string\n      this.url.searchParams.append(column, `cs.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cs.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  containedBy<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | ReadonlyArray<Row[ColumnName]> | Record<string, unknown>\n  ): this\n  containedBy(column: string, value: string | readonly unknown[] | Record<string, unknown>): this\n  /**\n   * Only relevant for jsonb, array, and range columns. Match only rows where\n   * every element appearing in `column` is contained by `value`.\n   *\n   * @param column - The jsonb, array, or range column to filter on\n   * @param value - The jsonb, array, or range value to filter with\n   */\n  containedBy(column: string, value: string | readonly unknown[] | Record<string, unknown>): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `cd.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cd.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  rangeGt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeGt(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is greater than any element in `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeGt(column: string, range: string): this {\n    this.url.searchParams.append(column, `sr.${range}`)\n    return this\n  }\n\n  rangeGte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeGte(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is either contained in `range` or greater than any element in\n   * `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeGte(column: string, range: string): this {\n    this.url.searchParams.append(column, `nxl.${range}`)\n    return this\n  }\n\n  rangeLt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeLt(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is less than any element in `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeLt(column: string, range: string): this {\n    this.url.searchParams.append(column, `sl.${range}`)\n    return this\n  }\n\n  rangeLte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeLte(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is either contained in `range` or less than any element in\n   * `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeLte(column: string, range: string): this {\n    this.url.searchParams.append(column, `nxr.${range}`)\n    return this\n  }\n\n  rangeAdjacent<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeAdjacent(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where `column` is\n   * mutually exclusive to `range` and there can be no element between the two\n   * ranges.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeAdjacent(column: string, range: string): this {\n    this.url.searchParams.append(column, `adj.${range}`)\n    return this\n  }\n\n  overlaps<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | ReadonlyArray<Row[ColumnName]>\n  ): this\n  overlaps(column: string, value: string | readonly unknown[]): this\n  /**\n   * Only relevant for array and range columns. Match only rows where\n   * `column` and `value` have an element in common.\n   *\n   * @param column - The array or range column to filter on\n   * @param value - The array or range value to filter with\n   */\n  overlaps(column: string, value: string | readonly unknown[]): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `ov.${value}`)\n    } else {\n      // array\n      this.url.searchParams.append(column, `ov.{${value.join(',')}}`)\n    }\n    return this\n  }\n\n  textSearch<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    query: string,\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\n  ): this\n  textSearch(\n    column: string,\n    query: string,\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\n  ): this\n  /**\n   * Only relevant for text and tsvector columns. Match only rows where\n   * `column` matches the query string in `query`.\n   *\n   * @param column - The text or tsvector column to filter on\n   * @param query - The query text to match with\n   * @param options - Named parameters\n   * @param options.config - The text search configuration to use\n   * @param options.type - Change how the `query` text is interpreted\n   */\n  textSearch(\n    column: string,\n    query: string,\n    { config, type }: { config?: string; type?: 'plain' | 'phrase' | 'websearch' } = {}\n  ): this {\n    let typePart = ''\n    if (type === 'plain') {\n      typePart = 'pl'\n    } else if (type === 'phrase') {\n      typePart = 'ph'\n    } else if (type === 'websearch') {\n      typePart = 'w'\n    }\n    const configPart = config === undefined ? '' : `(${config})`\n    this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`)\n    return this\n  }\n\n  match<ColumnName extends string & keyof Row>(query: Record<ColumnName, Row[ColumnName]>): this\n  match(query: Record<string, unknown>): this\n  /**\n   * Match only rows where each column in `query` keys is equal to its\n   * associated value. Shorthand for multiple `.eq()`s.\n   *\n   * @param query - The object to filter with, with column names as keys mapped\n   * to their filter values\n   */\n  match(query: Record<string, unknown>): this {\n    Object.entries(query).forEach(([column, value]) => {\n      this.url.searchParams.append(column, `eq.${value}`)\n    })\n    return this\n  }\n\n  not<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    operator: FilterOperator,\n    value: Row[ColumnName]\n  ): this\n  not(column: string, operator: string, value: unknown): this\n  /**\n   * Match only rows which doesn't satisfy the filter.\n   *\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\n   * follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure they are properly sanitized.\n   *\n   * @param column - The column to filter on\n   * @param operator - The operator to be negated to filter with, following\n   * PostgREST syntax\n   * @param value - The value to filter with, following PostgREST syntax\n   */\n  not(column: string, operator: string, value: unknown): this {\n    this.url.searchParams.append(column, `not.${operator}.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows which satisfy at least one of the filters.\n   *\n   * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure it's properly sanitized.\n   *\n   * It's currently not possible to do an `.or()` filter across multiple tables.\n   *\n   * @param filters - The filters to use, following PostgREST syntax\n   * @param options - Named parameters\n   * @param options.referencedTable - Set this to filter on referenced tables\n   * instead of the parent table\n   * @param options.foreignTable - Deprecated, use `referencedTable` instead\n   */\n  or(\n    filters: string,\n    {\n      foreignTable,\n      referencedTable = foreignTable,\n    }: { foreignTable?: string; referencedTable?: string } = {}\n  ): this {\n    const key = referencedTable ? `${referencedTable}.or` : 'or'\n    this.url.searchParams.append(key, `(${filters})`)\n    return this\n  }\n\n  filter<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    operator: `${'' | 'not.'}${FilterOperator}`,\n    value: unknown\n  ): this\n  filter(column: string, operator: string, value: unknown): this\n  /**\n   * Match only rows which satisfy the filter. This is an escape hatch - you\n   * should use the specific filter methods wherever possible.\n   *\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\n   * follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure they are properly sanitized.\n   *\n   * @param column - The column to filter on\n   * @param operator - The operator to filter with, following PostgREST syntax\n   * @param value - The value to filter with, following PostgREST syntax\n   */\n  filter(column: string, operator: string, value: unknown): this {\n    this.url.searchParams.append(column, `${operator}.${value}`)\n    return this\n  }\n}\n", "import PostgrestBuilder from './PostgrestBuilder'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport { GetResult } from './select-query-parser/result'\nimport { Fetch, GenericSchema, GenericTable, GenericView } from './types'\n\nexport default class PostgrestQueryBuilder<\n  Schema extends GenericSchema,\n  Relation extends GenericTable | GenericView,\n  RelationName = unknown,\n  Relationships = Relation extends { Relationships: infer R } ? R : unknown\n> {\n  url: URL\n  headers: Record<string, string>\n  schema?: string\n  signal?: AbortSignal\n  fetch?: Fetch\n\n  constructor(\n    url: URL,\n    {\n      headers = {},\n      schema,\n      fetch,\n    }: {\n      headers?: Record<string, string>\n      schema?: string\n      fetch?: Fetch\n    }\n  ) {\n    this.url = url\n    this.headers = headers\n    this.schema = schema\n    this.fetch = fetch\n  }\n\n  /**\n   * Perform a SELECT query on the table or view.\n   *\n   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n   *\n   * @param options - Named parameters\n   *\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   *\n   * @param options.count - Count algorithm to use to count rows in the table or view.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  select<\n    Query extends string = '*',\n    ResultOne = GetResult<Schema, Relation['Row'], RelationName, Relationships, Query>\n  >(\n    columns?: Query,\n    {\n      head = false,\n      count,\n    }: {\n      head?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], ResultOne[], RelationName, Relationships> {\n    const method = head ? 'HEAD' : 'GET'\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = (columns ?? '*')\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n    if (count) {\n      this.headers['Prefer'] = `count=${count}`\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<ResultOne[]>)\n  }\n\n  // TODO(v3): Make `defaultToNull` consistent for both single & bulk inserts.\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row,\n    options?: {\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships>\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row[],\n    options?: {\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    }\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships>\n  /**\n   * Perform an INSERT into the table or view.\n   *\n   * By default, inserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to insert. Pass an object to insert a single row\n   * or an array to insert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count inserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. Only applies for bulk\n   * inserts.\n   */\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      count,\n      defaultToNull = true,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships> {\n    const method = 'POST'\n\n    const prefersHeaders = []\n    if (this.headers['Prefer']) {\n      prefersHeaders.push(this.headers['Prefer'])\n    }\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (!defaultToNull) {\n      prefersHeaders.push('missing=default')\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<null>)\n  }\n\n  // TODO(v3): Make `defaultToNull` consistent for both single & bulk upserts.\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row,\n    options?: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships>\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row[],\n    options?: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    }\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships>\n  /**\n   * Perform an UPSERT on the table or view. Depending on the column(s) passed\n   * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n   * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n   * exist, or if it does exist, perform an alternative action depending on\n   * `ignoreDuplicates`.\n   *\n   * By default, upserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to upsert with. Pass an object to upsert a\n   * single row or an array to upsert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n   * duplicate rows are determined. Two rows are duplicates if all the\n   * `onConflict` columns are equal.\n   *\n   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n   * `false`, duplicate rows are merged with existing rows.\n   *\n   * @param options.count - Count algorithm to use to count upserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. This only applies when\n   * inserting new rows, not when merging with existing rows under\n   * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n   */\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      onConflict,\n      ignoreDuplicates = false,\n      count,\n      defaultToNull = true,\n    }: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships> {\n    const method = 'POST'\n\n    const prefersHeaders = [`resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`]\n\n    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict)\n    if (this.headers['Prefer']) {\n      prefersHeaders.push(this.headers['Prefer'])\n    }\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (!defaultToNull) {\n      prefersHeaders.push('missing=default')\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<null>)\n  }\n\n  /**\n   * Perform an UPDATE on the table or view.\n   *\n   * By default, updated rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param values - The values to update with\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count updated rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  update<Row extends Relation extends { Update: unknown } ? Relation['Update'] : never>(\n    values: Row,\n    {\n      count,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships> {\n    const method = 'PATCH'\n    const prefersHeaders = []\n    if (this.headers['Prefer']) {\n      prefersHeaders.push(this.headers['Prefer'])\n    }\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<null>)\n  }\n\n  /**\n   * Perform a DELETE on the table or view.\n   *\n   * By default, deleted rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count deleted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  delete({\n    count,\n  }: {\n    count?: 'exact' | 'planned' | 'estimated'\n  } = {}): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships> {\n    const method = 'DELETE'\n    const prefersHeaders = []\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer'])\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<null>)\n  }\n}\n", "export const version = '1.19.4'\n", "import { version } from './version'\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `postgrest-js/${version}` }\n", "import PostgrestQueryBuilder from './PostgrestQueryBuilder'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport PostgrestBuilder from './PostgrestBuilder'\nimport { DEFAULT_HEADERS } from './constants'\nimport { Fetch, GenericSchema } from './types'\n\n/**\n * PostgREST client.\n *\n * @typeParam Database - Types for the schema from the [type\n * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n *\n * @typeParam SchemaName - Postgres schema to switch to. Must be a string\n * literal, the same one passed to the constructor. If the schema is not\n * `\"public\"`, this must be supplied manually.\n */\nexport default class PostgrestClient<\n  Database = any,\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\n    ? 'public'\n    : string & keyof Database,\n  Schema extends GenericSchema = Database[SchemaName] extends GenericSchema\n    ? Database[SchemaName]\n    : any\n> {\n  url: string\n  headers: Record<string, string>\n  schemaName?: SchemaName\n  fetch?: Fetch\n\n  // TODO: Add back shouldThrowOnError once we figure out the typings\n  /**\n   * Creates a PostgREST client.\n   *\n   * @param url - URL of the PostgREST endpoint\n   * @param options - Named parameters\n   * @param options.headers - Custom headers\n   * @param options.schema - Postgres schema to switch to\n   * @param options.fetch - Custom fetch\n   */\n  constructor(\n    url: string,\n    {\n      headers = {},\n      schema,\n      fetch,\n    }: {\n      headers?: Record<string, string>\n      schema?: SchemaName\n      fetch?: Fetch\n    } = {}\n  ) {\n    this.url = url\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\n    this.schemaName = schema\n    this.fetch = fetch\n  }\n\n  from<\n    TableName extends string & keyof Schema['Tables'],\n    Table extends Schema['Tables'][TableName]\n  >(relation: TableName): PostgrestQueryBuilder<Schema, Table, TableName>\n  from<ViewName extends string & keyof Schema['Views'], View extends Schema['Views'][ViewName]>(\n    relation: ViewName\n  ): PostgrestQueryBuilder<Schema, View, ViewName>\n  /**\n   * Perform a query on a table or a view.\n   *\n   * @param relation - The table or view name to query\n   */\n  from(relation: string): PostgrestQueryBuilder<Schema, any, any> {\n    const url = new URL(`${this.url}/${relation}`)\n    return new PostgrestQueryBuilder(url, {\n      headers: { ...this.headers },\n      schema: this.schemaName,\n      fetch: this.fetch,\n    })\n  }\n\n  /**\n   * Select a schema to query or perform an function (rpc) call.\n   *\n   * The schema needs to be on the list of exposed schemas inside Supabase.\n   *\n   * @param schema - The schema to query\n   */\n  schema<DynamicSchema extends string & keyof Database>(\n    schema: DynamicSchema\n  ): PostgrestClient<\n    Database,\n    DynamicSchema,\n    Database[DynamicSchema] extends GenericSchema ? Database[DynamicSchema] : any\n  > {\n    return new PostgrestClient(this.url, {\n      headers: this.headers,\n      schema,\n      fetch: this.fetch,\n    })\n  }\n\n  /**\n   * Perform a function call.\n   *\n   * @param fn - The function name to call\n   * @param args - The arguments to pass to the function call\n   * @param options - Named parameters\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   * @param options.get - When set to `true`, the function will be called with\n   * read-only access mode.\n   * @param options.count - Count algorithm to use to count rows returned by the\n   * function. Only applicable for [set-returning\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  rpc<FnName extends string & keyof Schema['Functions'], Fn extends Schema['Functions'][FnName]>(\n    fn: FnName,\n    args: Fn['Args'] = {},\n    {\n      head = false,\n      get = false,\n      count,\n    }: {\n      head?: boolean\n      get?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<\n    Schema,\n    Fn['Returns'] extends any[]\n      ? Fn['Returns'][number] extends Record<string, unknown>\n        ? Fn['Returns'][number]\n        : never\n      : never,\n    Fn['Returns'],\n    FnName,\n    null\n  > {\n    let method: 'HEAD' | 'GET' | 'POST'\n    const url = new URL(`${this.url}/rpc/${fn}`)\n    let body: unknown | undefined\n    if (head || get) {\n      method = head ? 'HEAD' : 'GET'\n      Object.entries(args)\n        // params with undefined value needs to be filtered out, otherwise it'll\n        // show up as `?param=undefined`\n        .filter(([_, value]) => value !== undefined)\n        // array values need special syntax\n        .map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(',')}}` : `${value}`])\n        .forEach(([name, value]) => {\n          url.searchParams.append(name, value)\n        })\n    } else {\n      method = 'POST'\n      body = args\n    }\n\n    const headers = { ...this.headers }\n    if (count) {\n      headers['Prefer'] = `count=${count}`\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schemaName,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<Fn['Returns']>)\n  }\n}\n", "// Always update wrapper.mjs when updating this file.\nimport PostgrestClient from './PostgrestClient'\nimport PostgrestQueryBuilder from './PostgrestQueryBuilder'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport PostgrestTransformBuilder from './PostgrestTransformBuilder'\nimport PostgrestBuilder from './PostgrestBuilder'\nimport PostgrestError from './PostgrestError'\n\nexport {\n  PostgrestClient,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestTransformBuilder,\n  PostgrestBuilder,\n  PostgrestError,\n}\nexport default {\n  PostgrestClient,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestTransformBuilder,\n  PostgrestBuilder,\n  PostgrestError,\n}\nexport type {\n  PostgrestResponse,\n  PostgrestResponseFailure,\n  PostgrestResponseSuccess,\n  PostgrestSingleResponse,\n  PostgrestMaybeSingleResponse,\n} from './types'\n// https://github.com/supabase/postgrest-js/issues/551\n// To be replaced with a helper type that only uses public types\nexport type { GetResult as UnstableGetResult } from './select-query-parser/result'\n", "'use strict';\n\nmodule.exports = function () {\n  throw new Error(\n    'ws does not work in the browser. Browser clients must use the native ' +\n      'WebSocket object'\n  );\n};\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/Users/michaelsipes/Desktop/coding/layers-project/remote-mcp-server-authless/.wrangler/tmp/bundle-1Iwz8Z/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/Users/michaelsipes/Desktop/coding/layers-project/remote-mcp-server-authless/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/Users/michaelsipes/Desktop/coding/layers-project/remote-mcp-server-authless/.wrangler/tmp/bundle-1Iwz8Z/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/Users/michaelsipes/Desktop/coding/layers-project/remote-mcp-server-authless/.wrangler/tmp/bundle-1Iwz8Z/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/Users/michaelsipes/Desktop/coding/layers-project/remote-mcp-server-authless/src/index.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/Users/michaelsipes/Desktop/coding/layers-project/remote-mcp-server-authless/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"/Users/michaelsipes/Desktop/coding/layers-project/remote-mcp-server-authless/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"/Users/michaelsipes/Desktop/coding/layers-project/remote-mcp-server-authless/src/index.ts\";\n\t\t\t\tconst MIDDLEWARE_TEST_INJECT = \"__INJECT_FOR_TESTING_WRANGLER_MIDDLEWARE__\";\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "import { McpAgent } from \"agents/mcp\";\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { SupabaseClient, createClient } from \"@supabase/supabase-js\";\nimport { register_secret } from \"./components/secret\";\nimport { register_layer } from \"./components/layer\";\nimport { register_get_outfit_details } from \"./components/get_outfit_details\";\nimport { register_calculate_outfit_warmth } from \"./components/calculate_outfit_warmth\";\nimport { register_logs } from \"./components/get_logs\";\nimport { register_get_weather } from \"./components/get_weather\";\nimport { register_schema } from \"./components/schema\";\n\n// Define Env interface\ninterface Env {\n  SUPABASE_URL: string;\n  SUPABASE_ANON_KEY: string;\n  [key: string]: string | undefined;\n}\n\n// Define our MCP agent with tools\nexport class MyMCP extends McpAgent {\n  server = new McpServer({\n    name: \"Authless Calculator\",\n    version: \"1.0.0\",\n  });\n  \n  declare env: Env;\n  declare supabase: SupabaseClient;\n\n  async init() {\n    // Create Supabase client once\n    console.log(\"creating supabase client\");\n    console.log(\"env\", this.env);\n    this.supabase = createClient(\n      this.env.SUPABASE_URL,\n      this.env.SUPABASE_ANON_KEY\n    );\n\n    const { data, error } = await this.supabase.from(\"layer\").select(\"*\");\n    console.log(\"data\", data);\n    console.log(\"error\", error);\n\n    // Register all components directly\n    register_secret(this.server);\n    register_layer(this.server, this.supabase);\n    register_get_outfit_details(this.server, this.supabase);\n    register_calculate_outfit_warmth(this.server, this.supabase);\n    register_logs(this.server, this.supabase);\n    register_get_weather(this.server, this.supabase);\n    register_schema(this.server);\n  }\n}\n\nexport default {\n  fetch(request: Request, env: Env, ctx: ExecutionContext) {\n    console.log(\"hello from cloudflare worker!\");\n\n    const url = new URL(request.url);\n    console.log(\"url: \", url);\n    if (url.pathname === \"/sse\" || url.pathname === \"/sse/message\") {\n      return MyMCP.serveSSE(\"/sse\").fetch(request, env, ctx);\n    }\n    if (url.pathname === \"/mcp\") {\n      return MyMCP.serve(\"/mcp\").fetch(request, env, ctx);\n    }\n    return new Response(\"Not found\", { status: 404 });\n  },\n};\n", null, "/**\n * The type of error that occurred.\n * @public\n */\nexport type ErrorType = 'invalid-retry' | 'unknown-field'\n\n/**\n * Error thrown when encountering an issue during parsing.\n *\n * @public\n */\nexport class ParseError extends Error {\n  /**\n   * The type of error that occurred.\n   */\n  type: ErrorType\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the field name.\n   */\n  field?: string\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the value of the field.\n   */\n  value?: string\n\n  /**\n   * The line that caused the error, if available.\n   */\n  line?: string\n\n  constructor(\n    message: string,\n    options: {type: ErrorType; field?: string; value?: string; line?: string},\n  ) {\n    super(message)\n    this.name = 'ParseError'\n    this.type = options.type\n    this.field = options.field\n    this.value = options.value\n    this.line = options.line\n  }\n}\n", "/**\n * EventSource/Server-Sent Events parser\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n */\nimport {ParseError} from './errors.ts'\nimport type {EventSourceParser, ParserCallbacks} from './types.ts'\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction noop(_arg: unknown) {\n  // intentional noop\n}\n\n/**\n * Creates a new EventSource parser.\n *\n * @param callbacks - Callbacks to invoke on different parsing events:\n *   - `onEvent` when a new event is parsed\n *   - `onError` when an error occurs\n *   - `onRetry` when a new reconnection interval has been sent from the server\n *   - `onComment` when a comment is encountered in the stream\n *\n * @returns A new EventSource parser, with `parse` and `reset` methods.\n * @public\n */\nexport function createParser(callbacks: ParserCallbacks): EventSourceParser {\n  if (typeof callbacks === 'function') {\n    throw new TypeError(\n      '`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?',\n    )\n  }\n\n  const {onEvent = noop, onError = noop, onRetry = noop, onComment} = callbacks\n\n  let incompleteLine = ''\n\n  let isFirstChunk = true\n  let id: string | undefined\n  let data = ''\n  let eventType = ''\n\n  function feed(newChunk: string) {\n    // Strip any UTF8 byte order mark (BOM) at the start of the stream\n    const chunk = isFirstChunk ? newChunk.replace(/^\\xEF\\xBB\\xBF/, '') : newChunk\n\n    // If there was a previous incomplete line, append it to the new chunk,\n    // so we may process it together as a new (hopefully complete) chunk.\n    const [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`)\n\n    for (const line of complete) {\n      parseLine(line)\n    }\n\n    incompleteLine = incomplete\n    isFirstChunk = false\n  }\n\n  function parseLine(line: string) {\n    // If the line is empty (a blank line), dispatch the event\n    if (line === '') {\n      dispatchEvent()\n      return\n    }\n\n    // If the line starts with a U+003A COLON character (:), ignore the line.\n    if (line.startsWith(':')) {\n      if (onComment) {\n        onComment(line.slice(line.startsWith(': ') ? 2 : 1))\n      }\n      return\n    }\n\n    // If the line contains a U+003A COLON character (:)\n    const fieldSeparatorIndex = line.indexOf(':')\n    if (fieldSeparatorIndex !== -1) {\n      // Collect the characters on the line before the first U+003A COLON character (:),\n      // and let `field` be that string.\n      const field = line.slice(0, fieldSeparatorIndex)\n\n      // Collect the characters on the line after the first U+003A COLON character (:),\n      // and let `value` be that string. If value starts with a U+0020 SPACE character,\n      // remove it from value.\n      const offset = line[fieldSeparatorIndex + 1] === ' ' ? 2 : 1\n      const value = line.slice(fieldSeparatorIndex + offset)\n\n      processField(field, value, line)\n      return\n    }\n\n    // Otherwise, the string is not empty but does not contain a U+003A COLON character (:)\n    // Process the field using the whole line as the field name, and an empty string as the field value.\n    // 👆 This is according to spec. That means that a line that has the value `data` will result in\n    // a newline being added to the current `data` buffer, for instance.\n    processField(line, '', line)\n  }\n\n  function processField(field: string, value: string, line: string) {\n    // Field names must be compared literally, with no case folding performed.\n    switch (field) {\n      case 'event':\n        // Set the `event type` buffer to field value\n        eventType = value\n        break\n      case 'data':\n        // Append the field value to the `data` buffer, then append a single U+000A LINE FEED(LF)\n        // character to the `data` buffer.\n        data = `${data}${value}\\n`\n        break\n      case 'id':\n        // If the field value does not contain U+0000 NULL, then set the `ID` buffer to\n        // the field value. Otherwise, ignore the field.\n        id = value.includes('\\0') ? undefined : value\n        break\n      case 'retry':\n        // If the field value consists of only ASCII digits, then interpret the field value as an\n        // integer in base ten, and set the event stream's reconnection time to that integer.\n        // Otherwise, ignore the field.\n        if (/^\\d+$/.test(value)) {\n          onRetry(parseInt(value, 10))\n        } else {\n          onError(\n            new ParseError(`Invalid \\`retry\\` value: \"${value}\"`, {\n              type: 'invalid-retry',\n              value,\n              line,\n            }),\n          )\n        }\n        break\n      default:\n        // Otherwise, the field is ignored.\n        onError(\n          new ParseError(\n            `Unknown field \"${field.length > 20 ? `${field.slice(0, 20)}…` : field}\"`,\n            {type: 'unknown-field', field, value, line},\n          ),\n        )\n        break\n    }\n  }\n\n  function dispatchEvent() {\n    const shouldDispatch = data.length > 0\n    if (shouldDispatch) {\n      onEvent({\n        id,\n        event: eventType || undefined,\n        // If the data buffer's last character is a U+000A LINE FEED (LF) character,\n        // then remove the last character from the data buffer.\n        data: data.endsWith('\\n') ? data.slice(0, -1) : data,\n      })\n    }\n\n    // Reset for the next event\n    id = undefined\n    data = ''\n    eventType = ''\n  }\n\n  function reset(options: {consume?: boolean} = {}) {\n    if (incompleteLine && options.consume) {\n      parseLine(incompleteLine)\n    }\n\n    isFirstChunk = true\n    id = undefined\n    data = ''\n    eventType = ''\n    incompleteLine = ''\n  }\n\n  return {feed, reset}\n}\n\n/**\n * For the given `chunk`, split it into lines according to spec, and return any remaining incomplete line.\n *\n * @param chunk - The chunk to split into lines\n * @returns A tuple containing an array of complete lines, and any remaining incomplete line\n * @internal\n */\nfunction splitLines(chunk: string): [complete: Array<string>, incomplete: string] {\n  /**\n   * According to the spec, a line is terminated by either:\n   * - U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pair\n   * - a single U+000A LINE FEED(LF) character not preceded by a U+000D CARRIAGE RETURN(CR) character\n   * - a single U+000D CARRIAGE RETURN(CR) character not followed by a U+000A LINE FEED(LF) character\n   */\n  const lines: Array<string> = []\n  let incompleteLine = ''\n  let searchIndex = 0\n\n  while (searchIndex < chunk.length) {\n    // Find next line terminator\n    const crIndex = chunk.indexOf('\\r', searchIndex)\n    const lfIndex = chunk.indexOf('\\n', searchIndex)\n\n    // Determine line end\n    let lineEnd = -1\n    if (crIndex !== -1 && lfIndex !== -1) {\n      // CRLF case\n      lineEnd = Math.min(crIndex, lfIndex)\n    } else if (crIndex !== -1) {\n      lineEnd = crIndex\n    } else if (lfIndex !== -1) {\n      lineEnd = lfIndex\n    }\n\n    // Extract line if terminator found\n    if (lineEnd === -1) {\n      // No terminator found, rest is incomplete\n      incompleteLine = chunk.slice(searchIndex)\n      break\n    } else {\n      const line = chunk.slice(searchIndex, lineEnd)\n      lines.push(line)\n\n      // Move past line terminator\n      searchIndex = lineEnd + 1\n      if (chunk[searchIndex - 1] === '\\r' && chunk[searchIndex] === '\\n') {\n        searchIndex++\n      }\n    }\n  }\n\n  return [lines, incompleteLine]\n}\n", "/**\n * An extended version of the `Event` emitted by the `EventSource` object when an error occurs.\n * While the spec does not include any additional properties, we intentionally go beyond the spec\n * and provide some (minimal) additional information to aid in debugging.\n *\n * @public\n */\nexport class ErrorEvent extends Event {\n  /**\n   * HTTP status code, if this was triggered by an HTTP error\n   * Note: this is not part of the spec, but is included for better error handling.\n   *\n   * @public\n   */\n  public code?: number | undefined\n\n  /**\n   * Optional message attached to the error.\n   * Note: this is not part of the spec, but is included for better error handling.\n   *\n   * @public\n   */\n  public message?: string | undefined\n\n  /**\n   * Constructs a new `ErrorEvent` instance. This is typically not called directly,\n   * but rather emitted by the `EventSource` object when an error occurs.\n   *\n   * @param type - The type of the event (should be \"error\")\n   * @param errorEventInitDict - Optional properties to include in the error event\n   */\n  constructor(\n    type: string,\n    errorEventInitDict?: {message?: string | undefined; code?: number | undefined},\n  ) {\n    super(type)\n    this.code = errorEventInitDict?.code ?? undefined\n    this.message = errorEventInitDict?.message ?? undefined\n  }\n\n  /**\n   * Node.js \"hides\" the `message` and `code` properties of the `ErrorEvent` instance,\n   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,\n   * we explicitly include the properties in the `inspect` method.\n   *\n   * This is automatically called by Node.js when you `console.log` an instance of this class.\n   *\n   * @param _depth - The current depth\n   * @param options - The options passed to `util.inspect`\n   * @param inspect - The inspect function to use (prevents having to import it from `util`)\n   * @returns A string representation of the error\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](\n    _depth: number,\n    options: {colors: boolean},\n    inspect: (obj: unknown, inspectOptions: {colors: boolean}) => string,\n  ): string {\n    return inspect(inspectableError(this), options)\n  }\n\n  /**\n   * Deno \"hides\" the `message` and `code` properties of the `ErrorEvent` instance,\n   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,\n   * we explicitly include the properties in the `inspect` method.\n   *\n   * This is automatically called by Deno when you `console.log` an instance of this class.\n   *\n   * @param inspect - The inspect function to use (prevents having to import it from `util`)\n   * @param options - The options passed to `Deno.inspect`\n   * @returns A string representation of the error\n   */\n  [Symbol.for('Deno.customInspect')](\n    inspect: (obj: unknown, inspectOptions: {colors: boolean}) => string,\n    options: {colors: boolean},\n  ): string {\n    return inspect(inspectableError(this), options)\n  }\n}\n\n/**\n * For environments where DOMException may not exist, we will use a SyntaxError instead.\n * While this isn't strictly according to spec, it is very close.\n *\n * @param message - The message to include in the error\n * @returns A `DOMException` or `SyntaxError` instance\n * @internal\n */\nexport function syntaxError(message: string): SyntaxError {\n  // If someone can figure out a way to make this work without depending on DOM/Node.js typings,\n  // and without casting to `any`, please send a PR 🙏\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const DomException = (globalThis as any).DOMException\n  if (typeof DomException === 'function') {\n    return new DomException(message, 'SyntaxError')\n  }\n\n  return new SyntaxError(message)\n}\n\n/**\n * Flatten an error into a single error message string.\n * Unwraps nested errors and joins them with a comma.\n *\n * @param err - The error to flatten\n * @returns A string representation of the error\n * @internal\n */\nexport function flattenError(err: unknown): string {\n  if (!(err instanceof Error)) {\n    return `${err}`\n  }\n\n  if ('errors' in err && Array.isArray(err.errors)) {\n    return err.errors.map(flattenError).join(', ')\n  }\n\n  if ('cause' in err && err.cause instanceof Error) {\n    return `${err}: ${flattenError(err.cause)}`\n  }\n\n  return err.message\n}\n\n/**\n * Convert an `ErrorEvent` instance into a plain object for inspection.\n *\n * @param err - The `ErrorEvent` instance to inspect\n * @returns A plain object representation of the error\n * @internal\n */\nfunction inspectableError(err: ErrorEvent) {\n  return {\n    type: err.type,\n    message: err.message,\n    code: err.code,\n    defaultPrevented: err.defaultPrevented,\n    cancelable: err.cancelable,\n    timeStamp: err.timeStamp,\n  }\n}\n", "import {createParser, type EventSourceMessage, type EventSourceParser} from 'eventsource-parser'\n\nimport {ErrorEvent, flattenError, syntaxError} from './errors.js'\nimport type {\n  AddEventListenerOptions,\n  EventListenerOptions,\n  EventListenerOrEventListenerObject,\n  EventSourceEventMap,\n  EventSourceFetchInit,\n  EventSourceInit,\n  FetchLike,\n  FetchLikeResponse,\n} from './types.js'\n\n/**\n * An `EventSource` instance opens a persistent connection to an HTTP server, which sends events\n * in `text/event-stream` format. The connection remains open until closed by calling `.close()`.\n *\n * @public\n * @example\n * ```js\n * const eventSource = new EventSource('https://example.com/stream')\n * eventSource.addEventListener('error', (error) => {\n *   console.error(error)\n * })\n * eventSource.addEventListener('message', (event) => {\n *  console.log('Received message:', event.data)\n * })\n * ```\n */\nexport class EventSource extends EventTarget {\n  /**\n   * ReadyState representing an EventSource currently trying to connect\n   *\n   * @public\n   */\n  static CONNECTING = 0 as const\n\n  /**\n   * ReadyState representing an EventSource connection that is open (eg connected)\n   *\n   * @public\n   */\n  static OPEN = 1 as const\n\n  /**\n   * ReadyState representing an EventSource connection that is closed (eg disconnected)\n   *\n   * @public\n   */\n  static CLOSED = 2 as const\n\n  /**\n   * ReadyState representing an EventSource currently trying to connect\n   *\n   * @public\n   */\n  readonly CONNECTING = 0 as const\n\n  /**\n   * ReadyState representing an EventSource connection that is open (eg connected)\n   *\n   * @public\n   */\n  readonly OPEN = 1 as const\n\n  /**\n   * ReadyState representing an EventSource connection that is closed (eg disconnected)\n   *\n   * @public\n   */\n  readonly CLOSED = 2 as const\n\n  /**\n   * Returns the state of this EventSource object's connection. It can have the values described below.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)\n   *\n   * Note: typed as `number` instead of `0 | 1 | 2` for compatibility with the `EventSource` interface,\n   * defined in the TypeScript `dom` library.\n   *\n   * @public\n   */\n  public get readyState(): number {\n    return this.#readyState\n  }\n\n  /**\n   * Returns the URL providing the event stream.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)\n   *\n   * @public\n   */\n  public get url(): string {\n    return this.#url.href\n  }\n\n  /**\n   * Returns true if the credentials mode for connection requests to the URL providing the event stream is set to \"include\", and false otherwise.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)\n   */\n  public get withCredentials(): boolean {\n    return this.#withCredentials\n  }\n\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */\n  public get onerror(): ((ev: ErrorEvent) => unknown) | null {\n    return this.#onError\n  }\n  public set onerror(value: ((ev: ErrorEvent) => unknown) | null) {\n    this.#onError = value\n  }\n\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */\n  public get onmessage(): ((ev: MessageEvent) => unknown) | null {\n    return this.#onMessage\n  }\n  public set onmessage(value: ((ev: MessageEvent) => unknown) | null) {\n    this.#onMessage = value\n  }\n\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */\n  public get onopen(): ((ev: Event) => unknown) | null {\n    return this.#onOpen\n  }\n  public set onopen(value: ((ev: Event) => unknown) | null) {\n    this.#onOpen = value\n  }\n\n  override addEventListener<K extends keyof EventSourceEventMap>(\n    type: K,\n    listener: (this: EventSource, ev: EventSourceEventMap[K]) => unknown,\n    options?: boolean | AddEventListenerOptions,\n  ): void\n  override addEventListener(\n    type: string,\n    listener: (this: EventSource, event: MessageEvent) => unknown,\n    options?: boolean | AddEventListenerOptions,\n  ): void\n  override addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ): void\n  override addEventListener(\n    type: string,\n    listener:\n      | ((this: EventSource, event: MessageEvent) => unknown)\n      | EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ): void {\n    const listen = listener as (this: EventSource, event: Event) => unknown\n    super.addEventListener(type, listen, options)\n  }\n\n  override removeEventListener<K extends keyof EventSourceEventMap>(\n    type: K,\n    listener: (this: EventSource, ev: EventSourceEventMap[K]) => unknown,\n    options?: boolean | EventListenerOptions,\n  ): void\n  override removeEventListener(\n    type: string,\n    listener: (this: EventSource, event: MessageEvent) => unknown,\n    options?: boolean | EventListenerOptions,\n  ): void\n  override removeEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions,\n  ): void\n  override removeEventListener(\n    type: string,\n    listener:\n      | ((this: EventSource, event: MessageEvent) => unknown)\n      | EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions,\n  ): void {\n    const listen = listener as (this: EventSource, event: Event) => unknown\n    super.removeEventListener(type, listen, options)\n  }\n\n  constructor(url: string | URL, eventSourceInitDict?: EventSourceInit) {\n    super()\n\n    try {\n      if (url instanceof URL) {\n        this.#url = url\n      } else if (typeof url === 'string') {\n        this.#url = new URL(url, getBaseURL())\n      } else {\n        throw new Error('Invalid URL')\n      }\n    } catch (err) {\n      throw syntaxError('An invalid or illegal string was specified')\n    }\n\n    this.#parser = createParser({\n      onEvent: this.#onEvent,\n      onRetry: this.#onRetryChange,\n    })\n\n    this.#readyState = this.CONNECTING\n    this.#reconnectInterval = 3000\n    this.#fetch = eventSourceInitDict?.fetch ?? globalThis.fetch\n    this.#withCredentials = eventSourceInitDict?.withCredentials ?? false\n\n    this.#connect()\n  }\n\n  /**\n   * Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)\n   *\n   * @public\n   */\n  close(): void {\n    if (this.#reconnectTimer) clearTimeout(this.#reconnectTimer)\n    if (this.#readyState === this.CLOSED) return\n    if (this.#controller) this.#controller.abort()\n    this.#readyState = this.CLOSED\n    this.#controller = undefined\n  }\n\n  // PRIVATES FOLLOW\n\n  /**\n   * Current connection state\n   *\n   * @internal\n   */\n  #readyState: number\n\n  /**\n   * Original URL used to connect.\n   *\n   * Note that this will stay the same even after a redirect.\n   *\n   * @internal\n   */\n  #url: URL\n\n  /**\n   * The destination URL after a redirect. Is reset on reconnection.\n   *\n   * @internal\n   */\n  #redirectUrl: URL | undefined\n\n  /**\n   * Whether to include credentials in the request\n   *\n   * @internal\n   */\n  #withCredentials: boolean\n\n  /**\n   * The fetch implementation to use\n   *\n   * @internal\n   */\n  #fetch: FetchLike\n\n  /**\n   * The reconnection time in milliseconds\n   *\n   * @internal\n   */\n  #reconnectInterval: number\n\n  /**\n   * Reference to an ongoing reconnect attempt, if any\n   *\n   * @internal\n   */\n  #reconnectTimer: ReturnType<typeof setTimeout> | undefined\n\n  /**\n   * The last event ID seen by the EventSource, which will be sent as `Last-Event-ID` in the\n   * request headers on a reconnection attempt.\n   *\n   * @internal\n   */\n  #lastEventId: string | null = null\n\n  /**\n   * The AbortController instance used to abort the fetch request\n   *\n   * @internal\n   */\n  #controller: AbortController | undefined\n\n  /**\n   * Instance of an EventSource parser (`eventsource-parser` npm module)\n   *\n   * @internal\n   */\n  #parser: EventSourceParser\n\n  /**\n   * Holds the current error handler, attached through `onerror` property directly.\n   * Note that `addEventListener('error', …)` will not be stored here.\n   *\n   * @internal\n   */\n  #onError: ((ev: ErrorEvent) => unknown) | null = null\n\n  /**\n   * Holds the current message handler, attached through `onmessage` property directly.\n   * Note that `addEventListener('message', …)` will not be stored here.\n   *\n   * @internal\n   */\n  #onMessage: ((ev: MessageEvent) => unknown) | null = null\n\n  /**\n   * Holds the current open handler, attached through `onopen` property directly.\n   * Note that `addEventListener('open', …)` will not be stored here.\n   *\n   * @internal\n   */\n  #onOpen: ((ev: Event) => unknown) | null = null\n\n  /**\n   * Connect to the given URL and start receiving events\n   *\n   * @internal\n   */\n  #connect() {\n    this.#readyState = this.CONNECTING\n    this.#controller = new AbortController()\n\n    // Browser tests are failing if we directly call `this.#fetch()`, thus the indirection.\n    const fetch = this.#fetch\n    fetch(this.#url, this.#getRequestOptions())\n      .then(this.#onFetchResponse)\n      .catch(this.#onFetchError)\n  }\n\n  /**\n   * Handles the fetch response\n   *\n   * @param response - The Fetch(ish) response\n   * @internal\n   */\n  #onFetchResponse = async (response: FetchLikeResponse) => {\n    this.#parser.reset()\n\n    const {body, redirected, status, headers} = response\n\n    // [spec] a client can be told to stop reconnecting using the HTTP 204 No Content response code.\n    if (status === 204) {\n      // We still need to emit an error event - this mirrors the browser behavior,\n      // and without it there is no way to tell the user that the connection was closed.\n      this.#failConnection('Server sent HTTP 204, not reconnecting', 204)\n      this.close()\n      return\n    }\n\n    // [spec] …Event stream requests can be redirected using HTTP 301 and 307 redirects as with\n    // [spec] normal HTTP requests.\n    // Spec does not say anything about other redirect codes (302, 308), but this seems an\n    // unintended omission, rather than a feature. Browsers will happily redirect on other 3xxs's.\n    if (redirected) {\n      this.#redirectUrl = new URL(response.url)\n    } else {\n      this.#redirectUrl = undefined\n    }\n\n    // [spec] if res's status is not 200, …, then fail the connection.\n    if (status !== 200) {\n      this.#failConnection(`Non-200 status code (${status})`, status)\n      return\n    }\n\n    // [spec] …or if res's `Content-Type` is not `text/event-stream`, then fail the connection.\n    const contentType = headers.get('content-type') || ''\n    if (!contentType.startsWith('text/event-stream')) {\n      this.#failConnection('Invalid content type, expected \"text/event-stream\"', status)\n      return\n    }\n\n    // [spec] …if the readyState attribute is set to a value other than CLOSED…\n    if (this.#readyState === this.CLOSED) {\n      return\n    }\n\n    // [spec] …sets the readyState attribute to OPEN and fires an event\n    // [spec] …named open at the EventSource object.\n    this.#readyState = this.OPEN\n\n    const openEvent = new Event('open')\n    this.#onOpen?.(openEvent)\n    this.dispatchEvent(openEvent)\n\n    // Ensure that the response stream is a web stream\n    if (typeof body !== 'object' || !body || !('getReader' in body)) {\n      this.#failConnection('Invalid response body, expected a web ReadableStream', status)\n      this.close() // This should only happen if `fetch` provided is \"faulty\" - don't reconnect\n      return\n    }\n\n    const decoder = new TextDecoder()\n\n    const reader = body.getReader()\n    let open = true\n\n    do {\n      const {done, value} = await reader.read()\n      if (value) {\n        this.#parser.feed(decoder.decode(value, {stream: !done}))\n      }\n\n      if (!done) {\n        continue\n      }\n\n      open = false\n      this.#parser.reset()\n\n      this.#scheduleReconnect()\n    } while (open)\n  }\n\n  /**\n   * Handles rejected requests for the EventSource endpoint\n   *\n   * @param err - The error from `fetch()`\n   * @internal\n   */\n  #onFetchError = (err: Error & {type?: string}) => {\n    this.#controller = undefined\n\n    // We expect abort errors when the user manually calls `close()` - ignore those\n    if (err.name === 'AbortError' || err.type === 'aborted') {\n      return\n    }\n\n    this.#scheduleReconnect(flattenError(err))\n  }\n\n  /**\n   * Get request options for the `fetch()` request\n   *\n   * @returns The request options\n   * @internal\n   */\n  #getRequestOptions(): EventSourceFetchInit {\n    const lastEvent = this.#lastEventId ? {'Last-Event-ID': this.#lastEventId} : undefined\n\n    const init: EventSourceFetchInit = {\n      // [spec] Let `corsAttributeState` be `Anonymous`…\n      // [spec] …will have their mode set to \"cors\"…\n      mode: 'cors',\n      redirect: 'follow',\n      headers: {Accept: 'text/event-stream', ...lastEvent},\n      cache: 'no-store',\n      signal: this.#controller?.signal,\n    }\n\n    // Some environments crash if attempting to set `credentials` where it is not supported,\n    // eg on Cloudflare Workers. To avoid this, we only set it in browser-like environments.\n    if ('window' in globalThis) {\n      // [spec] …and their credentials mode set to \"same-origin\"\n      // [spec] …if the `withCredentials` attribute is `true`, set the credentials mode to \"include\"…\n      init.credentials = this.withCredentials ? 'include' : 'same-origin'\n    }\n\n    return init\n  }\n\n  /**\n   * Called by EventSourceParser instance when an event has successfully been parsed\n   * and is ready to be processed.\n   *\n   * @param event - The parsed event\n   * @internal\n   */\n  #onEvent = (event: EventSourceMessage) => {\n    if (typeof event.id === 'string') {\n      this.#lastEventId = event.id\n    }\n\n    const messageEvent = new MessageEvent(event.event || 'message', {\n      data: event.data,\n      origin: this.#redirectUrl ? this.#redirectUrl.origin : this.#url.origin,\n      lastEventId: event.id || '',\n    })\n\n    // The `onmessage` property of the EventSource instance only triggers on messages without an\n    // `event` field, or ones that explicitly set `message`.\n    if (this.#onMessage && (!event.event || event.event === 'message')) {\n      this.#onMessage(messageEvent)\n    }\n\n    this.dispatchEvent(messageEvent)\n  }\n\n  /**\n   * Called by EventSourceParser instance when a new reconnection interval is received\n   * from the EventSource endpoint.\n   *\n   * @param value - The new reconnection interval in milliseconds\n   * @internal\n   */\n  #onRetryChange = (value: number) => {\n    this.#reconnectInterval = value\n  }\n\n  /**\n   * Handles the process referred to in the EventSource specification as \"failing a connection\".\n   *\n   * @param error - The error causing the connection to fail\n   * @param code - The HTTP status code, if available\n   * @internal\n   */\n  #failConnection(message?: string, code?: number) {\n    // [spec] …if the readyState attribute is set to a value other than CLOSED,\n    // [spec] sets the readyState attribute to CLOSED…\n    if (this.#readyState !== this.CLOSED) {\n      this.#readyState = this.CLOSED\n    }\n\n    // [spec] …and fires an event named `error` at the `EventSource` object.\n    // [spec] Once the user agent has failed the connection, it does not attempt to reconnect.\n    // [spec] > Implementations are especially encouraged to report detailed information\n    // [spec] > to their development consoles whenever an error event is fired, since little\n    // [spec] > to no information can be made available in the events themselves.\n    // Printing to console is not very programatically helpful, though, so we emit a custom event.\n    const errorEvent = new ErrorEvent('error', {code, message})\n\n    this.#onError?.(errorEvent)\n    this.dispatchEvent(errorEvent)\n  }\n\n  /**\n   * Schedules a reconnection attempt against the EventSource endpoint.\n   *\n   * @param message - The error causing the connection to fail\n   * @param code - The HTTP status code, if available\n   * @internal\n   */\n  #scheduleReconnect(message?: string, code?: number) {\n    // [spec] If the readyState attribute is set to CLOSED, abort the task.\n    if (this.#readyState === this.CLOSED) {\n      return\n    }\n\n    // [spec] Set the readyState attribute to CONNECTING.\n    this.#readyState = this.CONNECTING\n\n    // [spec] Fire an event named `error` at the EventSource object.\n    const errorEvent = new ErrorEvent('error', {code, message})\n    this.#onError?.(errorEvent)\n    this.dispatchEvent(errorEvent)\n\n    // [spec] Wait a delay equal to the reconnection time of the event source.\n    this.#reconnectTimer = setTimeout(this.#reconnect, this.#reconnectInterval)\n  }\n\n  /**\n   * Reconnects to the EventSource endpoint after a disconnect/failure\n   *\n   * @internal\n   */\n  #reconnect = () => {\n    this.#reconnectTimer = undefined\n\n    // [spec] If the EventSource's readyState attribute is not set to CONNECTING, then return.\n    if (this.#readyState !== this.CONNECTING) {\n      return\n    }\n\n    this.#connect()\n  }\n}\n\n/**\n * According to spec, when constructing a URL:\n * > 1. Let baseURL be environment's base URL, if environment is a Document object\n * > 2. Return the result of applying the URL parser to url, with baseURL.\n *\n * Thus we should use `document.baseURI` if available, since it can be set through a base tag.\n *\n * @returns The base URL, if available - otherwise `undefined`\n * @internal\n */\nfunction getBaseURL(): string | undefined {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const doc = 'document' in globalThis ? (globalThis as any).document : undefined\n  return doc && typeof doc === 'object' && 'baseURI' in doc && typeof doc.baseURI === 'string'\n    ? doc.baseURI\n    : undefined\n}\n", null, "import z3 from \"./v3/index.js\";\nexport * from \"./v3/index.js\";\nexport default z3;\n", "import * as z from \"./external.js\";\nexport * from \"./external.js\";\nexport { z };\nexport default z;\n", "export * from \"./errors.js\";\nexport * from \"./helpers/parseUtil.js\";\nexport * from \"./helpers/typeAliases.js\";\nexport * from \"./helpers/util.js\";\nexport * from \"./types.js\";\nexport * from \"./ZodError.js\";\n", "import defaultErrorMap from \"./locales/en.js\";\nlet overrideErrorMap = defaultErrorMap;\nexport { defaultErrorMap };\nexport function setErrorMap(map) {\n    overrideErrorMap = map;\n}\nexport function getErrorMap() {\n    return overrideErrorMap;\n}\n", "import { ZodIssueCode } from \"../ZodError.js\";\nimport { util, ZodParsedType } from \"../helpers/util.js\";\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return { message };\n};\nexport default errorMap;\n", "import { util } from \"./helpers/util.js\";\nexport const ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nexport const quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nexport class ZodError extends Error {\n    get errors() {\n        return this.issues;\n    }\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    static assert(value) {\n        if (!(value instanceof ZodError)) {\n            throw new Error(`Not a ZodError: ${value}`);\n        }\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n                fieldErrors[sub.path[0]].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n", "export var util;\n(function (util) {\n    util.assertEqual = (_) => { };\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && Number.isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array.map((val) => (typeof val === \"string\" ? `'${val}'` : val)).join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nexport var objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nexport const ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nexport const getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\n", "import { getErrorMap } from \"../errors.js\";\nimport defaultErrorMap from \"../locales/en.js\";\nexport const makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    if (issueData.message !== undefined) {\n        return {\n            ...issueData,\n            path: fullPath,\n            message: issueData.message,\n        };\n    }\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage,\n    };\n};\nexport const EMPTY_PATH = [];\nexport function addIssueToContext(ctx, issueData) {\n    const overrideMap = getErrorMap();\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap, // contextual error map is first priority\n            ctx.schemaErrorMap, // then schema-bound map if available\n            overrideMap, // then global override map\n            overrideMap === defaultErrorMap ? undefined : defaultErrorMap, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nexport class ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n                key,\n                value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return INVALID;\n            if (value.status === \"aborted\")\n                return INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nexport const INVALID = Object.freeze({\n    status: \"aborted\",\n});\nexport const DIRTY = (value) => ({ status: \"dirty\", value });\nexport const OK = (value) => ({ status: \"valid\", value });\nexport const isAborted = (x) => x.status === \"aborted\";\nexport const isDirty = (x) => x.status === \"dirty\";\nexport const isValid = (x) => x.status === \"valid\";\nexport const isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n", "export {};\n", "import { ZodError, ZodIssueCode, } from \"./ZodError.js\";\nimport { defaultErrorMap, getErrorMap } from \"./errors.js\";\nimport { errorUtil } from \"./helpers/errorUtil.js\";\nimport { DIRTY, INVALID, OK, ParseStatus, addIssueToContext, isAborted, isAsync, isDirty, isValid, makeIssue, } from \"./helpers/parseUtil.js\";\nimport { util, ZodParsedType, getParsedType } from \"./helpers/util.js\";\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (Array.isArray(this._key)) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if (isValid(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        const { message } = params;\n        if (iss.code === \"invalid_enum_value\") {\n            return { message: message ?? ctx.defaultError };\n        }\n        if (typeof ctx.data === \"undefined\") {\n            return { message: message ?? required_error ?? ctx.defaultError };\n        }\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        return { message: message ?? invalid_type_error ?? ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nexport class ZodType {\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: params?.async ?? false,\n                contextualErrorMap: params?.errorMap,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    \"~validate\"(data) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: !!this[\"~standard\"].async,\n            },\n            path: [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        if (!this[\"~standard\"].async) {\n            try {\n                const result = this._parseSync({ data, path: [], parent: ctx });\n                return isValid(result)\n                    ? {\n                        value: result.value,\n                    }\n                    : {\n                        issues: ctx.common.issues,\n                    };\n            }\n            catch (err) {\n                if (err?.message?.toLowerCase()?.includes(\"encountered\")) {\n                    this[\"~standard\"].async = true;\n                }\n                ctx.common = {\n                    issues: [],\n                    async: true,\n                };\n            }\n        }\n        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result)\n            ? {\n                value: result.value,\n            }\n            : {\n                issues: ctx.common.issues,\n            });\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params?.errorMap,\n                async: true,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n        this[\"~standard\"] = {\n            version: 1,\n            vendor: \"zod\",\n            validate: (data) => this[\"~validate\"](data),\n        };\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[0-9a-z]+$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\nconst jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nconst durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&\u2019*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\n// faster, simpler, safer\nconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nconst ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\n// const ipv6Regex =\n// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nconst ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nconst ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n// https://base64.guru/standards/base64url\nconst base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\n// simple\n// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\n// no leap year validation\n// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\n// with leap year validation\nconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n    let secondsRegexSource = `[0-5]\\\\d`;\n    if (args.precision) {\n        secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n    }\n    else if (args.precision == null) {\n        secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n    }\n    const secondsQuantifier = args.precision ? \"+\" : \"?\"; // require seconds if precision is nonzero\n    return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n    return new RegExp(`^${timeRegexSource(args)}$`);\n}\n// Adapted from https://stackoverflow.com/a/3143231\nexport function datetimeRegex(args) {\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n    const opts = [];\n    opts.push(args.local ? `Z?` : `Z`);\n    if (args.offset)\n        opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n    regex = `${regex}(${opts.join(\"|\")})`;\n    return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nfunction isValidJWT(jwt, alg) {\n    if (!jwtRegex.test(jwt))\n        return false;\n    try {\n        const [header] = jwt.split(\".\");\n        // Convert base64url to base64\n        const base64 = header\n            .replace(/-/g, \"+\")\n            .replace(/_/g, \"/\")\n            .padEnd(header.length + ((4 - (header.length % 4)) % 4), \"=\");\n        const decoded = JSON.parse(atob(base64));\n        if (typeof decoded !== \"object\" || decoded === null)\n            return false;\n        if (\"typ\" in decoded && decoded?.typ !== \"JWT\")\n            return false;\n        if (!decoded.alg)\n            return false;\n        if (alg && decoded.alg !== alg)\n            return false;\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nfunction isValidCidr(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nexport class ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"nanoid\") {\n                if (!nanoidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"nanoid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                }\n                catch {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"date\") {\n                const regex = dateRegex;\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"date\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"time\") {\n                const regex = timeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"time\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"duration\") {\n                if (!durationRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"duration\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"jwt\") {\n                if (!isValidJWT(input.data, check.alg)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"jwt\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cidr\") {\n                if (!isValidCidr(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cidr\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64\") {\n                if (!base64Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64url\") {\n                if (!base64urlRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n    }\n    nanoid(message) {\n        return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n    }\n    base64(message) {\n        return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\n    }\n    base64url(message) {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return this._addCheck({\n            kind: \"base64url\",\n            ...errorUtil.errToObj(message),\n        });\n    }\n    jwt(options) {\n        return this._addCheck({ kind: \"jwt\", ...errorUtil.errToObj(options) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n    }\n    cidr(options) {\n        return this._addCheck({ kind: \"cidr\", ...errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                local: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            offset: options?.offset ?? false,\n            local: options?.local ?? false,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    date(message) {\n        return this._addCheck({ kind: \"date\", message });\n    }\n    time(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"time\",\n                precision: null,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"time\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    duration(message) {\n        return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options?.position,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    /**\n     * Equivalent to `.min(1)`\n     */\n    nonempty(message) {\n        return this.min(1, errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isDate() {\n        return !!this._def.checks.find((ch) => ch.kind === \"date\");\n    }\n    get isTime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"time\");\n    }\n    get isDuration() {\n        return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isNANOID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get isCIDR() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\n    }\n    get isBase64() {\n        return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n    }\n    get isBase64url() {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params) => {\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / 10 ** decCount;\n}\nexport class ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" || (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null;\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            try {\n                input.data = BigInt(input.data);\n            }\n            catch {\n                return this._getInvalidInput(input);\n            }\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            return this._getInvalidInput(input);\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _getInvalidInput(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.bigint,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params) => {\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (Number.isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: params?.coerce || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nexport class ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        this._cached = { shape, keys };\n        return this._cached;\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") {\n            }\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    syncPairs.push({\n                        key,\n                        value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: errorUtil.errToObj(message).message ?? defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(mask)) {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return util.objectValues(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else if (type instanceof ZodOptional) {\n        return [undefined, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodNullable) {\n        return [null, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodBranded) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodReadonly) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodCatch) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else {\n        return [];\n    }\n};\nexport class ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues.length) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nexport class ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types,\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\n// type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];\nexport class ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nexport class ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(async function (...args) {\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(function (...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args ? args : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nexport class ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nexport class ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(this._def.values);\n        }\n        if (!this._cache.has(input.data)) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values, newDef = this._def) {\n        return ZodEnum.create(values, {\n            ...this._def,\n            ...newDef,\n        });\n    }\n    exclude(values, newDef = this._def) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n            ...this._def,\n            ...newDef,\n        });\n    }\n}\nZodEnum.create = createZodEnum;\nexport class ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(util.getValidEnumValues(this._def.values));\n        }\n        if (!this._cache.has(input.data)) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n        return OK(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg) => {\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then(async (processed) => {\n                    if (status.value === \"aborted\")\n                        return INVALID;\n                    const result = await this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                    if (result.status === \"aborted\")\n                        return INVALID;\n                    if (result.status === \"dirty\")\n                        return DIRTY(result.value);\n                    if (status.value === \"dirty\")\n                        return DIRTY(result.value);\n                    return result;\n                });\n            }\n            else {\n                if (status.value === \"aborted\")\n                    return INVALID;\n                const result = this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (result.status === \"aborted\")\n                    return INVALID;\n                if (result.status === \"dirty\")\n                    return DIRTY(result.value);\n                if (status.value === \"dirty\")\n                    return DIRTY(result.value);\n                return result;\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!isValid(base))\n                    return INVALID;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n                    if (!isValid(base))\n                        return INVALID;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n                        status: status.value,\n                        value: result,\n                    }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nexport { ZodEffects as ZodTransformer };\nexport class ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\" ? params.default : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if (isAsync(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nexport const BRAND = Symbol(\"zod_brand\");\nexport class ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nexport class ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nexport class ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        const freeze = (data) => {\n            if (isValid(data)) {\n                data.value = Object.freeze(data.value);\n            }\n            return data;\n        };\n        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodReadonly.create = (type, params) => {\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params),\n    });\n};\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      z.custom      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nfunction cleanParams(params, data) {\n    const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\n    const p2 = typeof p === \"string\" ? { message: p } : p;\n    return p2;\n}\nexport function custom(check, _params = {}, \n/**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            const r = check(data);\n            if (r instanceof Promise) {\n                return r.then((r) => {\n                    if (!r) {\n                        const params = cleanParams(_params, data);\n                        const _fatal = params.fatal ?? fatal ?? true;\n                        ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n                    }\n                });\n            }\n            if (!r) {\n                const params = cleanParams(_params, data);\n                const _fatal = params.fatal ?? fatal ?? true;\n                ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n            }\n            return;\n        });\n    return ZodAny.create();\n}\nexport { ZodType as Schema, ZodType as ZodSchema };\nexport const late = {\n    object: ZodObject.lazycreate,\n};\nexport var ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\n// requires TS 4.4+\nclass Class {\n    constructor(..._) { }\n}\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\nexport const coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nexport { anyType as any, arrayType as array, bigIntType as bigint, booleanType as boolean, dateType as date, discriminatedUnionType as discriminatedUnion, effectsType as effect, enumType as enum, functionType as function, instanceOfType as instanceof, intersectionType as intersection, lazyType as lazy, literalType as literal, mapType as map, nanType as nan, nativeEnumType as nativeEnum, neverType as never, nullType as null, nullableType as nullable, numberType as number, objectType as object, oboolean, onumber, optionalType as optional, ostring, pipelineType as pipeline, preprocessType as preprocess, promiseType as promise, recordType as record, setType as set, strictObjectType as strictObject, stringType as string, symbolType as symbol, effectsType as transformer, tupleType as tuple, undefinedType as undefined, unionType as union, unknownType as unknown, voidType as void, };\nexport const NEVER = INVALID;\n", "export var errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    // biome-ignore lint:\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message?.message;\n})(errorUtil || (errorUtil = {}));\n", null, "let crypto;\ncrypto = globalThis.crypto; // web browsers\n/**\n * Creates an array of length `size` of random bytes\n * @param size\n * @returns Array of random ints (0 to 255)\n */\nasync function getRandomValues(size) {\n    return (await crypto).getRandomValues(new Uint8Array(size));\n}\n/** Generate cryptographically strong random string\n * @param size The desired length of the string\n * @returns The random string\n */\nasync function random(size) {\n    const mask = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~\";\n    let result = \"\";\n    const randomUints = await getRandomValues(size);\n    for (let i = 0; i < size; i++) {\n        // cap the value of the randomIndex to mask.length - 1\n        const randomIndex = randomUints[i] % mask.length;\n        result += mask[randomIndex];\n    }\n    return result;\n}\n/** Generate a PKCE challenge verifier\n * @param length Length of the verifier\n * @returns A random verifier `length` characters long\n */\nasync function generateVerifier(length) {\n    return await random(length);\n}\n/** Generate a PKCE code challenge from a code verifier\n * @param code_verifier\n * @returns The base64 url encoded code challenge\n */\nexport async function generateChallenge(code_verifier) {\n    const buffer = await (await crypto).subtle.digest(\"SHA-256\", new TextEncoder().encode(code_verifier));\n    // Generate base64url string\n    // btoa is deprecated in Node.js but is used here for web browser compatibility\n    // (which has no good replacement yet, see also https://github.com/whatwg/html/issues/6811)\n    return btoa(String.fromCharCode(...new Uint8Array(buffer)))\n        .replace(/\\//g, '_')\n        .replace(/\\+/g, '-')\n        .replace(/=/g, '');\n}\n/** Generate a PKCE challenge pair\n * @param length Length of the verifer (between 43-128). Defaults to 43.\n * @returns PKCE challenge pair\n */\nexport default async function pkceChallenge(length) {\n    if (!length)\n        length = 43;\n    if (length < 43 || length > 128) {\n        throw `Expected a length between 43 and 128. Received ${length}.`;\n    }\n    const verifier = await generateVerifier(length);\n    const challenge = await generateChallenge(verifier);\n    return {\n        code_verifier: verifier,\n        code_challenge: challenge,\n    };\n}\n/** Verify that a code_verifier produces the expected code challenge\n * @param code_verifier\n * @param expectedChallenge The code challenge to verify\n * @returns True if challenges are equal. False otherwise.\n */\nexport async function verifyChallenge(code_verifier, expectedChallenge) {\n    const actualChallenge = await generateChallenge(code_verifier);\n    return actualChallenge === expectedChallenge;\n}\n", null, null, null, "/**\n * Symbol used for identifying AI SDK Error instances.\n * Enables checking if an error is an instance of AISDKError across package versions.\n */\nconst marker = 'vercel.ai.error';\nconst symbol = Symbol.for(marker);\n\n/**\n * Custom error class for AI SDK related errors.\n * @extends Error\n */\nexport class AISDKError extends Error {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n   * The underlying cause of the error, if any.\n   */\n  readonly cause?: unknown;\n\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name,\n    message,\n    cause,\n  }: {\n    name: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super(message);\n\n    this.name = name;\n    this.cause = cause;\n  }\n\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error: unknown): error is AISDKError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  protected static hasMarker(error: unknown, marker: string): boolean {\n    const markerSymbol = Symbol.for(marker);\n    return (\n      error != null &&\n      typeof error === 'object' &&\n      markerSymbol in error &&\n      typeof error[markerSymbol] === 'boolean' &&\n      error[markerSymbol] === true\n    );\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_APICallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class APICallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly url: string;\n  readonly requestBodyValues: unknown;\n  readonly statusCode?: number;\n\n  readonly responseHeaders?: Record<string, string>;\n  readonly responseBody?: string;\n\n  readonly isRetryable: boolean;\n  readonly data?: unknown;\n\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null &&\n      (statusCode === 408 || // request timeout\n        statusCode === 409 || // conflict\n        statusCode === 429 || // too many requests\n        statusCode >= 500), // server error\n    data,\n  }: {\n    message: string;\n    url: string;\n    requestBodyValues: unknown;\n    statusCode?: number;\n    responseHeaders?: Record<string, string>;\n    responseBody?: string;\n    cause?: unknown;\n    isRetryable?: boolean;\n    data?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is APICallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_EmptyResponseBodyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class EmptyResponseBodyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message = 'Empty response body' }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is EmptyResponseBodyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidArgumentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A function argument is invalid.\n */\nexport class InvalidArgumentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly argument: string;\n\n  constructor({\n    message,\n    cause,\n    argument,\n  }: {\n    argument: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.argument = argument;\n  }\n\n  static isInstance(error: unknown): error is InvalidArgumentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidPromptError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A prompt is invalid. This error should be thrown by providers when they cannot\n * process a prompt.\n */\nexport class InvalidPromptError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly prompt: unknown;\n\n  constructor({\n    prompt,\n    message,\n    cause,\n  }: {\n    prompt: unknown;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message: `Invalid prompt: ${message}`, cause });\n\n    this.prompt = prompt;\n  }\n\n  static isInstance(error: unknown): error is InvalidPromptError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidResponseDataError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * Server returned a response with invalid data content.\n * This should be thrown by providers when they cannot parse the response from the API.\n */\nexport class InvalidResponseDataError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly data: unknown;\n\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`,\n  }: {\n    data: unknown;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is InvalidResponseDataError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_JSONParseError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n// TODO v5: rename to ParseError\nexport class JSONParseError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly text: string;\n\n  constructor({ text, cause }: { text: string; cause: unknown }) {\n    super({\n      name,\n      message:\n        `JSON parsing failed: ` +\n        `Text: ${text}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.text = text;\n  }\n\n  static isInstance(error: unknown): error is JSONParseError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadAPIKeyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadAPIKeyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadAPIKeyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadSettingError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadSettingError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadSettingError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoContentGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when the AI provider fails to generate any content.\n */\nexport class NoContentGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({\n    message = 'No content generated.',\n  }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is NoContentGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoSuchModelError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchModelError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly modelId: string;\n  readonly modelType: 'languageModel' | 'textEmbeddingModel' | 'imageModel';\n\n  constructor({\n    errorName = name,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`,\n  }: {\n    errorName?: string;\n    modelId: string;\n    modelType: 'languageModel' | 'textEmbeddingModel' | 'imageModel';\n    message?: string;\n  }) {\n    super({ name: errorName, message });\n\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n\n  static isInstance(error: unknown): error is NoSuchModelError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_TooManyEmbeddingValuesForCallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TooManyEmbeddingValuesForCallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly provider: string;\n  readonly modelId: string;\n  readonly maxEmbeddingsPerCall: number;\n  readonly values: Array<unknown>;\n\n  constructor(options: {\n    provider: string;\n    modelId: string;\n    maxEmbeddingsPerCall: number;\n    values: Array<unknown>;\n  }) {\n    super({\n      name,\n      message:\n        `Too many values for a single embedding call. ` +\n        `The ${options.provider} model \"${options.modelId}\" can only embed up to ` +\n        `${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`,\n    });\n\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n\n  static isInstance(\n    error: unknown,\n  ): error is TooManyEmbeddingValuesForCallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_TypeValidationError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TypeValidationError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly value: unknown;\n\n  constructor({ value, cause }: { value: unknown; cause: unknown }) {\n    super({\n      name,\n      message:\n        `Type validation failed: ` +\n        `Value: ${JSON.stringify(value)}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is TypeValidationError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause,\n  }: {\n    value: unknown;\n    cause: unknown;\n  }): TypeValidationError {\n    return TypeValidationError.isInstance(cause) && cause.value === value\n      ? cause\n      : new TypeValidationError({ value, cause });\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_UnsupportedFunctionalityError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class UnsupportedFunctionalityError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly functionality: string;\n\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`,\n  }: {\n    functionality: string;\n    message?: string;\n  }) {\n    super({ name, message });\n    this.functionality = functionality;\n  }\n\n  static isInstance(error: unknown): error is UnsupportedFunctionalityError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { JSONArray, JSONObject, JSONValue } from './json-value';\n\nexport function isJSONValue(value: unknown): value is JSONValue {\n  if (\n    value === null ||\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean'\n  ) {\n    return true;\n  }\n\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n\n  if (typeof value === 'object') {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === 'string' && isJSONValue(val),\n    );\n  }\n\n  return false;\n}\n\nexport function isJSONArray(value: unknown): value is JSONArray {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\n\nexport function isJSONObject(value: unknown): value is JSONObject {\n  return (\n    value != null &&\n    typeof value === 'object' &&\n    Object.entries(value).every(\n      ([key, val]) => typeof key === 'string' && isJSONValue(val),\n    )\n  );\n}\n", "let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size | 0\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size | 0\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\nexport { nanoid, customAlphabet }\n", "export function combineHeaders(\n  ...headers: Array<Record<string, string | undefined> | undefined>\n): Record<string, string | undefined> {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...(currentHeaders ?? {}),\n    }),\n    {},\n  ) as Record<string, string | undefined>;\n}\n", "/**\n * Converts an AsyncIterator to a ReadableStream.\n *\n * @template T - The type of elements produced by the AsyncIterator.\n * @param { <T>} iterator - The AsyncIterator to convert.\n * @returns {ReadableStream<T>} - A ReadableStream that provides the same data as the AsyncIterator.\n */\nexport function convertAsyncIteratorToReadableStream<T>(\n  iterator: AsyncIterator<T>,\n): ReadableStream<T> {\n  return new ReadableStream<T>({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {},\n  });\n}\n", "/**\n * Creates a Promise that resolves after a specified delay\n * @param delayInMs - The delay duration in milliseconds. If null or undefined, resolves immediately.\n * @returns A Promise that resolves after the specified delay\n */\nexport async function delay(delayInMs?: number | null): Promise<void> {\n  return delayInMs == null\n    ? Promise.resolve()\n    : new Promise(resolve => setTimeout(resolve, delayInMs));\n}\n", "export type EventSourceChunk = {\n  event: string | undefined;\n  data: string;\n  id?: string;\n  retry?: number;\n};\n\nexport function createEventSourceParserStream() {\n  let buffer = '';\n  let event: string | undefined = undefined;\n  let data: string[] = [];\n  let lastEventId: string | undefined = undefined;\n  let retry: number | undefined = undefined;\n\n  function parseLine(\n    line: string,\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    // Empty line means dispatch the event\n    if (line === '') {\n      dispatchEvent(controller);\n      return;\n    }\n\n    // Comments start with colon\n    if (line.startsWith(':')) {\n      return;\n    }\n\n    // Field parsing\n    const colonIndex = line.indexOf(':');\n    if (colonIndex === -1) {\n      // field with no value\n      handleField(line, '');\n      return;\n    }\n\n    const field = line.slice(0, colonIndex);\n    // If there's a space after the colon, it should be ignored\n    const valueStart = colonIndex + 1;\n    const value =\n      valueStart < line.length && line[valueStart] === ' '\n        ? line.slice(valueStart + 1)\n        : line.slice(valueStart);\n\n    handleField(field, value);\n  }\n\n  function dispatchEvent(\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    if (data.length > 0) {\n      controller.enqueue({\n        event,\n        data: data.join('\\n'),\n        id: lastEventId,\n        retry,\n      });\n\n      // Reset data but keep lastEventId as per spec\n      data = [];\n      event = undefined;\n      retry = undefined;\n    }\n  }\n\n  function handleField(field: string, value: string) {\n    switch (field) {\n      case 'event':\n        event = value;\n        break;\n      case 'data':\n        data.push(value);\n        break;\n      case 'id':\n        lastEventId = value;\n        break;\n      case 'retry':\n        const parsedRetry = parseInt(value, 10);\n        if (!isNaN(parsedRetry)) {\n          retry = parsedRetry;\n        }\n        break;\n    }\n  }\n\n  return new TransformStream<string, EventSourceChunk>({\n    transform(chunk, controller) {\n      const { lines, incompleteLine } = splitLines(buffer, chunk);\n\n      buffer = incompleteLine;\n\n      // using for loop for performance\n      for (let i = 0; i < lines.length; i++) {\n        parseLine(lines[i], controller);\n      }\n    },\n\n    flush(controller) {\n      parseLine(buffer, controller);\n      dispatchEvent(controller);\n    },\n  });\n}\n\n// performance: send in already scanned buffer separately, do not scan again\nfunction splitLines(buffer: string, chunk: string) {\n  const lines: Array<string> = [];\n  let currentLine = buffer;\n\n  // using for loop for performance\n  for (let i = 0; i < chunk.length; ) {\n    const char = chunk[i++];\n\n    // order is performance-optimized\n    if (char === '\\n') {\n      // Standalone LF\n      lines.push(currentLine);\n      currentLine = '';\n    } else if (char === '\\r') {\n      lines.push(currentLine);\n      currentLine = '';\n      if (chunk[i] === '\\n') {\n        i++; // CRLF case: Skip the LF character\n      }\n    } else {\n      currentLine += char;\n    }\n  }\n\n  return { lines, incompleteLine: currentLine };\n}\n", "/**\nExtracts the headers from a response object and returns them as a key-value object.\n\n@param response - The response object to extract headers from.\n@returns The headers as a key-value object.\n*/\nexport function extractResponseHeaders(\n  response: Response,\n): Record<string, string> {\n  const headers: Record<string, string> = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n", "import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { customAlphabet } from 'nanoid/non-secure';\n\n/**\nCreates an ID generator.\nThe total length of the ID is the sum of the prefix, separator, and random part length.\nNon-secure.\n\n@param alphabet - The alphabet to use for the ID. Default: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.\n@param prefix - The prefix of the ID to generate. Default: ''.\n@param separator - The separator between the prefix and the random part of the ID. Default: '-'.\n@param size - The size of the random part of the ID to generate. Default: 16.\n */\n// TODO 5.0 breaking change: change the return type to IDGenerator\nexport const createIdGenerator = ({\n  prefix,\n  size: defaultSize = 16,\n  alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  separator = '-',\n}: {\n  prefix?: string;\n  separator?: string;\n  size?: number;\n  alphabet?: string;\n} = {}): ((size?: number) => string) => {\n  const generator = customAlphabet(alphabet, defaultSize);\n\n  if (prefix == null) {\n    return generator;\n  }\n\n  // check that the prefix is not part of the alphabet (otherwise prefix checking can fail randomly)\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: 'separator',\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`,\n    });\n  }\n\n  return size => `${prefix}${separator}${generator(size)}`;\n};\n\n/**\nA function that generates an ID.\n */\nexport type IDGenerator = () => string;\n\n/**\nGenerates a 16-character random string to use for IDs. Not secure.\n\n@param size - The size of the ID to generate. Default: 16.\n */\nexport const generateId = createIdGenerator();\n", "export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n", "import { APICallError } from '@ai-sdk/provider';\nimport { FetchFunction } from './fetch-function';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\nimport { isAbortError } from './is-abort-error';\nimport { extractResponseHeaders } from './extract-response-headers';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const getFromApi = async <T>({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: removeUndefinedEntries(headers),\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {},\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {},\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {},\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {},\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n      if (cause != null) {\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          isRetryable: true,\n          requestBodyValues: {},\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n", "/**\n * Removes entries from a record where the value is null or undefined.\n * @param record - The input object whose entries may be null or undefined.\n * @returns A new object containing only entries with non-null and non-undefined values.\n */\nexport function removeUndefinedEntries<T>(\n  record: Record<string, T | undefined>,\n): Record<string, T> {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null),\n  ) as Record<string, T>;\n}\n", "export function isAbortError(error: unknown): error is Error {\n  return (\n    error instanceof Error &&\n    (error.name === 'AbortError' || error.name === 'TimeoutError')\n  );\n}\n", "import { LoadAPIKeyError } from '@ai-sdk/provider';\n\nexport function loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = 'apiKey',\n  description,\n}: {\n  apiKey: string | undefined;\n  environmentVariableName: string;\n  apiKeyParameterName?: string;\n  description: string;\n}): string {\n  if (typeof apiKey === 'string') {\n    return apiKey;\n  }\n\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`,\n    });\n  }\n\n  apiKey = process.env[environmentVariableName];\n\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof apiKey !== 'string') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return apiKey;\n}\n", "/**\n * Loads an optional `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @returns The setting value.\n */\nexport function loadOptionalSetting({\n  settingValue,\n  environmentVariableName,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n}): string | undefined {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null || typeof process === 'undefined') {\n    return undefined;\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null || typeof settingValue !== 'string') {\n    return undefined;\n  }\n\n  return settingValue;\n}\n", "import { LoadSettingError } from '@ai-sdk/provider';\n\n/**\n * Loads a `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @param settingName - The setting name.\n * @param description - The description of the setting.\n * @returns The setting value.\n */\nexport function loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n  settingName: string;\n  description: string;\n}): string {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null) {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter. ` +\n        `Environment variables is not supported in this environment.`,\n    });\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null) {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter ` +\n        `or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof settingValue !== 'string') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting must be a string. ` +\n        `The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return settingValue;\n}\n", "import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport SecureJSON from 'secure-json-parse';\nimport { ZodSchema } from 'zod';\nimport { safeValidateTypes, validateTypes } from './validate-types';\nimport { Validator } from './validator';\n\n/**\n * Parses a JSON string into an unknown object.\n *\n * @param text - The JSON string to parse.\n * @returns {JSONValue} - The parsed JSON object.\n */\nexport function parseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): JSONValue;\n/**\n * Parses a JSON string into a strongly-typed object using the provided schema.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns {T} - The parsed object.\n */\nexport function parseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): T;\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): T {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return value;\n    }\n\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (\n      JSONParseError.isInstance(error) ||\n      TypeValidationError.isInstance(error)\n    ) {\n      throw error;\n    }\n\n    throw new JSONParseError({ text, cause: error });\n  }\n}\n\nexport type ParseResult<T> =\n  | { success: true; value: T; rawValue: unknown }\n  | { success: false; error: JSONParseError | TypeValidationError };\n\n/**\n * Safely parses a JSON string and returns the result as an object of type `unknown`.\n *\n * @param text - The JSON string to parse.\n * @returns {object} Either an object with `success: true` and the parsed data, or an object with `success: false` and the error that occurred.\n */\nexport function safeParseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): ParseResult<JSONValue>;\n/**\n * Safely parses a JSON string into a strongly-typed object, using a provided schema to validate the object.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeParseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): ParseResult<T>;\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): ParseResult<T> {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return { success: true, value: value as T, rawValue: value };\n    }\n\n    const validationResult = safeValidateTypes({ value, schema });\n\n    return validationResult.success\n      ? { ...validationResult, rawValue: value }\n      : validationResult;\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error)\n        ? error\n        : new JSONParseError({ text, cause: error }),\n    };\n  }\n}\n\nexport function isParsableJson(input: string): boolean {\n  try {\n    SecureJSON.parse(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n", "import { TypeValidationError } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { Validator, asValidator } from './validator';\n\n/**\n * Validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns {T} - The typed object.\n */\nexport function validateTypes<T>({\n  value,\n  schema: inputSchema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}): T {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n\n  return result.value;\n}\n\n/**\n * Safely validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The JSON object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeValidateTypes<T>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: TypeValidationError } {\n  const validator = asValidator(schema);\n\n  try {\n    if (validator.validate == null) {\n      return { success: true, value: value as T };\n    }\n\n    const result = validator.validate(value);\n\n    if (result.success) {\n      return result;\n    }\n\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error }),\n    };\n  }\n}\n", "import { z } from 'zod';\n\n/**\n * Used to mark validator functions so we can support both Zod and custom schemas.\n */\nexport const validatorSymbol = Symbol.for('vercel.ai.validator');\n\nexport type ValidationResult<OBJECT> =\n  | { success: true; value: OBJECT }\n  | { success: false; error: Error };\n\nexport type Validator<OBJECT = unknown> = {\n  /**\n   * Used to mark validator functions so we can support both Zod and custom schemas.\n   */\n  [validatorSymbol]: true;\n\n  /**\n   * Optional. Validates that the structure of a value matches this schema,\n   * and returns a typed version of the value if it does.\n   */\n  readonly validate?: (value: unknown) => ValidationResult<OBJECT>;\n};\n\n/**\n * Create a validator.\n *\n * @param validate A validation function for the schema.\n */\nexport function validator<OBJECT>(\n  validate?: undefined | ((value: unknown) => ValidationResult<OBJECT>),\n): Validator<OBJECT> {\n  return { [validatorSymbol]: true, validate };\n}\n\nexport function isValidator(value: unknown): value is Validator {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    validatorSymbol in value &&\n    value[validatorSymbol] === true &&\n    'validate' in value\n  );\n}\n\nexport function asValidator<OBJECT>(\n  value: Validator<OBJECT> | z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return isValidator(value) ? value : zodValidator(value);\n}\n\nexport function zodValidator<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return validator(value => {\n    const result = zodSchema.safeParse(value);\n    return result.success\n      ? { success: true, value: result.data }\n      : { success: false, error: result.error };\n  });\n}\n", "import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { safeValidateTypes } from './validate-types';\nimport { z } from 'zod';\n\nexport function parseProviderOptions<T>({\n  provider,\n  providerOptions,\n  schema,\n}: {\n  provider: string;\n  providerOptions: Record<string, unknown> | undefined;\n  schema: z.ZodSchema<T>;\n}): T | undefined {\n  if (providerOptions?.[provider] == null) {\n    return undefined;\n  }\n\n  const parsedProviderOptions = safeValidateTypes({\n    value: providerOptions[provider],\n    schema,\n  });\n\n  if (!parsedProviderOptions.success) {\n    throw new InvalidArgumentError({\n      argument: 'providerOptions',\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error,\n    });\n  }\n\n  return parsedProviderOptions.value;\n}\n", "import { APICallError } from '@ai-sdk/provider';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { FetchFunction } from './fetch-function';\nimport { isAbortError } from './is-abort-error';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const postJsonToApi = async <T>({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: unknown;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n    body: {\n      content: JSON.stringify(body),\n      values: body,\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postFormDataToApi = async <T>({\n  url,\n  headers,\n  formData,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  formData: FormData;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers,\n    body: {\n      content: formData,\n      values: Object.fromEntries((formData as any).entries()),\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postToApi = async <T>({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: {\n    content: string | FormData | Uint8Array;\n    values: unknown;\n  };\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values,\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values,\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values,\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values,\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    // unwrap original error when fetch failed (for easier debugging):\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n\n      if (cause != null) {\n        // Failed to connect to server:\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true, // retry when network error\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n", "export type Resolvable<T> =\n  | T // Raw value\n  | Promise<T> // Promise of value\n  | (() => T) // Function returning value\n  | (() => Promise<T>); // Function returning promise of value\n\n/**\n * Resolves a value that could be a raw value, a Promise, a function returning a value,\n * or a function returning a Promise.\n */\nexport async function resolve<T>(value: Resolvable<T>): Promise<T> {\n  // If it's a function, call it to get the value/promise\n  if (typeof value === 'function') {\n    value = (value as Function)();\n  }\n\n  // Otherwise just resolve whatever we got (value or promise)\n  return Promise.resolve(value as T);\n}\n", "import { APICallError, EmptyResponseBodyError } from '@ai-sdk/provider';\nimport { ZodSchema } from 'zod';\nimport {\n  createEventSourceParserStream,\n  EventSourceChunk,\n} from './event-source-parser-stream';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { parseJSON, ParseResult, safeParseJSON } from './parse-json';\n\nexport type ResponseHandler<RETURN_TYPE> = (options: {\n  url: string;\n  requestBodyValues: unknown;\n  response: Response;\n}) => PromiseLike<{\n  value: RETURN_TYPE;\n  rawValue?: unknown;\n  responseHeaders?: Record<string, string>;\n}>;\n\nexport const createJsonErrorResponseHandler =\n  <T>({\n    errorSchema,\n    errorToMessage,\n    isRetryable,\n  }: {\n    errorSchema: ZodSchema<T>;\n    errorToMessage: (error: T) => string;\n    isRetryable?: (response: Response, error?: T) => boolean;\n  }): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n    const responseHeaders = extractResponseHeaders(response);\n\n    // Some providers return an empty response body for some errors:\n    if (responseBody.trim() === '') {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n\n    // resilient parsing in case the response is not JSON or does not match the schema:\n    try {\n      const parsedError = parseJSON({\n        text: responseBody,\n        schema: errorSchema,\n      });\n\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: errorToMessage(parsedError),\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          data: parsedError,\n          isRetryable: isRetryable?.(response, parsedError),\n        }),\n      };\n    } catch (parseError) {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n  };\n\nexport const createEventSourceResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    return {\n      responseHeaders,\n      value: response.body\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(createEventSourceParserStream())\n        .pipeThrough(\n          new TransformStream<EventSourceChunk, ParseResult<T>>({\n            transform({ data }, controller) {\n              // ignore the 'DONE' event that e.g. OpenAI sends:\n              if (data === '[DONE]') {\n                return;\n              }\n\n              controller.enqueue(\n                safeParseJSON({\n                  text: data,\n                  schema: chunkSchema,\n                }),\n              );\n            },\n          }),\n        ),\n    };\n  };\n\nexport const createJsonStreamResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    let buffer = '';\n\n    return {\n      responseHeaders,\n      value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n        new TransformStream<string, ParseResult<T>>({\n          transform(chunkText, controller) {\n            if (chunkText.endsWith('\\n')) {\n              controller.enqueue(\n                safeParseJSON({\n                  text: buffer + chunkText,\n                  schema: chunkSchema,\n                }),\n              );\n              buffer = '';\n            } else {\n              buffer += chunkText;\n            }\n          },\n        }),\n      ),\n    };\n  };\n\nexport const createJsonResponseHandler =\n  <T>(responseSchema: ZodSchema<T>): ResponseHandler<T> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n\n    const parsedResult = safeParseJSON({\n      text: responseBody,\n      schema: responseSchema,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!parsedResult.success) {\n      throw new APICallError({\n        message: 'Invalid JSON response',\n        cause: parsedResult.error,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        url,\n        requestBodyValues,\n      });\n    }\n\n    return {\n      responseHeaders,\n      value: parsedResult.value,\n      rawValue: parsedResult.rawValue,\n    };\n  };\n\nexport const createBinaryResponseHandler =\n  (): ResponseHandler<Uint8Array> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.body) {\n      throw new APICallError({\n        message: 'Response body is empty',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n      });\n    }\n\n    try {\n      const buffer = await response.arrayBuffer();\n      return {\n        responseHeaders,\n        value: new Uint8Array(buffer),\n      };\n    } catch (error) {\n      throw new APICallError({\n        message: 'Failed to read response as array buffer',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n        cause: error,\n      });\n    }\n  };\n\nexport const createStatusCodeErrorResponseHandler =\n  (): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n    const responseBody = await response.text();\n\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues: requestBodyValues as Record<string, unknown>,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n      }),\n    };\n  };\n", "// btoa and atob need to be invoked as a function call, not as a method call.\n// Otherwise CloudFlare will throw a\n// \"TypeError: Illegal invocation: function called with incorrect this reference\"\nconst { btoa, atob } = globalThis;\n\nexport function convertBase64ToUint8Array(base64String: string) {\n  const base64Url = base64String.replace(/-/g, '+').replace(/_/g, '/');\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0)!);\n}\n\nexport function convertUint8ArrayToBase64(array: Uint8Array): string {\n  let latin1string = '';\n\n  // Note: regular for loop to support older JavaScript versions that\n  // do not support for..of on Uint8Array\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n\n  return btoa(latin1string);\n}\n", "export function withoutTrailingSlash(url: string | undefined) {\n  return url?.replace(/\\/$/, '');\n}\n", "export * from \"./Options.js\";\nexport * from \"./Refs.js\";\nexport * from \"./errorMessages.js\";\nexport * from \"./parseDef.js\";\nexport * from \"./parseTypes.js\";\nexport * from \"./parsers/any.js\";\nexport * from \"./parsers/array.js\";\nexport * from \"./parsers/bigint.js\";\nexport * from \"./parsers/boolean.js\";\nexport * from \"./parsers/branded.js\";\nexport * from \"./parsers/catch.js\";\nexport * from \"./parsers/date.js\";\nexport * from \"./parsers/default.js\";\nexport * from \"./parsers/effects.js\";\nexport * from \"./parsers/enum.js\";\nexport * from \"./parsers/intersection.js\";\nexport * from \"./parsers/literal.js\";\nexport * from \"./parsers/map.js\";\nexport * from \"./parsers/nativeEnum.js\";\nexport * from \"./parsers/never.js\";\nexport * from \"./parsers/null.js\";\nexport * from \"./parsers/nullable.js\";\nexport * from \"./parsers/number.js\";\nexport * from \"./parsers/object.js\";\nexport * from \"./parsers/optional.js\";\nexport * from \"./parsers/pipeline.js\";\nexport * from \"./parsers/promise.js\";\nexport * from \"./parsers/readonly.js\";\nexport * from \"./parsers/record.js\";\nexport * from \"./parsers/set.js\";\nexport * from \"./parsers/string.js\";\nexport * from \"./parsers/tuple.js\";\nexport * from \"./parsers/undefined.js\";\nexport * from \"./parsers/union.js\";\nexport * from \"./parsers/unknown.js\";\nexport * from \"./selectParser.js\";\nexport * from \"./zodToJsonSchema.js\";\nimport { zodToJsonSchema } from \"./zodToJsonSchema.js\";\nexport default zodToJsonSchema;\n", "export const ignoreOverride = Symbol(\"Let zodToJsonSchema decide on which parser to use\");\nexport const jsonDescription = (jsonSchema, def) => {\n    if (def.description) {\n        try {\n            return {\n                ...jsonSchema,\n                ...JSON.parse(def.description),\n            };\n        }\n        catch { }\n    }\n    return jsonSchema;\n};\nexport const defaultOptions = {\n    name: undefined,\n    $refStrategy: \"root\",\n    basePath: [\"#\"],\n    effectStrategy: \"input\",\n    pipeStrategy: \"all\",\n    dateStrategy: \"format:date-time\",\n    mapStrategy: \"entries\",\n    removeAdditionalStrategy: \"passthrough\",\n    allowedAdditionalProperties: true,\n    rejectedAdditionalProperties: false,\n    definitionPath: \"definitions\",\n    target: \"jsonSchema7\",\n    strictUnions: false,\n    definitions: {},\n    errorMessages: false,\n    markdownDescription: false,\n    patternStrategy: \"escape\",\n    applyRegexFlags: false,\n    emailStrategy: \"format:email\",\n    base64Strategy: \"contentEncoding:base64\",\n    nameStrategy: \"ref\",\n};\nexport const getDefaultOptions = (options) => (typeof options === \"string\"\n    ? {\n        ...defaultOptions,\n        name: options,\n    }\n    : {\n        ...defaultOptions,\n        ...options,\n    });\n", "import { getDefaultOptions } from \"./Options.js\";\nexport const getRefs = (options) => {\n    const _options = getDefaultOptions(options);\n    const currentPath = _options.name !== undefined\n        ? [..._options.basePath, _options.definitionPath, _options.name]\n        : _options.basePath;\n    return {\n        ..._options,\n        currentPath: currentPath,\n        propertyPath: undefined,\n        seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [\n            def._def,\n            {\n                def: def._def,\n                path: [..._options.basePath, _options.definitionPath, name],\n                // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n                jsonSchema: undefined,\n            },\n        ])),\n    };\n};\n", "export function addErrorMessage(res, key, errorMessage, refs) {\n    if (!refs?.errorMessages)\n        return;\n    if (errorMessage) {\n        res.errorMessage = {\n            ...res.errorMessage,\n            [key]: errorMessage,\n        };\n    }\n}\nexport function setResponseValueAndErrors(res, key, value, errorMessage, refs) {\n    res[key] = value;\n    addErrorMessage(res, key, errorMessage, refs);\n}\n", "import { ignoreOverride } from \"./Options.js\";\nimport { selectParser } from \"./selectParser.js\";\nexport function parseDef(def, refs, forceResolution = false) {\n    const seenItem = refs.seen.get(def);\n    if (refs.override) {\n        const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);\n        if (overrideResult !== ignoreOverride) {\n            return overrideResult;\n        }\n    }\n    if (seenItem && !forceResolution) {\n        const seenSchema = get$ref(seenItem, refs);\n        if (seenSchema !== undefined) {\n            return seenSchema;\n        }\n    }\n    const newItem = { def, path: refs.currentPath, jsonSchema: undefined };\n    refs.seen.set(def, newItem);\n    const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);\n    // If the return was a function, then the inner definition needs to be extracted before a call to parseDef (recursive)\n    const jsonSchema = typeof jsonSchemaOrGetter === \"function\"\n        ? parseDef(jsonSchemaOrGetter(), refs)\n        : jsonSchemaOrGetter;\n    if (jsonSchema) {\n        addMeta(def, refs, jsonSchema);\n    }\n    if (refs.postProcess) {\n        const postProcessResult = refs.postProcess(jsonSchema, def, refs);\n        newItem.jsonSchema = jsonSchema;\n        return postProcessResult;\n    }\n    newItem.jsonSchema = jsonSchema;\n    return jsonSchema;\n}\nconst get$ref = (item, refs) => {\n    switch (refs.$refStrategy) {\n        case \"root\":\n            return { $ref: item.path.join(\"/\") };\n        case \"relative\":\n            return { $ref: getRelativePath(refs.currentPath, item.path) };\n        case \"none\":\n        case \"seen\": {\n            if (item.path.length < refs.currentPath.length &&\n                item.path.every((value, index) => refs.currentPath[index] === value)) {\n                console.warn(`Recursive reference detected at ${refs.currentPath.join(\"/\")}! Defaulting to any`);\n                return {};\n            }\n            return refs.$refStrategy === \"seen\" ? {} : undefined;\n        }\n    }\n};\nconst getRelativePath = (pathA, pathB) => {\n    let i = 0;\n    for (; i < pathA.length && i < pathB.length; i++) {\n        if (pathA[i] !== pathB[i])\n            break;\n    }\n    return [(pathA.length - i).toString(), ...pathB.slice(i)].join(\"/\");\n};\nconst addMeta = (def, refs, jsonSchema) => {\n    if (def.description) {\n        jsonSchema.description = def.description;\n        if (refs.markdownDescription) {\n            jsonSchema.markdownDescription = def.description;\n        }\n    }\n    return jsonSchema;\n};\n", "import { ZodFirstPartyTypeKind } from \"zod\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nimport { parseArrayDef } from \"./parsers/array.js\";\nimport { parseBigintDef } from \"./parsers/bigint.js\";\nimport { parseBooleanDef } from \"./parsers/boolean.js\";\nimport { parseBrandedDef } from \"./parsers/branded.js\";\nimport { parseCatchDef } from \"./parsers/catch.js\";\nimport { parseDateDef } from \"./parsers/date.js\";\nimport { parseDefaultDef } from \"./parsers/default.js\";\nimport { parseEffectsDef } from \"./parsers/effects.js\";\nimport { parseEnumDef } from \"./parsers/enum.js\";\nimport { parseIntersectionDef } from \"./parsers/intersection.js\";\nimport { parseLiteralDef } from \"./parsers/literal.js\";\nimport { parseMapDef } from \"./parsers/map.js\";\nimport { parseNativeEnumDef } from \"./parsers/nativeEnum.js\";\nimport { parseNeverDef } from \"./parsers/never.js\";\nimport { parseNullDef } from \"./parsers/null.js\";\nimport { parseNullableDef } from \"./parsers/nullable.js\";\nimport { parseNumberDef } from \"./parsers/number.js\";\nimport { parseObjectDef } from \"./parsers/object.js\";\nimport { parseOptionalDef } from \"./parsers/optional.js\";\nimport { parsePipelineDef } from \"./parsers/pipeline.js\";\nimport { parsePromiseDef } from \"./parsers/promise.js\";\nimport { parseRecordDef } from \"./parsers/record.js\";\nimport { parseSetDef } from \"./parsers/set.js\";\nimport { parseStringDef } from \"./parsers/string.js\";\nimport { parseTupleDef } from \"./parsers/tuple.js\";\nimport { parseUndefinedDef } from \"./parsers/undefined.js\";\nimport { parseUnionDef } from \"./parsers/union.js\";\nimport { parseUnknownDef } from \"./parsers/unknown.js\";\nimport { parseReadonlyDef } from \"./parsers/readonly.js\";\nexport const selectParser = (def, typeName, refs) => {\n    switch (typeName) {\n        case ZodFirstPartyTypeKind.ZodString:\n            return parseStringDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodNumber:\n            return parseNumberDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodObject:\n            return parseObjectDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBigInt:\n            return parseBigintDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBoolean:\n            return parseBooleanDef();\n        case ZodFirstPartyTypeKind.ZodDate:\n            return parseDateDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodUndefined:\n            return parseUndefinedDef();\n        case ZodFirstPartyTypeKind.ZodNull:\n            return parseNullDef(refs);\n        case ZodFirstPartyTypeKind.ZodArray:\n            return parseArrayDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodUnion:\n        case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n            return parseUnionDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodIntersection:\n            return parseIntersectionDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodTuple:\n            return parseTupleDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodRecord:\n            return parseRecordDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodLiteral:\n            return parseLiteralDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodEnum:\n            return parseEnumDef(def);\n        case ZodFirstPartyTypeKind.ZodNativeEnum:\n            return parseNativeEnumDef(def);\n        case ZodFirstPartyTypeKind.ZodNullable:\n            return parseNullableDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodOptional:\n            return parseOptionalDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodMap:\n            return parseMapDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodSet:\n            return parseSetDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodLazy:\n            return () => def.getter()._def;\n        case ZodFirstPartyTypeKind.ZodPromise:\n            return parsePromiseDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodNaN:\n        case ZodFirstPartyTypeKind.ZodNever:\n            return parseNeverDef();\n        case ZodFirstPartyTypeKind.ZodEffects:\n            return parseEffectsDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodAny:\n            return parseAnyDef();\n        case ZodFirstPartyTypeKind.ZodUnknown:\n            return parseUnknownDef();\n        case ZodFirstPartyTypeKind.ZodDefault:\n            return parseDefaultDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBranded:\n            return parseBrandedDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodReadonly:\n            return parseReadonlyDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodCatch:\n            return parseCatchDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodPipeline:\n            return parsePipelineDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodFunction:\n        case ZodFirstPartyTypeKind.ZodVoid:\n        case ZodFirstPartyTypeKind.ZodSymbol:\n            return undefined;\n        default:\n            /* c8 ignore next */\n            return ((_) => undefined)(typeName);\n    }\n};\n", "export function parseAnyDef() {\n    return {};\n}\n", "import { ZodFirstPartyTypeKind } from \"zod\";\nimport { setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseArrayDef(def, refs) {\n    const res = {\n        type: \"array\",\n    };\n    if (def.type?._def &&\n        def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {\n        res.items = parseDef(def.type._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"items\"],\n        });\n    }\n    if (def.minLength) {\n        setResponseValueAndErrors(res, \"minItems\", def.minLength.value, def.minLength.message, refs);\n    }\n    if (def.maxLength) {\n        setResponseValueAndErrors(res, \"maxItems\", def.maxLength.value, def.maxLength.message, refs);\n    }\n    if (def.exactLength) {\n        setResponseValueAndErrors(res, \"minItems\", def.exactLength.value, def.exactLength.message, refs);\n        setResponseValueAndErrors(res, \"maxItems\", def.exactLength.value, def.exactLength.message, refs);\n    }\n    return res;\n}\n", "import { setResponseValueAndErrors } from \"../errorMessages.js\";\nexport function parseBigintDef(def, refs) {\n    const res = {\n        type: \"integer\",\n        format: \"int64\",\n    };\n    if (!def.checks)\n        return res;\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"min\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMinimum = true;\n                    }\n                    setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                }\n                break;\n            case \"max\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMaximum = true;\n                    }\n                    setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                }\n                break;\n            case \"multipleOf\":\n                setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n                break;\n        }\n    }\n    return res;\n}\n", "export function parseBooleanDef() {\n    return {\n        type: \"boolean\",\n    };\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport function parseBrandedDef(_def, refs) {\n    return parseDef(_def.type._def, refs);\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport const parseCatchDef = (def, refs) => {\n    return parseDef(def.innerType._def, refs);\n};\n", "import { setResponseValueAndErrors } from \"../errorMessages.js\";\nexport function parseDateDef(def, refs, overrideDateStrategy) {\n    const strategy = overrideDateStrategy ?? refs.dateStrategy;\n    if (Array.isArray(strategy)) {\n        return {\n            anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)),\n        };\n    }\n    switch (strategy) {\n        case \"string\":\n        case \"format:date-time\":\n            return {\n                type: \"string\",\n                format: \"date-time\",\n            };\n        case \"format:date\":\n            return {\n                type: \"string\",\n                format: \"date\",\n            };\n        case \"integer\":\n            return integerDateParser(def, refs);\n    }\n}\nconst integerDateParser = (def, refs) => {\n    const res = {\n        type: \"integer\",\n        format: \"unix-time\",\n    };\n    if (refs.target === \"openApi3\") {\n        return res;\n    }\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"min\":\n                setResponseValueAndErrors(res, \"minimum\", check.value, // This is in milliseconds\n                check.message, refs);\n                break;\n            case \"max\":\n                setResponseValueAndErrors(res, \"maximum\", check.value, // This is in milliseconds\n                check.message, refs);\n                break;\n        }\n    }\n    return res;\n};\n", "import { parseDef } from \"../parseDef.js\";\nexport function parseDefaultDef(_def, refs) {\n    return {\n        ...parseDef(_def.innerType._def, refs),\n        default: _def.defaultValue(),\n    };\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport function parseEffectsDef(_def, refs) {\n    return refs.effectStrategy === \"input\"\n        ? parseDef(_def.schema._def, refs)\n        : {};\n}\n", "export function parseEnumDef(def) {\n    return {\n        type: \"string\",\n        enum: Array.from(def.values),\n    };\n}\n", "import { parseDef } from \"../parseDef.js\";\nconst isJsonSchema7AllOfType = (type) => {\n    if (\"type\" in type && type.type === \"string\")\n        return false;\n    return \"allOf\" in type;\n};\nexport function parseIntersectionDef(def, refs) {\n    const allOf = [\n        parseDef(def.left._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n        }),\n        parseDef(def.right._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"1\"],\n        }),\n    ].filter((x) => !!x);\n    let unevaluatedProperties = refs.target === \"jsonSchema2019-09\"\n        ? { unevaluatedProperties: false }\n        : undefined;\n    const mergedAllOf = [];\n    // If either of the schemas is an allOf, merge them into a single allOf\n    allOf.forEach((schema) => {\n        if (isJsonSchema7AllOfType(schema)) {\n            mergedAllOf.push(...schema.allOf);\n            if (schema.unevaluatedProperties === undefined) {\n                // If one of the schemas has no unevaluatedProperties set,\n                // the merged schema should also have no unevaluatedProperties set\n                unevaluatedProperties = undefined;\n            }\n        }\n        else {\n            let nestedSchema = schema;\n            if (\"additionalProperties\" in schema &&\n                schema.additionalProperties === false) {\n                const { additionalProperties, ...rest } = schema;\n                nestedSchema = rest;\n            }\n            else {\n                // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties\n                unevaluatedProperties = undefined;\n            }\n            mergedAllOf.push(nestedSchema);\n        }\n    });\n    return mergedAllOf.length\n        ? {\n            allOf: mergedAllOf,\n            ...unevaluatedProperties,\n        }\n        : undefined;\n}\n", "export function parseLiteralDef(def, refs) {\n    const parsedType = typeof def.value;\n    if (parsedType !== \"bigint\" &&\n        parsedType !== \"number\" &&\n        parsedType !== \"boolean\" &&\n        parsedType !== \"string\") {\n        return {\n            type: Array.isArray(def.value) ? \"array\" : \"object\",\n        };\n    }\n    if (refs.target === \"openApi3\") {\n        return {\n            type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n            enum: [def.value],\n        };\n    }\n    return {\n        type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n        const: def.value,\n    };\n}\n", "import { parseDef } from \"../parseDef.js\";\nimport { parseRecordDef } from \"./record.js\";\nexport function parseMapDef(def, refs) {\n    if (refs.mapStrategy === \"record\") {\n        return parseRecordDef(def, refs);\n    }\n    const keys = parseDef(def.keyType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", \"items\", \"0\"],\n    }) || {};\n    const values = parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", \"items\", \"1\"],\n    }) || {};\n    return {\n        type: \"array\",\n        maxItems: 125,\n        items: {\n            type: \"array\",\n            items: [keys, values],\n            minItems: 2,\n            maxItems: 2,\n        },\n    };\n}\n", "import { ZodFirstPartyTypeKind, } from \"zod\";\nimport { parseDef } from \"../parseDef.js\";\nimport { parseStringDef } from \"./string.js\";\nimport { parseBrandedDef } from \"./branded.js\";\nexport function parseRecordDef(def, refs) {\n    if (refs.target === \"openAi\") {\n        console.warn(\"Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.\");\n    }\n    if (refs.target === \"openApi3\" &&\n        def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n        return {\n            type: \"object\",\n            required: def.keyType._def.values,\n            properties: def.keyType._def.values.reduce((acc, key) => ({\n                ...acc,\n                [key]: parseDef(def.valueType._def, {\n                    ...refs,\n                    currentPath: [...refs.currentPath, \"properties\", key],\n                }) ?? {},\n            }), {}),\n            additionalProperties: refs.rejectedAdditionalProperties,\n        };\n    }\n    const schema = {\n        type: \"object\",\n        additionalProperties: parseDef(def.valueType._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"additionalProperties\"],\n        }) ?? refs.allowedAdditionalProperties,\n    };\n    if (refs.target === \"openApi3\") {\n        return schema;\n    }\n    if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n        def.keyType._def.checks?.length) {\n        const { type, ...keyType } = parseStringDef(def.keyType._def, refs);\n        return {\n            ...schema,\n            propertyNames: keyType,\n        };\n    }\n    else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n        return {\n            ...schema,\n            propertyNames: {\n                enum: def.keyType._def.values,\n            },\n        };\n    }\n    else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded &&\n        def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n        def.keyType._def.type._def.checks?.length) {\n        const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);\n        return {\n            ...schema,\n            propertyNames: keyType,\n        };\n    }\n    return schema;\n}\n", "import { setResponseValueAndErrors } from \"../errorMessages.js\";\nlet emojiRegex = undefined;\n/**\n * Generated from the regular expressions found here as of 2024-05-22:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Expressions with /i flag have been changed accordingly.\n */\nexport const zodPatterns = {\n    /**\n     * `c` was changed to `[cC]` to replicate /i flag\n     */\n    cuid: /^[cC][^\\s-]{8,}$/,\n    cuid2: /^[0-9a-z]+$/,\n    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n    /**\n     * `a-z` was added to replicate /i flag\n     */\n    email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n    /**\n     * Constructed a valid Unicode RegExp\n     *\n     * Lazily instantiate since this type of regex isn't supported\n     * in all envs (e.g. React Native).\n     *\n     * See:\n     * https://github.com/colinhacks/zod/issues/2433\n     * Fix in Zod:\n     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n     */\n    emoji: () => {\n        if (emojiRegex === undefined) {\n            emojiRegex = RegExp(\"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\", \"u\");\n        }\n        return emojiRegex;\n    },\n    /**\n     * Unused\n     */\n    uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n    /**\n     * Unused\n     */\n    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n    /**\n     * Unused\n     */\n    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n    nanoid: /^[a-zA-Z0-9_-]{21}$/,\n    jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/,\n};\nexport function parseStringDef(def, refs) {\n    const res = {\n        type: \"string\",\n    };\n    if (def.checks) {\n        for (const check of def.checks) {\n            switch (check.kind) {\n                case \"min\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"max\":\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"email\":\n                    switch (refs.emailStrategy) {\n                        case \"format:email\":\n                            addFormat(res, \"email\", check.message, refs);\n                            break;\n                        case \"format:idn-email\":\n                            addFormat(res, \"idn-email\", check.message, refs);\n                            break;\n                        case \"pattern:zod\":\n                            addPattern(res, zodPatterns.email, check.message, refs);\n                            break;\n                    }\n                    break;\n                case \"url\":\n                    addFormat(res, \"uri\", check.message, refs);\n                    break;\n                case \"uuid\":\n                    addFormat(res, \"uuid\", check.message, refs);\n                    break;\n                case \"regex\":\n                    addPattern(res, check.regex, check.message, refs);\n                    break;\n                case \"cuid\":\n                    addPattern(res, zodPatterns.cuid, check.message, refs);\n                    break;\n                case \"cuid2\":\n                    addPattern(res, zodPatterns.cuid2, check.message, refs);\n                    break;\n                case \"startsWith\":\n                    addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);\n                    break;\n                case \"endsWith\":\n                    addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);\n                    break;\n                case \"datetime\":\n                    addFormat(res, \"date-time\", check.message, refs);\n                    break;\n                case \"date\":\n                    addFormat(res, \"date\", check.message, refs);\n                    break;\n                case \"time\":\n                    addFormat(res, \"time\", check.message, refs);\n                    break;\n                case \"duration\":\n                    addFormat(res, \"duration\", check.message, refs);\n                    break;\n                case \"length\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"includes\": {\n                    addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);\n                    break;\n                }\n                case \"ip\": {\n                    if (check.version !== \"v6\") {\n                        addFormat(res, \"ipv4\", check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addFormat(res, \"ipv6\", check.message, refs);\n                    }\n                    break;\n                }\n                case \"base64url\":\n                    addPattern(res, zodPatterns.base64url, check.message, refs);\n                    break;\n                case \"jwt\":\n                    addPattern(res, zodPatterns.jwt, check.message, refs);\n                    break;\n                case \"cidr\": {\n                    if (check.version !== \"v6\") {\n                        addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);\n                    }\n                    break;\n                }\n                case \"emoji\":\n                    addPattern(res, zodPatterns.emoji(), check.message, refs);\n                    break;\n                case \"ulid\": {\n                    addPattern(res, zodPatterns.ulid, check.message, refs);\n                    break;\n                }\n                case \"base64\": {\n                    switch (refs.base64Strategy) {\n                        case \"format:binary\": {\n                            addFormat(res, \"binary\", check.message, refs);\n                            break;\n                        }\n                        case \"contentEncoding:base64\": {\n                            setResponseValueAndErrors(res, \"contentEncoding\", \"base64\", check.message, refs);\n                            break;\n                        }\n                        case \"pattern:zod\": {\n                            addPattern(res, zodPatterns.base64, check.message, refs);\n                            break;\n                        }\n                    }\n                    break;\n                }\n                case \"nanoid\": {\n                    addPattern(res, zodPatterns.nanoid, check.message, refs);\n                }\n                case \"toLowerCase\":\n                case \"toUpperCase\":\n                case \"trim\":\n                    break;\n                default:\n                    /* c8 ignore next */\n                    ((_) => { })(check);\n            }\n        }\n    }\n    return res;\n}\nfunction escapeLiteralCheckValue(literal, refs) {\n    return refs.patternStrategy === \"escape\"\n        ? escapeNonAlphaNumeric(literal)\n        : literal;\n}\nconst ALPHA_NUMERIC = new Set(\"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\");\nfunction escapeNonAlphaNumeric(source) {\n    let result = \"\";\n    for (let i = 0; i < source.length; i++) {\n        if (!ALPHA_NUMERIC.has(source[i])) {\n            result += \"\\\\\";\n        }\n        result += source[i];\n    }\n    return result;\n}\n// Adds a \"format\" keyword to the schema. If a format exists, both formats will be joined in an allOf-node, along with subsequent ones.\nfunction addFormat(schema, value, message, refs) {\n    if (schema.format || schema.anyOf?.some((x) => x.format)) {\n        if (!schema.anyOf) {\n            schema.anyOf = [];\n        }\n        if (schema.format) {\n            schema.anyOf.push({\n                format: schema.format,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { format: schema.errorMessage.format },\n                }),\n            });\n            delete schema.format;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.format;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.anyOf.push({\n            format: value,\n            ...(message &&\n                refs.errorMessages && { errorMessage: { format: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"format\", value, message, refs);\n    }\n}\n// Adds a \"pattern\" keyword to the schema. If a pattern exists, both patterns will be joined in an allOf-node, along with subsequent ones.\nfunction addPattern(schema, regex, message, refs) {\n    if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {\n        if (!schema.allOf) {\n            schema.allOf = [];\n        }\n        if (schema.pattern) {\n            schema.allOf.push({\n                pattern: schema.pattern,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { pattern: schema.errorMessage.pattern },\n                }),\n            });\n            delete schema.pattern;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.pattern;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.allOf.push({\n            pattern: stringifyRegExpWithFlags(regex, refs),\n            ...(message &&\n                refs.errorMessages && { errorMessage: { pattern: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"pattern\", stringifyRegExpWithFlags(regex, refs), message, refs);\n    }\n}\n// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\nfunction stringifyRegExpWithFlags(regex, refs) {\n    if (!refs.applyRegexFlags || !regex.flags) {\n        return regex.source;\n    }\n    // Currently handled flags\n    const flags = {\n        i: regex.flags.includes(\"i\"),\n        m: regex.flags.includes(\"m\"),\n        s: regex.flags.includes(\"s\"), // `.` matches newlines\n    };\n    // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n    const source = flags.i ? regex.source.toLowerCase() : regex.source;\n    let pattern = \"\";\n    let isEscaped = false;\n    let inCharGroup = false;\n    let inCharRange = false;\n    for (let i = 0; i < source.length; i++) {\n        if (isEscaped) {\n            pattern += source[i];\n            isEscaped = false;\n            continue;\n        }\n        if (flags.i) {\n            if (inCharGroup) {\n                if (source[i].match(/[a-z]/)) {\n                    if (inCharRange) {\n                        pattern += source[i];\n                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n                        inCharRange = false;\n                    }\n                    else if (source[i + 1] === \"-\" && source[i + 2]?.match(/[a-z]/)) {\n                        pattern += source[i];\n                        inCharRange = true;\n                    }\n                    else {\n                        pattern += `${source[i]}${source[i].toUpperCase()}`;\n                    }\n                    continue;\n                }\n            }\n            else if (source[i].match(/[a-z]/)) {\n                pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n                continue;\n            }\n        }\n        if (flags.m) {\n            if (source[i] === \"^\") {\n                pattern += `(^|(?<=[\\r\\n]))`;\n                continue;\n            }\n            else if (source[i] === \"$\") {\n                pattern += `($|(?=[\\r\\n]))`;\n                continue;\n            }\n        }\n        if (flags.s && source[i] === \".\") {\n            pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n            continue;\n        }\n        pattern += source[i];\n        if (source[i] === \"\\\\\") {\n            isEscaped = true;\n        }\n        else if (inCharGroup && source[i] === \"]\") {\n            inCharGroup = false;\n        }\n        else if (!inCharGroup && source[i] === \"[\") {\n            inCharGroup = true;\n        }\n    }\n    try {\n        new RegExp(pattern);\n    }\n    catch {\n        console.warn(`Could not convert regex pattern at ${refs.currentPath.join(\"/\")} to a flag-independent form! Falling back to the flag-ignorant source`);\n        return regex.source;\n    }\n    return pattern;\n}\n", "export function parseNativeEnumDef(def) {\n    const object = def.values;\n    const actualKeys = Object.keys(def.values).filter((key) => {\n        return typeof object[object[key]] !== \"number\";\n    });\n    const actualValues = actualKeys.map((key) => object[key]);\n    const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));\n    return {\n        type: parsedTypes.length === 1\n            ? parsedTypes[0] === \"string\"\n                ? \"string\"\n                : \"number\"\n            : [\"string\", \"number\"],\n        enum: actualValues,\n    };\n}\n", "export function parseNeverDef() {\n    return {\n        not: {},\n    };\n}\n", "export function parseNullDef(refs) {\n    return refs.target === \"openApi3\"\n        ? {\n            enum: [\"null\"],\n            nullable: true,\n        }\n        : {\n            type: \"null\",\n        };\n}\n", "import { parseDef } from \"../parseDef.js\";\nimport { primitiveMappings } from \"./union.js\";\nexport function parseNullableDef(def, refs) {\n    if ([\"ZodString\", \"ZodNumber\", \"ZodBigInt\", \"ZodBoolean\", \"ZodNull\"].includes(def.innerType._def.typeName) &&\n        (!def.innerType._def.checks || !def.innerType._def.checks.length)) {\n        if (refs.target === \"openApi3\") {\n            return {\n                type: primitiveMappings[def.innerType._def.typeName],\n                nullable: true,\n            };\n        }\n        return {\n            type: [\n                primitiveMappings[def.innerType._def.typeName],\n                \"null\",\n            ],\n        };\n    }\n    if (refs.target === \"openApi3\") {\n        const base = parseDef(def.innerType._def, {\n            ...refs,\n            currentPath: [...refs.currentPath],\n        });\n        if (base && \"$ref\" in base)\n            return { allOf: [base], nullable: true };\n        return base && { ...base, nullable: true };\n    }\n    const base = parseDef(def.innerType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", \"0\"],\n    });\n    return base && { anyOf: [base, { type: \"null\" }] };\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport const primitiveMappings = {\n    ZodString: \"string\",\n    ZodNumber: \"number\",\n    ZodBigInt: \"integer\",\n    ZodBoolean: \"boolean\",\n    ZodNull: \"null\",\n};\nexport function parseUnionDef(def, refs) {\n    if (refs.target === \"openApi3\")\n        return asAnyOf(def, refs);\n    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n    // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.\n    if (options.every((x) => x._def.typeName in primitiveMappings &&\n        (!x._def.checks || !x._def.checks.length))) {\n        // all types in union are primitive and lack checks, so might as well squash into {type: [...]}\n        const types = options.reduce((types, x) => {\n            const type = primitiveMappings[x._def.typeName]; //Can be safely casted due to row 43\n            return type && !types.includes(type) ? [...types, type] : types;\n        }, []);\n        return {\n            type: types.length > 1 ? types : types[0],\n        };\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n        // all options literals\n        const types = options.reduce((acc, x) => {\n            const type = typeof x._def.value;\n            switch (type) {\n                case \"string\":\n                case \"number\":\n                case \"boolean\":\n                    return [...acc, type];\n                case \"bigint\":\n                    return [...acc, \"integer\"];\n                case \"object\":\n                    if (x._def.value === null)\n                        return [...acc, \"null\"];\n                case \"symbol\":\n                case \"undefined\":\n                case \"function\":\n                default:\n                    return acc;\n            }\n        }, []);\n        if (types.length === options.length) {\n            // all the literals are primitive, as far as null can be considered primitive\n            const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n            return {\n                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n                enum: options.reduce((acc, x) => {\n                    return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n                }, []),\n            };\n        }\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodEnum\")) {\n        return {\n            type: \"string\",\n            enum: options.reduce((acc, x) => [\n                ...acc,\n                ...x._def.values.filter((x) => !acc.includes(x)),\n            ], []),\n        };\n    }\n    return asAnyOf(def, refs);\n}\nconst asAnyOf = (def, refs) => {\n    const anyOf = (def.options instanceof Map\n        ? Array.from(def.options.values())\n        : def.options)\n        .map((x, i) => parseDef(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", `${i}`],\n    }))\n        .filter((x) => !!x &&\n        (!refs.strictUnions ||\n            (typeof x === \"object\" && Object.keys(x).length > 0)));\n    return anyOf.length ? { anyOf } : undefined;\n};\n", "import { addErrorMessage, setResponseValueAndErrors, } from \"../errorMessages.js\";\nexport function parseNumberDef(def, refs) {\n    const res = {\n        type: \"number\",\n    };\n    if (!def.checks)\n        return res;\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"int\":\n                res.type = \"integer\";\n                addErrorMessage(res, \"type\", check.message, refs);\n                break;\n            case \"min\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMinimum = true;\n                    }\n                    setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                }\n                break;\n            case \"max\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMaximum = true;\n                    }\n                    setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                }\n                break;\n            case \"multipleOf\":\n                setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n                break;\n        }\n    }\n    return res;\n}\n", "import { ZodOptional } from \"zod\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseObjectDef(def, refs) {\n    const forceOptionalIntoNullable = refs.target === \"openAi\";\n    const result = {\n        type: \"object\",\n        properties: {},\n    };\n    const required = [];\n    const shape = def.shape();\n    for (const propName in shape) {\n        let propDef = shape[propName];\n        if (propDef === undefined || propDef._def === undefined) {\n            continue;\n        }\n        let propOptional = safeIsOptional(propDef);\n        if (propOptional && forceOptionalIntoNullable) {\n            if (propDef instanceof ZodOptional) {\n                propDef = propDef._def.innerType;\n            }\n            if (!propDef.isNullable()) {\n                propDef = propDef.nullable();\n            }\n            propOptional = false;\n        }\n        const parsedDef = parseDef(propDef._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"properties\", propName],\n            propertyPath: [...refs.currentPath, \"properties\", propName],\n        });\n        if (parsedDef === undefined) {\n            continue;\n        }\n        result.properties[propName] = parsedDef;\n        if (!propOptional) {\n            required.push(propName);\n        }\n    }\n    if (required.length) {\n        result.required = required;\n    }\n    const additionalProperties = decideAdditionalProperties(def, refs);\n    if (additionalProperties !== undefined) {\n        result.additionalProperties = additionalProperties;\n    }\n    return result;\n}\nfunction decideAdditionalProperties(def, refs) {\n    if (def.catchall._def.typeName !== \"ZodNever\") {\n        return parseDef(def.catchall._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"additionalProperties\"],\n        });\n    }\n    switch (def.unknownKeys) {\n        case \"passthrough\":\n            return refs.allowedAdditionalProperties;\n        case \"strict\":\n            return refs.rejectedAdditionalProperties;\n        case \"strip\":\n            return refs.removeAdditionalStrategy === \"strict\"\n                ? refs.allowedAdditionalProperties\n                : refs.rejectedAdditionalProperties;\n    }\n}\nfunction safeIsOptional(schema) {\n    try {\n        return schema.isOptional();\n    }\n    catch {\n        return true;\n    }\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport const parseOptionalDef = (def, refs) => {\n    if (refs.currentPath.toString() === refs.propertyPath?.toString()) {\n        return parseDef(def.innerType._def, refs);\n    }\n    const innerSchema = parseDef(def.innerType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", \"1\"],\n    });\n    return innerSchema\n        ? {\n            anyOf: [\n                {\n                    not: {},\n                },\n                innerSchema,\n            ],\n        }\n        : {};\n};\n", "import { parseDef } from \"../parseDef.js\";\nexport const parsePipelineDef = (def, refs) => {\n    if (refs.pipeStrategy === \"input\") {\n        return parseDef(def.in._def, refs);\n    }\n    else if (refs.pipeStrategy === \"output\") {\n        return parseDef(def.out._def, refs);\n    }\n    const a = parseDef(def.in._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n    });\n    const b = parseDef(def.out._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"allOf\", a ? \"1\" : \"0\"],\n    });\n    return {\n        allOf: [a, b].filter((x) => x !== undefined),\n    };\n};\n", "import { parseDef } from \"../parseDef.js\";\nexport function parsePromiseDef(def, refs) {\n    return parseDef(def.type._def, refs);\n}\n", "import { setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseSetDef(def, refs) {\n    const items = parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\"],\n    });\n    const schema = {\n        type: \"array\",\n        uniqueItems: true,\n        items,\n    };\n    if (def.minSize) {\n        setResponseValueAndErrors(schema, \"minItems\", def.minSize.value, def.minSize.message, refs);\n    }\n    if (def.maxSize) {\n        setResponseValueAndErrors(schema, \"maxItems\", def.maxSize.value, def.maxSize.message, refs);\n    }\n    return schema;\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport function parseTupleDef(def, refs) {\n    if (def.rest) {\n        return {\n            type: \"array\",\n            minItems: def.items.length,\n            items: def.items\n                .map((x, i) => parseDef(x._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"items\", `${i}`],\n            }))\n                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n            additionalItems: parseDef(def.rest._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"additionalItems\"],\n            }),\n        };\n    }\n    else {\n        return {\n            type: \"array\",\n            minItems: def.items.length,\n            maxItems: def.items.length,\n            items: def.items\n                .map((x, i) => parseDef(x._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"items\", `${i}`],\n            }))\n                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n        };\n    }\n}\n", "export function parseUndefinedDef() {\n    return {\n        not: {},\n    };\n}\n", "export function parseUnknownDef() {\n    return {};\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport const parseReadonlyDef = (def, refs) => {\n    return parseDef(def.innerType._def, refs);\n};\n", "export {};\n", "import { parseDef } from \"./parseDef.js\";\nimport { getRefs } from \"./Refs.js\";\nconst zodToJsonSchema = (schema, options) => {\n    const refs = getRefs(options);\n    const definitions = typeof options === \"object\" && options.definitions\n        ? Object.entries(options.definitions).reduce((acc, [name, schema]) => ({\n            ...acc,\n            [name]: parseDef(schema._def, {\n                ...refs,\n                currentPath: [...refs.basePath, refs.definitionPath, name],\n            }, true) ?? {},\n        }), {})\n        : undefined;\n    const name = typeof options === \"string\"\n        ? options\n        : options?.nameStrategy === \"title\"\n            ? undefined\n            : options?.name;\n    const main = parseDef(schema._def, name === undefined\n        ? refs\n        : {\n            ...refs,\n            currentPath: [...refs.basePath, refs.definitionPath, name],\n        }, false) ?? {};\n    const title = typeof options === \"object\" &&\n        options.name !== undefined &&\n        options.nameStrategy === \"title\"\n        ? options.name\n        : undefined;\n    if (title !== undefined) {\n        main.title = title;\n    }\n    const combined = name === undefined\n        ? definitions\n            ? {\n                ...main,\n                [refs.definitionPath]: definitions,\n            }\n            : main\n        : {\n            $ref: [\n                ...(refs.$refStrategy === \"relative\" ? [] : refs.basePath),\n                refs.definitionPath,\n                name,\n            ].join(\"/\"),\n            [refs.definitionPath]: {\n                ...definitions,\n                [name]: main,\n            },\n        };\n    if (refs.target === \"jsonSchema7\") {\n        combined.$schema = \"http://json-schema.org/draft-07/schema#\";\n    }\n    else if (refs.target === \"jsonSchema2019-09\" || refs.target === \"openAi\") {\n        combined.$schema = \"https://json-schema.org/draft/2019-09/schema#\";\n    }\n    if (refs.target === \"openAi\" &&\n        (\"anyOf\" in combined ||\n            \"oneOf\" in combined ||\n            \"allOf\" in combined ||\n            (\"type\" in combined && Array.isArray(combined.type)))) {\n        console.warn(\"Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.\");\n    }\n    return combined;\n};\nexport { zodToJsonSchema };\n", "export * from './types';\n\nexport { generateId } from '@ai-sdk/provider-utils';\n\n// Export stream data utilities for custom stream implementations,\n// both on the client and server side.\n// NOTE: this is experimental / internal and may change without notice\nexport {\n  formatAssistantStreamPart,\n  parseAssistantStreamPart,\n} from './assistant-stream-parts';\nexport type {\n  AssistantStreamPart,\n  AssistantStreamString,\n} from './assistant-stream-parts';\nexport { callChatApi } from './call-chat-api';\nexport { callCompletionApi } from './call-completion-api';\nexport { formatDataStreamPart, parseDataStreamPart } from './data-stream-parts';\nexport type { DataStreamPart, DataStreamString } from './data-stream-parts';\nexport { getTextFromDataUrl } from './data-url';\nexport type { DeepPartial } from './deep-partial';\nexport { extractMaxToolInvocationStep } from './extract-max-tool-invocation-step';\nexport { fillMessageParts } from './fill-message-parts';\nexport { getMessageParts } from './get-message-parts';\nexport { isDeepEqualData } from './is-deep-equal-data';\nexport { parsePartialJson } from './parse-partial-json';\nexport { prepareAttachmentsForRequest } from './prepare-attachments-for-request';\nexport { processAssistantStream } from './process-assistant-stream';\nexport { processDataStream } from './process-data-stream';\nexport { processTextStream } from './process-text-stream';\nexport { asSchema, jsonSchema } from './schema';\nexport type { Schema } from './schema';\nexport {\n  isAssistantMessageWithCompletedToolCalls,\n  shouldResubmitMessages,\n} from './should-resubmit-messages';\nexport { updateToolCallResult } from './update-tool-call-result';\nexport { zodSchema } from './zod-schema';\n", "import { AssistantMessage, DataMessage, JSONValue } from './types';\n\nexport type AssistantStreamString =\n  `${(typeof StreamStringPrefixes)[keyof typeof StreamStringPrefixes]}:${string}\\n`;\n\nexport interface AssistantStreamPart<\n  CODE extends string,\n  NAME extends string,\n  TYPE,\n> {\n  code: CODE;\n  name: NAME;\n  parse: (value: JSONValue) => { type: NAME; value: TYPE };\n}\n\nconst textStreamPart: AssistantStreamPart<'0', 'text', string> = {\n  code: '0',\n  name: 'text',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: 'text', value };\n  },\n};\n\nconst errorStreamPart: AssistantStreamPart<'3', 'error', string> = {\n  code: '3',\n  name: 'error',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: 'error', value };\n  },\n};\n\nconst assistantMessageStreamPart: AssistantStreamPart<\n  '4',\n  'assistant_message',\n  AssistantMessage\n> = {\n  code: '4',\n  name: 'assistant_message',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('id' in value) ||\n      !('role' in value) ||\n      !('content' in value) ||\n      typeof value.id !== 'string' ||\n      typeof value.role !== 'string' ||\n      value.role !== 'assistant' ||\n      !Array.isArray(value.content) ||\n      !value.content.every(\n        item =>\n          item != null &&\n          typeof item === 'object' &&\n          'type' in item &&\n          item.type === 'text' &&\n          'text' in item &&\n          item.text != null &&\n          typeof item.text === 'object' &&\n          'value' in item.text &&\n          typeof item.text.value === 'string',\n      )\n    ) {\n      throw new Error(\n        '\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.',\n      );\n    }\n\n    return {\n      type: 'assistant_message',\n      value: value as AssistantMessage,\n    };\n  },\n};\n\nconst assistantControlDataStreamPart: AssistantStreamPart<\n  '5',\n  'assistant_control_data',\n  {\n    threadId: string;\n    messageId: string;\n  }\n> = {\n  code: '5',\n  name: 'assistant_control_data',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('threadId' in value) ||\n      !('messageId' in value) ||\n      typeof value.threadId !== 'string' ||\n      typeof value.messageId !== 'string'\n    ) {\n      throw new Error(\n        '\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.',\n      );\n    }\n\n    return {\n      type: 'assistant_control_data',\n      value: {\n        threadId: value.threadId,\n        messageId: value.messageId,\n      },\n    };\n  },\n};\n\nconst dataMessageStreamPart: AssistantStreamPart<\n  '6',\n  'data_message',\n  DataMessage\n> = {\n  code: '6',\n  name: 'data_message',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('role' in value) ||\n      !('data' in value) ||\n      typeof value.role !== 'string' ||\n      value.role !== 'data'\n    ) {\n      throw new Error(\n        '\"data_message\" parts expect an object with a \"role\" and \"data\" property.',\n      );\n    }\n\n    return {\n      type: 'data_message',\n      value: value as DataMessage,\n    };\n  },\n};\n\nconst assistantStreamParts = [\n  textStreamPart,\n  errorStreamPart,\n  assistantMessageStreamPart,\n  assistantControlDataStreamPart,\n  dataMessageStreamPart,\n] as const;\n\ntype AssistantStreamParts =\n  | typeof textStreamPart\n  | typeof errorStreamPart\n  | typeof assistantMessageStreamPart\n  | typeof assistantControlDataStreamPart\n  | typeof dataMessageStreamPart;\n\ntype AssistantStreamPartValueType = {\n  [P in AssistantStreamParts as P['name']]: ReturnType<P['parse']>['value'];\n};\n\nexport type AssistantStreamPartType =\n  | ReturnType<typeof textStreamPart.parse>\n  | ReturnType<typeof errorStreamPart.parse>\n  | ReturnType<typeof assistantMessageStreamPart.parse>\n  | ReturnType<typeof assistantControlDataStreamPart.parse>\n  | ReturnType<typeof dataMessageStreamPart.parse>;\n\nexport const assistantStreamPartsByCode = {\n  [textStreamPart.code]: textStreamPart,\n  [errorStreamPart.code]: errorStreamPart,\n  [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n  [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n  [dataMessageStreamPart.code]: dataMessageStreamPart,\n} as const;\n\nexport const StreamStringPrefixes = {\n  [textStreamPart.name]: textStreamPart.code,\n  [errorStreamPart.name]: errorStreamPart.code,\n  [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n  [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n  [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n} as const;\n\nexport const validCodes = assistantStreamParts.map(part => part.code);\n\nexport const parseAssistantStreamPart = (\n  line: string,\n): AssistantStreamPartType => {\n  const firstSeparatorIndex = line.indexOf(':');\n\n  if (firstSeparatorIndex === -1) {\n    throw new Error('Failed to parse stream string. No separator found.');\n  }\n\n  const prefix = line.slice(0, firstSeparatorIndex);\n\n  if (!validCodes.includes(prefix as keyof typeof assistantStreamPartsByCode)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n\n  const code = prefix as keyof typeof assistantStreamPartsByCode;\n\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue: JSONValue = JSON.parse(textValue);\n\n  return assistantStreamPartsByCode[code].parse(jsonValue);\n};\n\nexport function formatAssistantStreamPart<\n  T extends keyof AssistantStreamPartValueType,\n>(type: T, value: AssistantStreamPartValueType[T]): AssistantStreamString {\n  const streamPart = assistantStreamParts.find(part => part.name === type);\n\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n\n  return `${streamPart.code}:${JSON.stringify(value)}\\n`;\n}\n", "import { LanguageModelV1FinishReason } from '@ai-sdk/provider';\nimport { generateId as generateIdFunction } from '@ai-sdk/provider-utils';\nimport {\n  calculateLanguageModelUsage,\n  LanguageModelUsage,\n} from './duplicated/usage';\nimport { parsePartialJson } from './parse-partial-json';\nimport { processDataStream } from './process-data-stream';\nimport type {\n  JSONValue,\n  ReasoningUIPart,\n  TextUIPart,\n  ToolInvocation,\n  ToolInvocationUIPart,\n  UIMessage,\n  UseChatOptions,\n} from './types';\n\nexport async function processChatResponse({\n  stream,\n  update,\n  onToolCall,\n  onFinish,\n  generateId = generateIdFunction,\n  getCurrentDate = () => new Date(),\n  lastMessage,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  update: (options: {\n    message: UIMessage;\n    data: JSONValue[] | undefined;\n    replaceLastMessage: boolean;\n  }) => void;\n  onToolCall?: UseChatOptions['onToolCall'];\n  onFinish?: (options: {\n    message: UIMessage | undefined;\n    finishReason: LanguageModelV1FinishReason;\n    usage: LanguageModelUsage;\n  }) => void;\n  generateId?: () => string;\n  getCurrentDate?: () => Date;\n  lastMessage: UIMessage | undefined;\n}) {\n  const replaceLastMessage = lastMessage?.role === 'assistant';\n  let step = replaceLastMessage\n    ? 1 +\n      // find max step in existing tool invocations:\n      (lastMessage.toolInvocations?.reduce((max, toolInvocation) => {\n        return Math.max(max, toolInvocation.step ?? 0);\n      }, 0) ?? 0)\n    : 0;\n\n  const message: UIMessage = replaceLastMessage\n    ? structuredClone(lastMessage)\n    : {\n        id: generateId(),\n        createdAt: getCurrentDate(),\n        role: 'assistant',\n        content: '',\n        parts: [],\n      };\n\n  let currentTextPart: TextUIPart | undefined = undefined;\n  let currentReasoningPart: ReasoningUIPart | undefined = undefined;\n  let currentReasoningTextDetail:\n    | { type: 'text'; text: string; signature?: string }\n    | undefined = undefined;\n\n  function updateToolInvocationPart(\n    toolCallId: string,\n    invocation: ToolInvocation,\n  ) {\n    const part = message.parts.find(\n      part =>\n        part.type === 'tool-invocation' &&\n        part.toolInvocation.toolCallId === toolCallId,\n    ) as ToolInvocationUIPart | undefined;\n\n    if (part != null) {\n      part.toolInvocation = invocation;\n    } else {\n      message.parts.push({\n        type: 'tool-invocation',\n        toolInvocation: invocation,\n      });\n    }\n  }\n\n  const data: JSONValue[] = [];\n\n  // keep list of current message annotations for message\n  let messageAnnotations: JSONValue[] | undefined = replaceLastMessage\n    ? lastMessage?.annotations\n    : undefined;\n\n  // keep track of partial tool calls\n  const partialToolCalls: Record<\n    string,\n    { text: string; step: number; index: number; toolName: string }\n  > = {};\n\n  let usage: LanguageModelUsage = {\n    completionTokens: NaN,\n    promptTokens: NaN,\n    totalTokens: NaN,\n  };\n  let finishReason: LanguageModelV1FinishReason = 'unknown';\n\n  function execUpdate() {\n    // make a copy of the data array to ensure UI is updated (SWR)\n    const copiedData = [...data];\n\n    // keeps the currentMessage up to date with the latest annotations,\n    // even if annotations preceded the message creation\n    if (messageAnnotations?.length) {\n      message.annotations = messageAnnotations;\n    }\n\n    const copiedMessage = {\n      // deep copy the message to ensure that deep changes (msg attachments) are updated\n      // with SolidJS. SolidJS uses referential integration of sub-objects to detect changes.\n      ...structuredClone(message),\n      // add a revision id to ensure that the message is updated with SWR. SWR uses a\n      // hashing approach by default to detect changes, but it only works for shallow\n      // changes. This is why we need to add a revision id to ensure that the message\n      // is updated with SWR (without it, the changes get stuck in SWR and are not\n      // forwarded to rendering):\n      revisionId: generateId(),\n    } as UIMessage;\n\n    update({\n      message: copiedMessage,\n      data: copiedData,\n      replaceLastMessage,\n    });\n  }\n\n  await processDataStream({\n    stream,\n    onTextPart(value) {\n      if (currentTextPart == null) {\n        currentTextPart = {\n          type: 'text',\n          text: value,\n        };\n        message.parts.push(currentTextPart);\n      } else {\n        currentTextPart.text += value;\n      }\n\n      message.content += value;\n      execUpdate();\n    },\n    onReasoningPart(value) {\n      if (currentReasoningTextDetail == null) {\n        currentReasoningTextDetail = { type: 'text', text: value };\n        if (currentReasoningPart != null) {\n          currentReasoningPart.details.push(currentReasoningTextDetail);\n        }\n      } else {\n        currentReasoningTextDetail.text += value;\n      }\n\n      if (currentReasoningPart == null) {\n        currentReasoningPart = {\n          type: 'reasoning',\n          reasoning: value,\n          details: [currentReasoningTextDetail],\n        };\n        message.parts.push(currentReasoningPart);\n      } else {\n        currentReasoningPart.reasoning += value;\n      }\n\n      message.reasoning = (message.reasoning ?? '') + value;\n\n      execUpdate();\n    },\n    onReasoningSignaturePart(value) {\n      if (currentReasoningTextDetail != null) {\n        currentReasoningTextDetail.signature = value.signature;\n      }\n    },\n    onRedactedReasoningPart(value) {\n      if (currentReasoningPart == null) {\n        currentReasoningPart = {\n          type: 'reasoning',\n          reasoning: '',\n          details: [],\n        };\n        message.parts.push(currentReasoningPart);\n      }\n\n      currentReasoningPart.details.push({\n        type: 'redacted',\n        data: value.data,\n      });\n\n      currentReasoningTextDetail = undefined;\n\n      execUpdate();\n    },\n    onFilePart(value) {\n      message.parts.push({\n        type: 'file',\n        mimeType: value.mimeType,\n        data: value.data,\n      });\n\n      execUpdate();\n    },\n    onSourcePart(value) {\n      message.parts.push({\n        type: 'source',\n        source: value,\n      });\n\n      execUpdate();\n    },\n    onToolCallStreamingStartPart(value) {\n      if (message.toolInvocations == null) {\n        message.toolInvocations = [];\n      }\n\n      // add the partial tool call to the map\n      partialToolCalls[value.toolCallId] = {\n        text: '',\n        step,\n        toolName: value.toolName,\n        index: message.toolInvocations.length,\n      };\n\n      const invocation = {\n        state: 'partial-call',\n        step,\n        toolCallId: value.toolCallId,\n        toolName: value.toolName,\n        args: undefined,\n      } as const;\n\n      message.toolInvocations.push(invocation);\n\n      updateToolInvocationPart(value.toolCallId, invocation);\n\n      execUpdate();\n    },\n    onToolCallDeltaPart(value) {\n      const partialToolCall = partialToolCalls[value.toolCallId];\n\n      partialToolCall.text += value.argsTextDelta;\n\n      const { value: partialArgs } = parsePartialJson(partialToolCall.text);\n\n      const invocation = {\n        state: 'partial-call',\n        step: partialToolCall.step,\n        toolCallId: value.toolCallId,\n        toolName: partialToolCall.toolName,\n        args: partialArgs,\n      } as const;\n\n      message.toolInvocations![partialToolCall.index] = invocation;\n\n      updateToolInvocationPart(value.toolCallId, invocation);\n\n      execUpdate();\n    },\n    async onToolCallPart(value) {\n      const invocation = {\n        state: 'call',\n        step,\n        ...value,\n      } as const;\n\n      if (partialToolCalls[value.toolCallId] != null) {\n        // change the partial tool call to a full tool call\n        message.toolInvocations![partialToolCalls[value.toolCallId].index] =\n          invocation;\n      } else {\n        if (message.toolInvocations == null) {\n          message.toolInvocations = [];\n        }\n\n        message.toolInvocations.push(invocation);\n      }\n\n      updateToolInvocationPart(value.toolCallId, invocation);\n\n      execUpdate();\n\n      // invoke the onToolCall callback if it exists. This is blocking.\n      // In the future we should make this non-blocking, which\n      // requires additional state management for error handling etc.\n      if (onToolCall) {\n        const result = await onToolCall({ toolCall: value });\n        if (result != null) {\n          const invocation = {\n            state: 'result',\n            step,\n            ...value,\n            result,\n          } as const;\n\n          // store the result in the tool invocation\n          message.toolInvocations![message.toolInvocations!.length - 1] =\n            invocation;\n\n          updateToolInvocationPart(value.toolCallId, invocation);\n\n          execUpdate();\n        }\n      }\n    },\n    onToolResultPart(value) {\n      const toolInvocations = message.toolInvocations;\n\n      if (toolInvocations == null) {\n        throw new Error('tool_result must be preceded by a tool_call');\n      }\n\n      // find if there is any tool invocation with the same toolCallId\n      // and replace it with the result\n      const toolInvocationIndex = toolInvocations.findIndex(\n        invocation => invocation.toolCallId === value.toolCallId,\n      );\n\n      if (toolInvocationIndex === -1) {\n        throw new Error(\n          'tool_result must be preceded by a tool_call with the same toolCallId',\n        );\n      }\n\n      const invocation = {\n        ...toolInvocations[toolInvocationIndex],\n        state: 'result' as const,\n        ...value,\n      } as const;\n\n      toolInvocations[toolInvocationIndex] = invocation;\n\n      updateToolInvocationPart(value.toolCallId, invocation);\n\n      execUpdate();\n    },\n    onDataPart(value) {\n      data.push(...value);\n      execUpdate();\n    },\n    onMessageAnnotationsPart(value) {\n      if (messageAnnotations == null) {\n        messageAnnotations = [...value];\n      } else {\n        messageAnnotations.push(...value);\n      }\n\n      execUpdate();\n    },\n    onFinishStepPart(value) {\n      step += 1;\n\n      // reset the current text and reasoning parts\n      currentTextPart = value.isContinued ? currentTextPart : undefined;\n      currentReasoningPart = undefined;\n      currentReasoningTextDetail = undefined;\n    },\n    onStartStepPart(value) {\n      // keep message id stable when we are updating an existing message:\n      if (!replaceLastMessage) {\n        message.id = value.messageId;\n      }\n\n      // add a step boundary part to the message\n      message.parts.push({ type: 'step-start' });\n      execUpdate();\n    },\n    onFinishMessagePart(value) {\n      finishReason = value.finishReason;\n      if (value.usage != null) {\n        usage = calculateLanguageModelUsage(value.usage);\n      }\n    },\n    onErrorPart(error) {\n      throw new Error(error);\n    },\n  });\n\n  onFinish?.({ message, finishReason, usage });\n}\n", "/**\nRepresents the number of tokens used in a prompt and completion.\n */\nexport type LanguageModelUsage = {\n  /**\nThe number of tokens used in the prompt.\n   */\n  promptTokens: number;\n\n  /**\nThe number of tokens used in the completion.\n */\n  completionTokens: number;\n\n  /**\nThe total number of tokens used (promptTokens + completionTokens).\n   */\n  totalTokens: number;\n};\n\n/**\nRepresents the number of tokens used in an embedding.\n */\nexport type EmbeddingModelUsage = {\n  /**\nThe number of tokens used in the embedding.\n   */\n  tokens: number;\n};\n\nexport function calculateLanguageModelUsage({\n  promptTokens,\n  completionTokens,\n}: {\n  promptTokens: number;\n  completionTokens: number;\n}): LanguageModelUsage {\n  return {\n    promptTokens,\n    completionTokens,\n    totalTokens: promptTokens + completionTokens,\n  };\n}\n", "import { JSONValue } from '@ai-sdk/provider';\nimport { safeParseJSON } from '@ai-sdk/provider-utils';\nimport { fixJson } from './fix-json';\n\nexport function parsePartialJson(jsonText: string | undefined): {\n  value: JSONValue | undefined;\n  state:\n    | 'undefined-input'\n    | 'successful-parse'\n    | 'repaired-parse'\n    | 'failed-parse';\n} {\n  if (jsonText === undefined) {\n    return { value: undefined, state: 'undefined-input' };\n  }\n\n  let result = safeParseJSON({ text: jsonText });\n\n  if (result.success) {\n    return { value: result.value, state: 'successful-parse' };\n  }\n\n  result = safeParseJSON({ text: fixJson(jsonText) });\n\n  if (result.success) {\n    return { value: result.value, state: 'repaired-parse' };\n  }\n\n  return { value: undefined, state: 'failed-parse' };\n}\n", "type State =\n  | 'ROOT'\n  | 'FINISH'\n  | 'INSIDE_STRING'\n  | 'INSIDE_STRING_ESCAPE'\n  | 'INSIDE_LITERAL'\n  | 'INSIDE_NUMBER'\n  | 'INSIDE_OBJECT_START'\n  | 'INSIDE_OBJECT_KEY'\n  | 'INSIDE_OBJECT_AFTER_KEY'\n  | 'INSIDE_OBJECT_BEFORE_VALUE'\n  | 'INSIDE_OBJECT_AFTER_VALUE'\n  | 'INSIDE_OBJECT_AFTER_COMMA'\n  | 'INSIDE_ARRAY_START'\n  | 'INSIDE_ARRAY_AFTER_VALUE'\n  | 'INSIDE_ARRAY_AFTER_COMMA';\n\n// Implemented as a scanner with additional fixing\n// that performs a single linear time scan pass over the partial JSON.\n//\n// The states should ideally match relevant states from the JSON spec:\n// https://www.json.org/json-en.html\n//\n// Please note that invalid JSON is not considered/covered, because it\n// is assumed that the resulting JSON will be processed by a standard\n// JSON parser that will detect any invalid JSON.\nexport function fixJson(input: string): string {\n  const stack: State[] = ['ROOT'];\n  let lastValidIndex = -1;\n  let literalStart: number | null = null;\n\n  function processValueStart(char: string, i: number, swapState: State) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_STRING');\n          break;\n        }\n\n        case 'f':\n        case 't':\n        case 'n': {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_LITERAL');\n          break;\n        }\n\n        case '-': {\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_NUMBER');\n          break;\n        }\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_NUMBER');\n          break;\n        }\n\n        case '{': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_OBJECT_START');\n          break;\n        }\n\n        case '[': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_ARRAY_START');\n          break;\n        }\n      }\n    }\n  }\n\n  function processAfterObjectValue(char: string, i: number) {\n    switch (char) {\n      case ',': {\n        stack.pop();\n        stack.push('INSIDE_OBJECT_AFTER_COMMA');\n        break;\n      }\n      case '}': {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n\n  function processAfterArrayValue(char: string, i: number) {\n    switch (char) {\n      case ',': {\n        stack.pop();\n        stack.push('INSIDE_ARRAY_AFTER_COMMA');\n        break;\n      }\n      case ']': {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n\n    switch (currentState) {\n      case 'ROOT':\n        processValueStart(char, i, 'FINISH');\n        break;\n\n      case 'INSIDE_OBJECT_START': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_KEY');\n            break;\n          }\n          case '}': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_COMMA': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_KEY');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_KEY': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_AFTER_KEY');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_KEY': {\n        switch (char) {\n          case ':': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_BEFORE_VALUE');\n\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_BEFORE_VALUE': {\n        processValueStart(char, i, 'INSIDE_OBJECT_AFTER_VALUE');\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_VALUE': {\n        processAfterObjectValue(char, i);\n        break;\n      }\n\n      case 'INSIDE_STRING': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n\n          case '\\\\': {\n            stack.push('INSIDE_STRING_ESCAPE');\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_ARRAY_START': {\n        switch (char) {\n          case ']': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, 'INSIDE_ARRAY_AFTER_VALUE');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_ARRAY_AFTER_VALUE': {\n        switch (char) {\n          case ',': {\n            stack.pop();\n            stack.push('INSIDE_ARRAY_AFTER_COMMA');\n            break;\n          }\n\n          case ']': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_ARRAY_AFTER_COMMA': {\n        processValueStart(char, i, 'INSIDE_ARRAY_AFTER_VALUE');\n        break;\n      }\n\n      case 'INSIDE_STRING_ESCAPE': {\n        stack.pop();\n        lastValidIndex = i;\n\n        break;\n      }\n\n      case 'INSIDE_NUMBER': {\n        switch (char) {\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9': {\n            lastValidIndex = i;\n            break;\n          }\n\n          case 'e':\n          case 'E':\n          case '-':\n          case '.': {\n            break;\n          }\n\n          case ',': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n              processAfterArrayValue(char, i);\n            }\n\n            if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n              processAfterObjectValue(char, i);\n            }\n\n            break;\n          }\n\n          case '}': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n              processAfterObjectValue(char, i);\n            }\n\n            break;\n          }\n\n          case ']': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n              processAfterArrayValue(char, i);\n            }\n\n            break;\n          }\n\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_LITERAL': {\n        const partialLiteral = input.substring(literalStart!, i + 1);\n\n        if (\n          !'false'.startsWith(partialLiteral) &&\n          !'true'.startsWith(partialLiteral) &&\n          !'null'.startsWith(partialLiteral)\n        ) {\n          stack.pop();\n\n          if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n\n        break;\n      }\n    }\n  }\n\n  let result = input.slice(0, lastValidIndex + 1);\n\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n\n    switch (state) {\n      case 'INSIDE_STRING': {\n        result += '\"';\n        break;\n      }\n\n      case 'INSIDE_OBJECT_KEY':\n      case 'INSIDE_OBJECT_AFTER_KEY':\n      case 'INSIDE_OBJECT_AFTER_COMMA':\n      case 'INSIDE_OBJECT_START':\n      case 'INSIDE_OBJECT_BEFORE_VALUE':\n      case 'INSIDE_OBJECT_AFTER_VALUE': {\n        result += '}';\n        break;\n      }\n\n      case 'INSIDE_ARRAY_START':\n      case 'INSIDE_ARRAY_AFTER_COMMA':\n      case 'INSIDE_ARRAY_AFTER_VALUE': {\n        result += ']';\n        break;\n      }\n\n      case 'INSIDE_LITERAL': {\n        const partialLiteral = input.substring(literalStart!, input.length);\n\n        if ('true'.startsWith(partialLiteral)) {\n          result += 'true'.slice(partialLiteral.length);\n        } else if ('false'.startsWith(partialLiteral)) {\n          result += 'false'.slice(partialLiteral.length);\n        } else if ('null'.startsWith(partialLiteral)) {\n          result += 'null'.slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n", "import {\n  LanguageModelV1FinishReason,\n  LanguageModelV1Source,\n} from '@ai-sdk/provider';\nimport { ToolCall, ToolResult } from '@ai-sdk/provider-utils';\nimport { JSONValue } from './types';\n\nexport type DataStreamString =\n  `${(typeof DataStreamStringPrefixes)[keyof typeof DataStreamStringPrefixes]}:${string}\\n`;\n\nexport interface DataStreamPart<\n  CODE extends string,\n  NAME extends string,\n  TYPE,\n> {\n  code: CODE;\n  name: NAME;\n  parse: (value: JSONValue) => { type: NAME; value: TYPE };\n}\n\nconst textStreamPart: DataStreamPart<'0', 'text', string> = {\n  code: '0',\n  name: 'text',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: 'text', value };\n  },\n};\n\nconst dataStreamPart: DataStreamPart<'2', 'data', Array<JSONValue>> = {\n  code: '2',\n  name: 'data',\n  parse: (value: JSONValue) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"data\" parts expect an array value.');\n    }\n\n    return { type: 'data', value };\n  },\n};\n\nconst errorStreamPart: DataStreamPart<'3', 'error', string> = {\n  code: '3',\n  name: 'error',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: 'error', value };\n  },\n};\n\nconst messageAnnotationsStreamPart: DataStreamPart<\n  '8',\n  'message_annotations',\n  Array<JSONValue>\n> = {\n  code: '8',\n  name: 'message_annotations',\n  parse: (value: JSONValue) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"message_annotations\" parts expect an array value.');\n    }\n\n    return { type: 'message_annotations', value };\n  },\n};\n\nconst toolCallStreamPart: DataStreamPart<\n  '9',\n  'tool_call',\n  ToolCall<string, any>\n> = {\n  code: '9',\n  name: 'tool_call',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('toolName' in value) ||\n      typeof value.toolName !== 'string' ||\n      !('args' in value) ||\n      typeof value.args !== 'object'\n    ) {\n      throw new Error(\n        '\"tool_call\" parts expect an object with a \"toolCallId\", \"toolName\", and \"args\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call',\n      value: value as unknown as ToolCall<string, any>,\n    };\n  },\n};\n\nconst toolResultStreamPart: DataStreamPart<\n  'a',\n  'tool_result',\n  Omit<ToolResult<string, any, any>, 'args' | 'toolName'>\n> = {\n  code: 'a',\n  name: 'tool_result',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('result' in value)\n    ) {\n      throw new Error(\n        '\"tool_result\" parts expect an object with a \"toolCallId\" and a \"result\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_result',\n      value: value as unknown as Omit<\n        ToolResult<string, any, any>,\n        'args' | 'toolName'\n      >,\n    };\n  },\n};\n\nconst toolCallStreamingStartStreamPart: DataStreamPart<\n  'b',\n  'tool_call_streaming_start',\n  { toolCallId: string; toolName: string }\n> = {\n  code: 'b',\n  name: 'tool_call_streaming_start',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('toolName' in value) ||\n      typeof value.toolName !== 'string'\n    ) {\n      throw new Error(\n        '\"tool_call_streaming_start\" parts expect an object with a \"toolCallId\" and \"toolName\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call_streaming_start',\n      value: value as unknown as { toolCallId: string; toolName: string },\n    };\n  },\n};\n\nconst toolCallDeltaStreamPart: DataStreamPart<\n  'c',\n  'tool_call_delta',\n  { toolCallId: string; argsTextDelta: string }\n> = {\n  code: 'c',\n  name: 'tool_call_delta',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('argsTextDelta' in value) ||\n      typeof value.argsTextDelta !== 'string'\n    ) {\n      throw new Error(\n        '\"tool_call_delta\" parts expect an object with a \"toolCallId\" and \"argsTextDelta\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call_delta',\n      value: value as unknown as {\n        toolCallId: string;\n        argsTextDelta: string;\n      },\n    };\n  },\n};\n\nconst finishMessageStreamPart: DataStreamPart<\n  'd',\n  'finish_message',\n  {\n    finishReason: LanguageModelV1FinishReason;\n    // TODO v5 remove usage from finish event (only on step-finish)\n    usage?: {\n      promptTokens: number;\n      completionTokens: number;\n    };\n  }\n> = {\n  code: 'd',\n  name: 'finish_message',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('finishReason' in value) ||\n      typeof value.finishReason !== 'string'\n    ) {\n      throw new Error(\n        '\"finish_message\" parts expect an object with a \"finishReason\" property.',\n      );\n    }\n\n    const result: {\n      finishReason: LanguageModelV1FinishReason;\n      usage?: {\n        promptTokens: number;\n        completionTokens: number;\n      };\n    } = {\n      finishReason: value.finishReason as LanguageModelV1FinishReason,\n    };\n\n    if (\n      'usage' in value &&\n      value.usage != null &&\n      typeof value.usage === 'object' &&\n      'promptTokens' in value.usage &&\n      'completionTokens' in value.usage\n    ) {\n      result.usage = {\n        promptTokens:\n          typeof value.usage.promptTokens === 'number'\n            ? value.usage.promptTokens\n            : Number.NaN,\n        completionTokens:\n          typeof value.usage.completionTokens === 'number'\n            ? value.usage.completionTokens\n            : Number.NaN,\n      };\n    }\n\n    return {\n      type: 'finish_message',\n      value: result,\n    };\n  },\n};\n\nconst finishStepStreamPart: DataStreamPart<\n  'e',\n  'finish_step',\n  {\n    isContinued: boolean;\n    finishReason: LanguageModelV1FinishReason;\n    usage?: {\n      promptTokens: number;\n      completionTokens: number;\n    };\n  }\n> = {\n  code: 'e',\n  name: 'finish_step',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('finishReason' in value) ||\n      typeof value.finishReason !== 'string'\n    ) {\n      throw new Error(\n        '\"finish_step\" parts expect an object with a \"finishReason\" property.',\n      );\n    }\n\n    const result: {\n      isContinued: boolean;\n      finishReason: LanguageModelV1FinishReason;\n      usage?: {\n        promptTokens: number;\n        completionTokens: number;\n      };\n    } = {\n      finishReason: value.finishReason as LanguageModelV1FinishReason,\n      isContinued: false,\n    };\n\n    if (\n      'usage' in value &&\n      value.usage != null &&\n      typeof value.usage === 'object' &&\n      'promptTokens' in value.usage &&\n      'completionTokens' in value.usage\n    ) {\n      result.usage = {\n        promptTokens:\n          typeof value.usage.promptTokens === 'number'\n            ? value.usage.promptTokens\n            : Number.NaN,\n        completionTokens:\n          typeof value.usage.completionTokens === 'number'\n            ? value.usage.completionTokens\n            : Number.NaN,\n      };\n    }\n\n    if ('isContinued' in value && typeof value.isContinued === 'boolean') {\n      result.isContinued = value.isContinued;\n    }\n\n    return {\n      type: 'finish_step',\n      value: result,\n    };\n  },\n};\n\nconst startStepStreamPart: DataStreamPart<\n  'f',\n  'start_step',\n  {\n    messageId: string;\n  }\n> = {\n  code: 'f',\n  name: 'start_step',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('messageId' in value) ||\n      typeof value.messageId !== 'string'\n    ) {\n      throw new Error(\n        '\"start_step\" parts expect an object with an \"id\" property.',\n      );\n    }\n\n    return {\n      type: 'start_step',\n      value: {\n        messageId: value.messageId,\n      },\n    };\n  },\n};\n\nconst reasoningStreamPart: DataStreamPart<'g', 'reasoning', string> = {\n  code: 'g',\n  name: 'reasoning',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"reasoning\" parts expect a string value.');\n    }\n    return { type: 'reasoning', value };\n  },\n};\n\nconst sourcePart: DataStreamPart<'h', 'source', LanguageModelV1Source> = {\n  code: 'h',\n  name: 'source',\n  parse: (value: JSONValue) => {\n    if (value == null || typeof value !== 'object') {\n      throw new Error('\"source\" parts expect a Source object.');\n    }\n\n    return {\n      type: 'source',\n      value: value as LanguageModelV1Source,\n    };\n  },\n};\n\nconst redactedReasoningStreamPart: DataStreamPart<\n  'i',\n  'redacted_reasoning',\n  { data: string }\n> = {\n  code: 'i',\n  name: 'redacted_reasoning',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('data' in value) ||\n      typeof value.data !== 'string'\n    ) {\n      throw new Error(\n        '\"redacted_reasoning\" parts expect an object with a \"data\" property.',\n      );\n    }\n    return { type: 'redacted_reasoning', value: { data: value.data } };\n  },\n};\n\nconst reasoningSignatureStreamPart: DataStreamPart<\n  'j',\n  'reasoning_signature',\n  { signature: string }\n> = {\n  code: 'j',\n  name: 'reasoning_signature',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('signature' in value) ||\n      typeof value.signature !== 'string'\n    ) {\n      throw new Error(\n        '\"reasoning_signature\" parts expect an object with a \"signature\" property.',\n      );\n    }\n    return {\n      type: 'reasoning_signature',\n      value: { signature: value.signature },\n    };\n  },\n};\n\nconst fileStreamPart: DataStreamPart<\n  'k',\n  'file',\n  {\n    data: string; // base64 encoded data\n    mimeType: string;\n  }\n> = {\n  code: 'k',\n  name: 'file',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('data' in value) ||\n      typeof value.data !== 'string' ||\n      !('mimeType' in value) ||\n      typeof value.mimeType !== 'string'\n    ) {\n      throw new Error(\n        '\"file\" parts expect an object with a \"data\" and \"mimeType\" property.',\n      );\n    }\n    return { type: 'file', value: value as { data: string; mimeType: string } };\n  },\n};\n\nconst dataStreamParts = [\n  textStreamPart,\n  dataStreamPart,\n  errorStreamPart,\n  messageAnnotationsStreamPart,\n  toolCallStreamPart,\n  toolResultStreamPart,\n  toolCallStreamingStartStreamPart,\n  toolCallDeltaStreamPart,\n  finishMessageStreamPart,\n  finishStepStreamPart,\n  startStepStreamPart,\n  reasoningStreamPart,\n  sourcePart,\n  redactedReasoningStreamPart,\n  reasoningSignatureStreamPart,\n  fileStreamPart,\n] as const;\n\nexport const dataStreamPartsByCode = Object.fromEntries(\n  dataStreamParts.map(part => [part.code, part]),\n) as {\n  [K in (typeof dataStreamParts)[number]['code']]: (typeof dataStreamParts)[number];\n};\n\ntype DataStreamParts = (typeof dataStreamParts)[number];\n\n/**\n * Maps the type of a stream part to its value type.\n */\ntype DataStreamPartValueType = {\n  [P in DataStreamParts as P['name']]: ReturnType<P['parse']>['value'];\n};\n\nexport type DataStreamPartType = ReturnType<DataStreamParts['parse']>;\n\n/**\n * The map of prefixes for data in the stream\n *\n * - 0: Text from the LLM response\n * - 1: (OpenAI) function_call responses\n * - 2: custom JSON added by the user using `Data`\n * - 6: (OpenAI) tool_call responses\n *\n * Example:\n * ```\n * 0:Vercel\n * 0:'s\n * 0: AI\n * 0: AI\n * 0: SDK\n * 0: is great\n * 0:!\n * 2: { \"someJson\": \"value\" }\n * 1: {\"function_call\": {\"name\": \"get_current_weather\", \"arguments\": \"{\\\\n\\\\\"location\\\\\": \\\\\"Charlottesville, Virginia\\\\\",\\\\n\\\\\"format\\\\\": \\\\\"celsius\\\\\"\\\\n}\"}}\n * 6: {\"tool_call\": {\"id\": \"tool_0\", \"type\": \"function\", \"function\": {\"name\": \"get_current_weather\", \"arguments\": \"{\\\\n\\\\\"location\\\\\": \\\\\"Charlottesville, Virginia\\\\\",\\\\n\\\\\"format\\\\\": \\\\\"celsius\\\\\"\\\\n}\"}}}\n *```\n */\nexport const DataStreamStringPrefixes = Object.fromEntries(\n  dataStreamParts.map(part => [part.name, part.code]),\n) as {\n  [K in DataStreamParts['name']]: (typeof dataStreamParts)[number]['code'];\n};\n\nexport const validCodes = dataStreamParts.map(part => part.code);\n\n/**\nParses a stream part from a string.\n\n@param line The string to parse.\n@returns The parsed stream part.\n@throws An error if the string cannot be parsed.\n */\nexport const parseDataStreamPart = (line: string): DataStreamPartType => {\n  const firstSeparatorIndex = line.indexOf(':');\n\n  if (firstSeparatorIndex === -1) {\n    throw new Error('Failed to parse stream string. No separator found.');\n  }\n\n  const prefix = line.slice(0, firstSeparatorIndex);\n\n  if (!validCodes.includes(prefix as keyof typeof dataStreamPartsByCode)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n\n  const code = prefix as keyof typeof dataStreamPartsByCode;\n\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue: JSONValue = JSON.parse(textValue);\n\n  return dataStreamPartsByCode[code].parse(jsonValue);\n};\n\n/**\nPrepends a string with a prefix from the `StreamChunkPrefixes`, JSON-ifies it,\nand appends a new line.\n\nIt ensures type-safety for the part type and value.\n */\nexport function formatDataStreamPart<T extends keyof DataStreamPartValueType>(\n  type: T,\n  value: DataStreamPartValueType[T],\n): DataStreamString {\n  const streamPart = dataStreamParts.find(part => part.name === type);\n\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n\n  return `${streamPart.code}:${JSON.stringify(value)}\\n`;\n}\n", "import { DataStreamPartType, parseDataStreamPart } from './data-stream-parts';\n\nconst NEWLINE = '\\n'.charCodeAt(0);\n\n// concatenates all the chunks into a single Uint8Array\nfunction concatChunks(chunks: Uint8Array[], totalLength: number) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n\n  return concatenatedChunks;\n}\n\nexport async function processDataStream({\n  stream,\n  onTextPart,\n  onReasoningPart,\n  onReasoningSignaturePart,\n  onRedactedReasoningPart,\n  onSourcePart,\n  onFilePart,\n  onDataPart,\n  onErrorPart,\n  onToolCallStreamingStartPart,\n  onToolCallDeltaPart,\n  onToolCallPart,\n  onToolResultPart,\n  onMessageAnnotationsPart,\n  onFinishMessagePart,\n  onFinishStepPart,\n  onStartStepPart,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  onTextPart?: (\n    streamPart: (DataStreamPartType & { type: 'text' })['value'],\n  ) => Promise<void> | void;\n  onReasoningPart?: (\n    streamPart: (DataStreamPartType & { type: 'reasoning' })['value'],\n  ) => Promise<void> | void;\n  onReasoningSignaturePart?: (\n    streamPart: (DataStreamPartType & { type: 'reasoning_signature' })['value'],\n  ) => Promise<void> | void;\n  onRedactedReasoningPart?: (\n    streamPart: (DataStreamPartType & { type: 'redacted_reasoning' })['value'],\n  ) => Promise<void> | void;\n  onFilePart?: (\n    streamPart: (DataStreamPartType & { type: 'file' })['value'],\n  ) => Promise<void> | void;\n  onSourcePart?: (\n    streamPart: (DataStreamPartType & { type: 'source' })['value'],\n  ) => Promise<void> | void;\n  onDataPart?: (\n    streamPart: (DataStreamPartType & { type: 'data' })['value'],\n  ) => Promise<void> | void;\n  onErrorPart?: (\n    streamPart: (DataStreamPartType & { type: 'error' })['value'],\n  ) => Promise<void> | void;\n  onToolCallStreamingStartPart?: (\n    streamPart: (DataStreamPartType & {\n      type: 'tool_call_streaming_start';\n    })['value'],\n  ) => Promise<void> | void;\n  onToolCallDeltaPart?: (\n    streamPart: (DataStreamPartType & { type: 'tool_call_delta' })['value'],\n  ) => Promise<void> | void;\n  onToolCallPart?: (\n    streamPart: (DataStreamPartType & { type: 'tool_call' })['value'],\n  ) => Promise<void> | void;\n  onToolResultPart?: (\n    streamPart: (DataStreamPartType & { type: 'tool_result' })['value'],\n  ) => Promise<void> | void;\n  onMessageAnnotationsPart?: (\n    streamPart: (DataStreamPartType & {\n      type: 'message_annotations';\n    })['value'],\n  ) => Promise<void> | void;\n  onFinishMessagePart?: (\n    streamPart: (DataStreamPartType & { type: 'finish_message' })['value'],\n  ) => Promise<void> | void;\n  onFinishStepPart?: (\n    streamPart: (DataStreamPartType & { type: 'finish_step' })['value'],\n  ) => Promise<void> | void;\n  onStartStepPart?: (\n    streamPart: (DataStreamPartType & { type: 'start_step' })['value'],\n  ) => Promise<void> | void;\n}): Promise<void> {\n  // implementation note: this slightly more complex algorithm is required\n  // to pass the tests in the edge environment.\n\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  const chunks: Uint8Array[] = [];\n  let totalLength = 0;\n\n  while (true) {\n    const { value } = await reader.read();\n\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        // if the last character is not a newline, we have not read the whole JSON value\n        continue;\n      }\n    }\n\n    if (chunks.length === 0) {\n      break; // we have reached the end of the stream\n    }\n\n    const concatenatedChunks = concatChunks(chunks, totalLength);\n    totalLength = 0;\n\n    const streamParts = decoder\n      .decode(concatenatedChunks, { stream: true })\n      .split('\\n')\n      .filter(line => line !== '') // splitting leaves an empty string at the end\n      .map(parseDataStreamPart);\n\n    for (const { type, value } of streamParts) {\n      switch (type) {\n        case 'text':\n          await onTextPart?.(value);\n          break;\n        case 'reasoning':\n          await onReasoningPart?.(value);\n          break;\n        case 'reasoning_signature':\n          await onReasoningSignaturePart?.(value);\n          break;\n        case 'redacted_reasoning':\n          await onRedactedReasoningPart?.(value);\n          break;\n        case 'file':\n          await onFilePart?.(value);\n          break;\n        case 'source':\n          await onSourcePart?.(value);\n          break;\n        case 'data':\n          await onDataPart?.(value);\n          break;\n        case 'error':\n          await onErrorPart?.(value);\n          break;\n        case 'message_annotations':\n          await onMessageAnnotationsPart?.(value);\n          break;\n        case 'tool_call_streaming_start':\n          await onToolCallStreamingStartPart?.(value);\n          break;\n        case 'tool_call_delta':\n          await onToolCallDeltaPart?.(value);\n          break;\n        case 'tool_call':\n          await onToolCallPart?.(value);\n          break;\n        case 'tool_result':\n          await onToolResultPart?.(value);\n          break;\n        case 'finish_message':\n          await onFinishMessagePart?.(value);\n          break;\n        case 'finish_step':\n          await onFinishStepPart?.(value);\n          break;\n        case 'start_step':\n          await onStartStepPart?.(value);\n          break;\n        default: {\n          const exhaustiveCheck: never = type;\n          throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);\n        }\n      }\n    }\n  }\n}\n", "import { JSONValue } from '@ai-sdk/provider';\nimport { generateId as generateIdFunction } from '@ai-sdk/provider-utils';\nimport { processTextStream } from './process-text-stream';\nimport { TextUIPart, UIMessage, UseChatOptions } from './types';\n\nexport async function processChatTextResponse({\n  stream,\n  update,\n  onFinish,\n  getCurrentDate = () => new Date(),\n  generateId = generateIdFunction,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  update: (options: {\n    message: UIMessage;\n    data: JSONValue[] | undefined;\n    replaceLastMessage: boolean;\n  }) => void;\n  onFinish: UseChatOptions['onFinish'];\n  getCurrentDate?: () => Date;\n  generateId?: () => string;\n}) {\n  const textPart: TextUIPart = { type: 'text', text: '' };\n\n  const resultMessage: UIMessage = {\n    id: generateId(),\n    createdAt: getCurrentDate(),\n    role: 'assistant' as const,\n    content: '',\n    parts: [textPart],\n  };\n\n  await processTextStream({\n    stream,\n    onTextPart: chunk => {\n      resultMessage.content += chunk;\n      textPart.text += chunk;\n\n      // note: creating a new message object is required for Solid.js streaming\n      update({\n        message: { ...resultMessage },\n        data: [],\n        replaceLastMessage: false,\n      });\n    },\n  });\n\n  // in text mode, we don't have usage information or finish reason:\n  onFinish?.(resultMessage, {\n    usage: { completionTokens: NaN, promptTokens: NaN, totalTokens: NaN },\n    finishReason: 'unknown',\n  });\n}\n", "export async function processTextStream({\n  stream,\n  onTextPart,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  onTextPart: (chunk: string) => Promise<void> | void;\n}): Promise<void> {\n  const reader = stream.pipeThrough(new TextDecoderStream()).getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    await onTextPart(value);\n  }\n}\n", "import { processChatResponse } from './process-chat-response';\nimport { processChatTextResponse } from './process-chat-text-response';\nimport { IdGenerator, JSONValue, UIMessage, UseChatOptions } from './types';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => fetch;\n\nexport async function callChatApi({\n  api,\n  body,\n  streamProtocol = 'data',\n  credentials,\n  headers,\n  abortController,\n  restoreMessagesOnFailure,\n  onResponse,\n  onUpdate,\n  onFinish,\n  onToolCall,\n  generateId,\n  fetch = getOriginalFetch(),\n  lastMessage,\n  requestType = 'generate',\n}: {\n  api: string;\n  body: Record<string, any>;\n  streamProtocol: 'data' | 'text' | undefined;\n  credentials: RequestCredentials | undefined;\n  headers: HeadersInit | undefined;\n  abortController: (() => AbortController | null) | undefined;\n  restoreMessagesOnFailure: () => void;\n  onResponse: ((response: Response) => void | Promise<void>) | undefined;\n  onUpdate: (options: {\n    message: UIMessage;\n    data: JSONValue[] | undefined;\n    replaceLastMessage: boolean;\n  }) => void;\n  onFinish: UseChatOptions['onFinish'];\n  onToolCall: UseChatOptions['onToolCall'];\n  generateId: IdGenerator;\n  fetch: ReturnType<typeof getOriginalFetch> | undefined;\n  lastMessage: UIMessage | undefined;\n  requestType?: 'generate' | 'resume';\n}) {\n  const request =\n    requestType === 'resume'\n      ? fetch(`${api}?chatId=${body.id}`, {\n          method: 'GET',\n          headers: {\n            'Content-Type': 'application/json',\n            ...headers,\n          },\n          signal: abortController?.()?.signal,\n          credentials,\n        })\n      : fetch(api, {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: {\n            'Content-Type': 'application/json',\n            ...headers,\n          },\n          signal: abortController?.()?.signal,\n          credentials,\n        });\n\n  const response = await request.catch(err => {\n    restoreMessagesOnFailure();\n    throw err;\n  });\n\n  if (onResponse) {\n    try {\n      await onResponse(response);\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  if (!response.ok) {\n    restoreMessagesOnFailure();\n    throw new Error(\n      (await response.text()) ?? 'Failed to fetch the chat response.',\n    );\n  }\n\n  if (!response.body) {\n    throw new Error('The response body is empty.');\n  }\n\n  switch (streamProtocol) {\n    case 'text': {\n      await processChatTextResponse({\n        stream: response.body,\n        update: onUpdate,\n        onFinish,\n        generateId,\n      });\n      return;\n    }\n\n    case 'data': {\n      await processChatResponse({\n        stream: response.body,\n        update: onUpdate,\n        lastMessage,\n        onToolCall,\n        onFinish({ message, finishReason, usage }) {\n          if (onFinish && message != null) {\n            onFinish(message, { usage, finishReason });\n          }\n        },\n        generateId,\n      });\n      return;\n    }\n\n    default: {\n      const exhaustiveCheck: never = streamProtocol;\n      throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n    }\n  }\n}\n", "import { processTextStream } from './process-text-stream';\nimport { processDataStream } from './process-data-stream';\nimport { JSONValue } from './types';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => fetch;\n\nexport async function callCompletionApi({\n  api,\n  prompt,\n  credentials,\n  headers,\n  body,\n  streamProtocol = 'data',\n  setCompletion,\n  setLoading,\n  setError,\n  setAbortController,\n  onResponse,\n  onFinish,\n  onError,\n  onData,\n  fetch = getOriginalFetch(),\n}: {\n  api: string;\n  prompt: string;\n  credentials: RequestCredentials | undefined;\n  headers: HeadersInit | undefined;\n  body: Record<string, any>;\n  streamProtocol: 'data' | 'text' | undefined;\n  setCompletion: (completion: string) => void;\n  setLoading: (loading: boolean) => void;\n  setError: (error: Error | undefined) => void;\n  setAbortController: (abortController: AbortController | null) => void;\n  onResponse: ((response: Response) => void | Promise<void>) | undefined;\n  onFinish: ((prompt: string, completion: string) => void) | undefined;\n  onError: ((error: Error) => void) | undefined;\n  onData: ((data: JSONValue[]) => void) | undefined;\n  fetch: ReturnType<typeof getOriginalFetch> | undefined;\n}) {\n  try {\n    setLoading(true);\n    setError(undefined);\n\n    const abortController = new AbortController();\n    setAbortController(abortController);\n\n    // Empty the completion immediately.\n    setCompletion('');\n\n    const response = await fetch(api, {\n      method: 'POST',\n      body: JSON.stringify({\n        prompt,\n        ...body,\n      }),\n      credentials,\n      headers: {\n        'Content-Type': 'application/json',\n        ...headers,\n      },\n      signal: abortController.signal,\n    }).catch(err => {\n      throw err;\n    });\n\n    if (onResponse) {\n      try {\n        await onResponse(response);\n      } catch (err) {\n        throw err;\n      }\n    }\n\n    if (!response.ok) {\n      throw new Error(\n        (await response.text()) ?? 'Failed to fetch the chat response.',\n      );\n    }\n\n    if (!response.body) {\n      throw new Error('The response body is empty.');\n    }\n\n    let result = '';\n\n    switch (streamProtocol) {\n      case 'text': {\n        await processTextStream({\n          stream: response.body,\n          onTextPart: chunk => {\n            result += chunk;\n            setCompletion(result);\n          },\n        });\n        break;\n      }\n      case 'data': {\n        await processDataStream({\n          stream: response.body,\n          onTextPart(value) {\n            result += value;\n            setCompletion(result);\n          },\n          onDataPart(value) {\n            onData?.(value);\n          },\n          onErrorPart(value) {\n            throw new Error(value);\n          },\n        });\n        break;\n      }\n      default: {\n        const exhaustiveCheck: never = streamProtocol;\n        throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n      }\n    }\n\n    if (onFinish) {\n      onFinish(prompt, result);\n    }\n\n    setAbortController(null);\n    return result;\n  } catch (err) {\n    // Ignore abort errors as they are expected.\n    if ((err as any).name === 'AbortError') {\n      setAbortController(null);\n      return null;\n    }\n\n    if (err instanceof Error) {\n      if (onError) {\n        onError(err);\n      }\n    }\n\n    setError(err as Error);\n  } finally {\n    setLoading(false);\n  }\n}\n", "/**\n * Converts a data URL of type text/* to a text string.\n */\nexport function getTextFromDataUrl(dataUrl: string): string {\n  const [header, base64Content] = dataUrl.split(',');\n  const mimeType = header.split(';')[0].split(':')[1];\n\n  if (mimeType == null || base64Content == null) {\n    throw new Error('Invalid data URL format');\n  }\n\n  try {\n    return window.atob(base64Content);\n  } catch (error) {\n    throw new Error(`Error decoding data URL`);\n  }\n}\n", "import { ToolInvocation } from './types';\n\nexport function extractMaxToolInvocationStep(\n  toolInvocations: ToolInvocation[] | undefined,\n): number | undefined {\n  return toolInvocations?.reduce((max, toolInvocation) => {\n    return Math.max(max, toolInvocation.step ?? 0);\n  }, 0);\n}\n", "import {\n  CreateMessage,\n  FileUIPart,\n  Message,\n  ReasoningUIPart,\n  SourceUIPart,\n  StepStartUIPart,\n  TextUIPart,\n  ToolInvocationUIPart,\n  UIMessage,\n} from './types';\n\nexport function getMessageParts(\n  message: Message | CreateMessage | UIMessage,\n): (\n  | TextUIPart\n  | ReasoningUIPart\n  | ToolInvocationUIPart\n  | SourceUIPart\n  | FileUIPart\n  | StepStartUIPart\n)[] {\n  return (\n    message.parts ?? [\n      ...(message.toolInvocations\n        ? message.toolInvocations.map(toolInvocation => ({\n            type: 'tool-invocation' as const,\n            toolInvocation,\n          }))\n        : []),\n      ...(message.reasoning\n        ? [\n            {\n              type: 'reasoning' as const,\n              reasoning: message.reasoning,\n              details: [{ type: 'text' as const, text: message.reasoning }],\n            },\n          ]\n        : []),\n      ...(message.content\n        ? [{ type: 'text' as const, text: message.content }]\n        : []),\n    ]\n  );\n}\n", "import { getMessageParts } from './get-message-parts';\nimport { Message, UIMessage } from './types';\n\nexport function fillMessageParts(messages: Message[]): UIMessage[] {\n  return messages.map(message => ({\n    ...message,\n    parts: getMessageParts(message),\n  }));\n}\n", "/**\n * Performs a deep-equal comparison of two parsed JSON objects.\n *\n * @param {any} obj1 - The first object to compare.\n * @param {any} obj2 - The second object to compare.\n * @returns {boolean} - Returns true if the two objects are deeply equal, false otherwise.\n */\nexport function isDeepEqualData(obj1: any, obj2: any): boolean {\n  // Check for strict equality first\n  if (obj1 === obj2) return true;\n\n  // Check if either is null or undefined\n  if (obj1 == null || obj2 == null) return false;\n\n  // Check if both are objects\n  if (typeof obj1 !== 'object' && typeof obj2 !== 'object')\n    return obj1 === obj2;\n\n  // If they are not strictly equal, they both need to be Objects\n  if (obj1.constructor !== obj2.constructor) return false;\n\n  // Special handling for Date objects\n  if (obj1 instanceof Date && obj2 instanceof Date) {\n    return obj1.getTime() === obj2.getTime();\n  }\n\n  // Handle arrays: compare length and then perform a recursive deep comparison on each item\n  if (Array.isArray(obj1)) {\n    if (obj1.length !== obj2.length) return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqualData(obj1[i], obj2[i])) return false;\n    }\n    return true; // All array elements matched\n  }\n\n  // Compare the set of keys in each object\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length) return false;\n\n  // Check each key-value pair recursively\n  for (const key of keys1) {\n    if (!keys2.includes(key)) return false;\n    if (!isDeepEqualData(obj1[key], obj2[key])) return false;\n  }\n\n  return true; // All keys and values matched\n}\n", "import { Attachment } from './types';\n\nexport async function prepareAttachmentsForRequest(\n  attachmentsFromOptions: FileList | Array<Attachment> | undefined,\n) {\n  if (!attachmentsFromOptions) {\n    return [];\n  }\n\n  // https://github.com/vercel/ai/pull/6045\n  // React-native doesn't have a FileList\n  // global variable, so we need to check for it\n  if (\n    globalThis.FileList &&\n    attachmentsFromOptions instanceof globalThis.FileList\n  ) {\n    return Promise.all(\n      Array.from(attachmentsFromOptions).map(async attachment => {\n        const { name, type } = attachment;\n\n        const dataUrl = await new Promise<string>((resolve, reject) => {\n          const reader = new FileReader();\n          reader.onload = readerEvent => {\n            resolve(readerEvent.target?.result as string);\n          };\n          reader.onerror = error => reject(error);\n          reader.readAsDataURL(attachment);\n        });\n\n        return {\n          name,\n          contentType: type,\n          url: dataUrl,\n        };\n      }),\n    );\n  }\n\n  if (Array.isArray(attachmentsFromOptions)) {\n    return attachmentsFromOptions;\n  }\n\n  throw new Error('Invalid attachments type');\n}\n", "import {\n  AssistantStreamPartType,\n  parseAssistantStreamPart,\n} from './assistant-stream-parts';\n\nconst NEWLINE = '\\n'.charCodeAt(0);\n\n// concatenates all the chunks into a single Uint8Array\nfunction concatChunks(chunks: Uint8Array[], totalLength: number) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n\n  return concatenatedChunks;\n}\n\nexport async function processAssistantStream({\n  stream,\n  onTextPart,\n  onErrorPart,\n  onAssistantMessagePart,\n  onAssistantControlDataPart,\n  onDataMessagePart,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  onTextPart?: (\n    streamPart: (AssistantStreamPartType & { type: 'text' })['value'],\n  ) => Promise<void> | void;\n  onErrorPart?: (\n    streamPart: (AssistantStreamPartType & { type: 'error' })['value'],\n  ) => Promise<void> | void;\n  onAssistantMessagePart?: (\n    streamPart: (AssistantStreamPartType & {\n      type: 'assistant_message';\n    })['value'],\n  ) => Promise<void> | void;\n  onAssistantControlDataPart?: (\n    streamPart: (AssistantStreamPartType & {\n      type: 'assistant_control_data';\n    })['value'],\n  ) => Promise<void> | void;\n  onDataMessagePart?: (\n    streamPart: (AssistantStreamPartType & { type: 'data_message' })['value'],\n  ) => Promise<void> | void;\n}): Promise<void> {\n  // implementation note: this slightly more complex algorithm is required\n  // to pass the tests in the edge environment.\n\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  const chunks: Uint8Array[] = [];\n  let totalLength = 0;\n\n  while (true) {\n    const { value } = await reader.read();\n\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        // if the last character is not a newline, we have not read the whole JSON value\n        continue;\n      }\n    }\n\n    if (chunks.length === 0) {\n      break; // we have reached the end of the stream\n    }\n\n    const concatenatedChunks = concatChunks(chunks, totalLength);\n    totalLength = 0;\n\n    const streamParts = decoder\n      .decode(concatenatedChunks, { stream: true })\n      .split('\\n')\n      .filter(line => line !== '')\n      .map(parseAssistantStreamPart);\n\n    for (const { type, value } of streamParts) {\n      switch (type) {\n        case 'text':\n          await onTextPart?.(value);\n          break;\n        case 'error':\n          await onErrorPart?.(value);\n          break;\n        case 'assistant_message':\n          await onAssistantMessagePart?.(value);\n          break;\n        case 'assistant_control_data':\n          await onAssistantControlDataPart?.(value);\n          break;\n        case 'data_message':\n          await onDataMessagePart?.(value);\n          break;\n        default: {\n          const exhaustiveCheck: never = type;\n          throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);\n        }\n      }\n    }\n  }\n}\n", "import { Validator, validatorSymbol } from '@ai-sdk/provider-utils';\nimport { JSONSchema7 } from 'json-schema';\nimport { z } from 'zod';\nimport { zodSchema } from './zod-schema';\n\n/**\n * Used to mark schemas so we can support both Zod and custom schemas.\n */\nconst schemaSymbol = Symbol.for('vercel.ai.schema');\n\nexport type Schema<OBJECT = unknown> = Validator<OBJECT> & {\n  /**\n   * Used to mark schemas so we can support both Zod and custom schemas.\n   */\n  [schemaSymbol]: true;\n\n  /**\n   * Schema type for inference.\n   */\n  _type: OBJECT;\n\n  /**\n   * The JSON Schema for the schema. It is passed to the providers.\n   */\n  readonly jsonSchema: JSONSchema7;\n};\n\n/**\n * Create a schema using a JSON Schema.\n *\n * @param jsonSchema The JSON Schema for the schema.\n * @param options.validate Optional. A validation function for the schema.\n */\nexport function jsonSchema<OBJECT = unknown>(\n  jsonSchema: JSONSchema7,\n  {\n    validate,\n  }: {\n    validate?: (\n      value: unknown,\n    ) => { success: true; value: OBJECT } | { success: false; error: Error };\n  } = {},\n): Schema<OBJECT> {\n  return {\n    [schemaSymbol]: true,\n    _type: undefined as OBJECT, // should never be used directly\n    [validatorSymbol]: true,\n    jsonSchema,\n    validate,\n  };\n}\n\nfunction isSchema(value: unknown): value is Schema {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    schemaSymbol in value &&\n    value[schemaSymbol] === true &&\n    'jsonSchema' in value &&\n    'validate' in value\n  );\n}\n\nexport function asSchema<OBJECT>(\n  schema: z.Schema<OBJECT, z.ZodTypeDef, any> | Schema<OBJECT>,\n): Schema<OBJECT> {\n  return isSchema(schema) ? schema : zodSchema(schema);\n}\n", "import { JSONSchema7 } from 'json-schema';\nimport { z } from 'zod';\nimport zodToJsonSchema from 'zod-to-json-schema';\nimport { jsonSchema, Schema } from './schema';\n\nexport function zodSchema<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n  options?: {\n    /**\n     * Enables support for references in the schema.\n     * This is required for recursive schemas, e.g. with `z.lazy`.\n     * However, not all language models and providers support such references.\n     * Defaults to `false`.\n     */\n    useReferences?: boolean;\n  },\n): Schema<OBJECT> {\n  // default to no references (to support openapi conversion for google)\n  const useReferences = options?.useReferences ?? false;\n\n  return jsonSchema(\n    zodToJsonSchema(zodSchema, {\n      $refStrategy: useReferences ? 'root' : 'none',\n      target: 'jsonSchema7', // note: openai mode breaks various gemini conversions\n    }) as JSONSchema7,\n    {\n      validate: value => {\n        const result = zodSchema.safeParse(value);\n        return result.success\n          ? { success: true, value: result.data }\n          : { success: false, error: result.error };\n      },\n    },\n  );\n}\n", "import { extractMaxToolInvocationStep } from './extract-max-tool-invocation-step';\nimport { UIMessage } from './types';\n\nexport function shouldResubmitMessages({\n  originalMaxToolInvocationStep,\n  originalMessageCount,\n  maxSteps,\n  messages,\n}: {\n  originalMaxToolInvocationStep: number | undefined;\n  originalMessageCount: number;\n  maxSteps: number;\n  messages: UIMessage[];\n}) {\n  const lastMessage = messages[messages.length - 1];\n  return (\n    // check if the feature is enabled:\n    maxSteps > 1 &&\n    // ensure there is a last message:\n    lastMessage != null &&\n    // ensure we actually have new steps (to prevent infinite loops in case of errors):\n    (messages.length > originalMessageCount ||\n      extractMaxToolInvocationStep(lastMessage.toolInvocations) !==\n        originalMaxToolInvocationStep) &&\n    // check that next step is possible:\n    isAssistantMessageWithCompletedToolCalls(lastMessage) &&\n    // limit the number of automatic steps:\n    (extractMaxToolInvocationStep(lastMessage.toolInvocations) ?? 0) < maxSteps\n  );\n}\n\n/**\nCheck if the message is an assistant message with completed tool calls.\nThe last step of the message must have at least one tool invocation and\nall tool invocations must have a result.\n */\nexport function isAssistantMessageWithCompletedToolCalls(\n  message: UIMessage,\n): message is UIMessage & {\n  role: 'assistant';\n} {\n  if (message.role !== 'assistant') {\n    return false;\n  }\n\n  const lastStepStartIndex = message.parts.reduce((lastIndex, part, index) => {\n    return part.type === 'step-start' ? index : lastIndex;\n  }, -1);\n\n  const lastStepToolInvocations = message.parts\n    .slice(lastStepStartIndex + 1)\n    .filter(part => part.type === 'tool-invocation');\n\n  return (\n    lastStepToolInvocations.length > 0 &&\n    lastStepToolInvocations.every(part => 'result' in part.toolInvocation)\n  );\n}\n", "import { ToolInvocationUIPart, UIMessage } from './types';\n\n/**\n * Updates the result of a specific tool invocation in the last message of the given messages array.\n *\n * @param {object} params - The parameters object.\n * @param {UIMessage[]} params.messages - An array of messages, from which the last one is updated.\n * @param {string} params.toolCallId - The unique identifier for the tool invocation to update.\n * @param {unknown} params.toolResult - The result object to attach to the tool invocation.\n * @returns {void} This function does not return anything.\n */\nexport function updateToolCallResult({\n  messages,\n  toolCallId,\n  toolResult: result,\n}: {\n  messages: UIMessage[];\n  toolCallId: string;\n  toolResult: unknown;\n}) {\n  const lastMessage = messages[messages.length - 1];\n\n  const invocationPart = lastMessage.parts.find(\n    (part): part is ToolInvocationUIPart =>\n      part.type === 'tool-invocation' &&\n      part.toolInvocation.toolCallId === toolCallId,\n  );\n\n  if (invocationPart == null) {\n    return;\n  }\n\n  const toolResult = {\n    ...invocationPart.toolInvocation,\n    state: 'result' as const,\n    result,\n  };\n\n  invocationPart.toolInvocation = toolResult;\n\n  lastMessage.toolInvocations = lastMessage.toolInvocations?.map(\n    toolInvocation =>\n      toolInvocation.toolCallId === toolCallId ? toolResult : toolInvocation,\n  );\n}\n", "// re-exports:\nexport { createIdGenerator, generateId } from '@ai-sdk/provider-utils';\nexport type { IDGenerator } from '@ai-sdk/provider-utils';\nexport {\n  formatAssistantStreamPart,\n  formatDataStreamPart,\n  jsonSchema,\n  parseAssistantStreamPart,\n  parseDataStreamPart,\n  processDataStream,\n  processTextStream,\n  zodSchema,\n} from '@ai-sdk/ui-utils';\nexport type {\n  AssistantMessage,\n  AssistantStatus,\n  Attachment,\n  ChatRequest,\n  ChatRequestOptions,\n  CreateMessage,\n  DataMessage,\n  DataStreamPart,\n  DeepPartial,\n  IdGenerator,\n  JSONValue,\n  Message,\n  UIMessage,\n  RequestOptions,\n  Schema,\n  ToolInvocation,\n  UseAssistantOptions,\n} from '@ai-sdk/ui-utils';\n\n// directory exports:\nexport * from './data-stream';\nexport * from './embed';\nexport * from './generate-image';\nexport * from './generate-object';\nexport * from './generate-text';\nexport * from './generate-speech';\nexport * from './transcribe';\nexport * from './middleware';\nexport * from './prompt';\nexport * from './registry';\nexport * from './tool';\nexport * from './types';\n\n// telemetry types:\nexport type { TelemetrySettings } from './telemetry/telemetry-settings';\n\n// util exports:\nexport { cosineSimilarity } from './util/cosine-similarity';\nexport { simulateReadableStream } from './util/simulate-readable-stream';\n", "import { DataStreamString, formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { DataStreamWriter } from './data-stream-writer';\n\nexport function createDataStream({\n  execute,\n  onError = () => 'An error occurred.', // mask error messages for safety by default\n}: {\n  execute: (dataStream: DataStreamWriter) => Promise<void> | void;\n  onError?: (error: unknown) => string;\n}): ReadableStream<DataStreamString> {\n  let controller!: ReadableStreamDefaultController<string>;\n\n  const ongoingStreamPromises: Promise<void>[] = [];\n\n  const stream = new ReadableStream({\n    start(controllerArg) {\n      controller = controllerArg;\n    },\n  });\n\n  function safeEnqueue(data: DataStreamString) {\n    try {\n      controller.enqueue(data);\n    } catch (error) {\n      // suppress errors when the stream has been closed\n    }\n  }\n\n  try {\n    const result = execute({\n      write(data: DataStreamString) {\n        safeEnqueue(data);\n      },\n      writeData(data) {\n        safeEnqueue(formatDataStreamPart('data', [data]));\n      },\n      writeMessageAnnotation(annotation) {\n        safeEnqueue(formatDataStreamPart('message_annotations', [annotation]));\n      },\n      writeSource(source) {\n        safeEnqueue(formatDataStreamPart('source', source));\n      },\n      merge(streamArg) {\n        ongoingStreamPromises.push(\n          (async () => {\n            const reader = streamArg.getReader();\n            while (true) {\n              const { done, value } = await reader.read();\n              if (done) break;\n              safeEnqueue(value);\n            }\n          })().catch(error => {\n            safeEnqueue(formatDataStreamPart('error', onError(error)));\n          }),\n        );\n      },\n      onError,\n    });\n\n    if (result) {\n      ongoingStreamPromises.push(\n        result.catch(error => {\n          safeEnqueue(formatDataStreamPart('error', onError(error)));\n        }),\n      );\n    }\n  } catch (error) {\n    safeEnqueue(formatDataStreamPart('error', onError(error)));\n  }\n\n  // Wait until all ongoing streams are done. This approach enables merging\n  // streams even after execute has returned, as long as there is still an\n  // open merged stream. This is important to e.g. forward new streams and\n  // from callbacks.\n  const waitForStreams: Promise<void> = new Promise(async resolve => {\n    while (ongoingStreamPromises.length > 0) {\n      await ongoingStreamPromises.shift();\n    }\n    resolve();\n  });\n\n  waitForStreams.finally(() => {\n    try {\n      controller.close();\n    } catch (error) {\n      // suppress errors when the stream has been closed\n    }\n  });\n\n  return stream;\n}\n", "export function prepareResponseHeaders(\n  headers: HeadersInit | undefined,\n  {\n    contentType,\n    dataStreamVersion,\n  }: { contentType: string; dataStreamVersion?: 'v1' | undefined },\n) {\n  const responseHeaders = new Headers(headers ?? {});\n\n  if (!responseHeaders.has('Content-Type')) {\n    responseHeaders.set('Content-Type', contentType);\n  }\n\n  if (dataStreamVersion !== undefined) {\n    responseHeaders.set('X-Vercel-AI-Data-Stream', dataStreamVersion);\n  }\n\n  return responseHeaders;\n}\n", "import { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { createDataStream } from './create-data-stream';\nimport { DataStreamWriter } from './data-stream-writer';\n\nexport function createDataStreamResponse({\n  status,\n  statusText,\n  headers,\n  execute,\n  onError,\n}: ResponseInit & {\n  execute: (dataStream: DataStreamWriter) => Promise<void> | void;\n  onError?: (error: unknown) => string;\n}): Response {\n  return new Response(\n    createDataStream({ execute, onError }).pipeThrough(new TextEncoderStream()),\n    {\n      status,\n      statusText,\n      headers: prepareResponseHeaders(headers, {\n        contentType: 'text/plain; charset=utf-8',\n        dataStreamVersion: 'v1',\n      }),\n    },\n  );\n}\n", "export function prepareOutgoingHttpHeaders(\n  headers: HeadersInit | undefined,\n  {\n    contentType,\n    dataStreamVersion,\n  }: { contentType: string; dataStreamVersion?: 'v1' | undefined },\n) {\n  const outgoingHeaders: Record<string, string | number | string[]> = {};\n\n  if (headers != null) {\n    for (const [key, value] of Object.entries(headers)) {\n      outgoingHeaders[key] = value;\n    }\n  }\n\n  if (outgoingHeaders['Content-Type'] == null) {\n    outgoingHeaders['Content-Type'] = contentType;\n  }\n\n  if (dataStreamVersion !== undefined) {\n    outgoingHeaders['X-Vercel-AI-Data-Stream'] = dataStreamVersion;\n  }\n\n  return outgoingHeaders;\n}\n", "import { ServerResponse } from 'node:http';\n\n/**\n * Writes the content of a stream to a server response.\n */\nexport function writeToServerResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream,\n}: {\n  response: ServerResponse;\n  status?: number;\n  statusText?: string;\n  headers?: Record<string, string | number | string[]>;\n  stream: ReadableStream<Uint8Array>;\n}): void {\n  response.writeHead(status ?? 200, statusText, headers);\n\n  const reader = stream.getReader();\n  const read = async () => {\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        response.write(value);\n      }\n    } catch (error) {\n      throw error;\n    } finally {\n      response.end();\n    }\n  };\n\n  read();\n}\n", "import { ServerResponse } from 'node:http';\nimport { prepareOutgoingHttpHeaders } from '../util/prepare-outgoing-http-headers';\nimport { writeToServerResponse } from '../util/write-to-server-response';\nimport { createDataStream } from './create-data-stream';\nimport { DataStreamWriter } from './data-stream-writer';\n\nexport function pipeDataStreamToResponse(\n  response: ServerResponse,\n  {\n    status,\n    statusText,\n    headers,\n    execute,\n    onError,\n  }: ResponseInit & {\n    execute: (writer: DataStreamWriter) => Promise<void> | void;\n    onError?: (error: unknown) => string;\n  },\n): void {\n  writeToServerResponse({\n    response,\n    status,\n    statusText,\n    headers: prepareOutgoingHttpHeaders(headers, {\n      contentType: 'text/plain; charset=utf-8',\n      dataStreamVersion: 'v1',\n    }),\n    stream: createDataStream({ execute, onError }).pipeThrough(\n      new TextEncoderStream(),\n    ),\n  });\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidArgumentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidArgumentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly parameter: string;\n  readonly value: unknown;\n\n  constructor({\n    parameter,\n    value,\n    message,\n  }: {\n    parameter: string;\n    value: unknown;\n    message: string;\n  }) {\n    super({\n      name,\n      message: `Invalid argument for parameter ${parameter}: ${message}`,\n    });\n\n    this.parameter = parameter;\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is InvalidArgumentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { APICallError } from '@ai-sdk/provider';\nimport { delay, getErrorMessage, isAbortError } from '@ai-sdk/provider-utils';\nimport { RetryError } from './retry-error';\n\nexport type RetryFunction = <OUTPUT>(\n  fn: () => PromiseLike<OUTPUT>,\n) => PromiseLike<OUTPUT>;\n\n/**\nThe `retryWithExponentialBackoff` strategy retries a failed API call with an exponential backoff.\nYou can configure the maximum number of retries, the initial delay, and the backoff factor.\n */\nexport const retryWithExponentialBackoff =\n  ({\n    maxRetries = 2,\n    initialDelayInMs = 2000,\n    backoffFactor = 2,\n  } = {}): RetryFunction =>\n  async <OUTPUT>(f: () => PromiseLike<OUTPUT>) =>\n    _retryWithExponentialBackoff(f, {\n      maxRetries,\n      delayInMs: initialDelayInMs,\n      backoffFactor,\n    });\n\nasync function _retryWithExponentialBackoff<OUTPUT>(\n  f: () => PromiseLike<OUTPUT>,\n  {\n    maxRetries,\n    delayInMs,\n    backoffFactor,\n  }: { maxRetries: number; delayInMs: number; backoffFactor: number },\n  errors: unknown[] = [],\n): Promise<OUTPUT> {\n  try {\n    return await f();\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error; // don't retry when the request was aborted\n    }\n\n    if (maxRetries === 0) {\n      throw error; // don't wrap the error when retries are disabled\n    }\n\n    const errorMessage = getErrorMessage(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n\n    if (tryNumber > maxRetries) {\n      throw new RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: 'maxRetriesExceeded',\n        errors: newErrors,\n      });\n    }\n\n    if (\n      error instanceof Error &&\n      APICallError.isInstance(error) &&\n      error.isRetryable === true &&\n      tryNumber <= maxRetries\n    ) {\n      await delay(delayInMs);\n      return _retryWithExponentialBackoff(\n        f,\n        { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },\n        newErrors,\n      );\n    }\n\n    if (tryNumber === 1) {\n      throw error; // don't wrap the error when a non-retryable error occurs on the first try\n    }\n\n    throw new RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: 'errorNotRetryable',\n      errors: newErrors,\n    });\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_RetryError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport type RetryErrorReason =\n  | 'maxRetriesExceeded'\n  | 'errorNotRetryable'\n  | 'abort';\n\nexport class RetryError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  // note: property order determines debugging output\n  readonly reason: RetryErrorReason;\n  readonly lastError: unknown;\n  readonly errors: Array<unknown>;\n\n  constructor({\n    message,\n    reason,\n    errors,\n  }: {\n    message: string;\n    reason: RetryErrorReason;\n    errors: Array<unknown>;\n  }) {\n    super({ name, message });\n\n    this.reason = reason;\n    this.errors = errors;\n\n    // separate our last error to make debugging via log easier:\n    this.lastError = errors[errors.length - 1];\n  }\n\n  static isInstance(error: unknown): error is RetryError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport {\n  RetryFunction,\n  retryWithExponentialBackoff,\n} from '../../util/retry-with-exponential-backoff';\n\n/**\n * Validate and prepare retries.\n */\nexport function prepareRetries({\n  maxRetries,\n}: {\n  maxRetries: number | undefined;\n}): {\n  maxRetries: number;\n  retry: RetryFunction;\n} {\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new InvalidArgumentError({\n        parameter: 'maxRetries',\n        value: maxRetries,\n        message: 'maxRetries must be an integer',\n      });\n    }\n\n    if (maxRetries < 0) {\n      throw new InvalidArgumentError({\n        parameter: 'maxRetries',\n        value: maxRetries,\n        message: 'maxRetries must be >= 0',\n      });\n    }\n  }\n\n  const maxRetriesResult = maxRetries ?? 2;\n\n  return {\n    maxRetries: maxRetriesResult,\n    retry: retryWithExponentialBackoff({ maxRetries: maxRetriesResult }),\n  };\n}\n", "import { TelemetrySettings } from './telemetry-settings';\n\nexport function assembleOperationName({\n  operationId,\n  telemetry,\n}: {\n  operationId: string;\n  telemetry?: TelemetrySettings;\n}) {\n  return {\n    // standardized operation and resource name:\n    'operation.name': `${operationId}${\n      telemetry?.functionId != null ? ` ${telemetry.functionId}` : ''\n    }`,\n    'resource.name': telemetry?.functionId,\n\n    // detailed, AI SDK specific data:\n    'ai.operationId': operationId,\n    'ai.telemetry.functionId': telemetry?.functionId,\n  };\n}\n", "import { Attributes } from '@opentelemetry/api';\nimport { CallSettings } from '../prompt/call-settings';\nimport { TelemetrySettings } from './telemetry-settings';\n\nexport function getBaseTelemetryAttributes({\n  model,\n  settings,\n  telemetry,\n  headers,\n}: {\n  model: { modelId: string; provider: string };\n  settings: Omit<CallSettings, 'abortSignal' | 'headers'>;\n  telemetry: TelemetrySettings | undefined;\n  headers: Record<string, string | undefined> | undefined;\n}): Attributes {\n  return {\n    'ai.model.provider': model.provider,\n    'ai.model.id': model.modelId,\n\n    // settings:\n    ...Object.entries(settings).reduce((attributes, [key, value]) => {\n      attributes[`ai.settings.${key}`] = value;\n      return attributes;\n    }, {} as Attributes),\n\n    // add metadata as attributes:\n    ...Object.entries(telemetry?.metadata ?? {}).reduce(\n      (attributes, [key, value]) => {\n        attributes[`ai.telemetry.metadata.${key}`] = value;\n        return attributes;\n      },\n      {} as Attributes,\n    ),\n\n    // request headers\n    ...Object.entries(headers ?? {}).reduce((attributes, [key, value]) => {\n      if (value !== undefined) {\n        attributes[`ai.request.headers.${key}`] = value;\n      }\n      return attributes;\n    }, {} as Attributes),\n  };\n}\n", "import { Tracer, trace } from '@opentelemetry/api';\nimport { noopTracer } from './noop-tracer';\n\nexport function getTracer({\n  isEnabled = false,\n  tracer,\n}: {\n  isEnabled?: boolean;\n  tracer?: Tracer;\n} = {}): Tracer {\n  if (!isEnabled) {\n    return noopTracer;\n  }\n\n  if (tracer) {\n    return tracer;\n  }\n\n  return trace.getTracer('ai');\n}\n", "import { Span, SpanContext, Tracer } from '@opentelemetry/api';\n\n/**\n * Tracer implementation that does nothing (null object).\n */\nexport const noopTracer: Tracer = {\n  startSpan(): Span {\n    return noopSpan;\n  },\n\n  startActiveSpan<F extends (span: Span) => unknown>(\n    name: unknown,\n    arg1: unknown,\n    arg2?: unknown,\n    arg3?: F,\n  ): ReturnType<any> {\n    if (typeof arg1 === 'function') {\n      return arg1(noopSpan);\n    }\n    if (typeof arg2 === 'function') {\n      return arg2(noopSpan);\n    }\n    if (typeof arg3 === 'function') {\n      return arg3(noopSpan);\n    }\n  },\n};\n\nconst noopSpan: Span = {\n  spanContext() {\n    return noopSpanContext;\n  },\n  setAttribute() {\n    return this;\n  },\n  setAttributes() {\n    return this;\n  },\n  addEvent() {\n    return this;\n  },\n  addLink() {\n    return this;\n  },\n  addLinks() {\n    return this;\n  },\n  setStatus() {\n    return this;\n  },\n  updateName() {\n    return this;\n  },\n  end() {\n    return this;\n  },\n  isRecording() {\n    return false;\n  },\n  recordException() {\n    return this;\n  },\n};\n\nconst noopSpanContext: SpanContext = {\n  traceId: '',\n  spanId: '',\n  traceFlags: 0,\n};\n", "import { Attributes, Span, Tracer, SpanStatusCode } from '@opentelemetry/api';\n\nexport function recordSpan<T>({\n  name,\n  tracer,\n  attributes,\n  fn,\n  endWhenDone = true,\n}: {\n  name: string;\n  tracer: Tracer;\n  attributes: Attributes;\n  fn: (span: Span) => Promise<T>;\n  endWhenDone?: boolean;\n}) {\n  return tracer.startActiveSpan(name, { attributes }, async span => {\n    try {\n      const result = await fn(span);\n\n      if (endWhenDone) {\n        span.end();\n      }\n\n      return result;\n    } catch (error) {\n      try {\n        if (error instanceof Error) {\n          span.recordException({\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n          });\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: error.message,\n          });\n        } else {\n          span.setStatus({ code: SpanStatusCode.ERROR });\n        }\n      } finally {\n        // always stop the span when there is an error:\n        span.end();\n      }\n\n      throw error;\n    }\n  });\n}\n", "import type { Attributes, AttributeValue } from '@opentelemetry/api';\nimport type { TelemetrySettings } from './telemetry-settings';\n\nexport function selectTelemetryAttributes({\n  telemetry,\n  attributes,\n}: {\n  telemetry?: TelemetrySettings;\n  attributes: {\n    [attributeKey: string]:\n      | AttributeValue\n      | { input: () => AttributeValue | undefined }\n      | { output: () => AttributeValue | undefined }\n      | undefined;\n  };\n}): Attributes {\n  // when telemetry is disabled, return an empty object to avoid serialization overhead:\n  if (telemetry?.isEnabled !== true) {\n    return {};\n  }\n\n  return Object.entries(attributes).reduce((attributes, [key, value]) => {\n    if (value === undefined) {\n      return attributes;\n    }\n\n    // input value, check if it should be recorded:\n    if (\n      typeof value === 'object' &&\n      'input' in value &&\n      typeof value.input === 'function'\n    ) {\n      // default to true:\n      if (telemetry?.recordInputs === false) {\n        return attributes;\n      }\n\n      const result = value.input();\n\n      return result === undefined\n        ? attributes\n        : { ...attributes, [key]: result };\n    }\n\n    // output value, check if it should be recorded:\n    if (\n      typeof value === 'object' &&\n      'output' in value &&\n      typeof value.output === 'function'\n    ) {\n      // default to true:\n      if (telemetry?.recordOutputs === false) {\n        return attributes;\n      }\n\n      const result = value.output();\n\n      return result === undefined\n        ? attributes\n        : { ...attributes, [key]: result };\n    }\n\n    // value is an attribute value already:\n    return { ...attributes, [key]: value };\n  }, {});\n}\n", "import { prepareRetries } from '../prompt/prepare-retries';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { EmbeddingModel } from '../types';\nimport { EmbedResult } from './embed-result';\n\n/**\nEmbed a value using an embedding model. The type of the value is defined by the embedding model.\n\n@param model - The embedding model to use.\n@param value - The value that should be embedded.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the embedding, the value, and additional information.\n */\nexport async function embed<VALUE>({\n  model,\n  value,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n}: {\n  /**\nThe embedding model to use.\n     */\n  model: EmbeddingModel<VALUE>;\n\n  /**\nThe value that should be embedded.\n   */\n  value: VALUE;\n\n  /**\nMaximum number of retries per embedding model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n\n  /**\n   * Optional telemetry configuration (experimental).\n   */\n  experimental_telemetry?: TelemetrySettings;\n}): Promise<EmbedResult<VALUE>> {\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.embed',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: 'ai.embed', telemetry }),\n        ...baseTelemetryAttributes,\n        'ai.value': { input: () => JSON.stringify(value) },\n      },\n    }),\n    tracer,\n    fn: async span => {\n      const { embedding, usage, rawResponse } = await retry(() =>\n        // nested spans to align with the embedMany telemetry data:\n        recordSpan({\n          name: 'ai.embed.doEmbed',\n          attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              ...assembleOperationName({\n                operationId: 'ai.embed.doEmbed',\n                telemetry,\n              }),\n              ...baseTelemetryAttributes,\n              // specific settings that only make sense on the outer level:\n              'ai.values': { input: () => [JSON.stringify(value)] },\n            },\n          }),\n          tracer,\n          fn: async doEmbedSpan => {\n            const modelResponse = await model.doEmbed({\n              values: [value],\n              abortSignal,\n              headers,\n            });\n\n            const embedding = modelResponse.embeddings[0];\n            const usage = modelResponse.usage ?? { tokens: NaN };\n\n            doEmbedSpan.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  'ai.embeddings': {\n                    output: () =>\n                      modelResponse.embeddings.map(embedding =>\n                        JSON.stringify(embedding),\n                      ),\n                  },\n                  'ai.usage.tokens': usage.tokens,\n                },\n              }),\n            );\n\n            return {\n              embedding,\n              usage,\n              rawResponse: modelResponse.rawResponse,\n            };\n          },\n        }),\n      );\n\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.embedding': { output: () => JSON.stringify(embedding) },\n            'ai.usage.tokens': usage.tokens,\n          },\n        }),\n      );\n\n      return new DefaultEmbedResult({ value, embedding, usage, rawResponse });\n    },\n  });\n}\n\nclass DefaultEmbedResult<VALUE> implements EmbedResult<VALUE> {\n  readonly value: EmbedResult<VALUE>['value'];\n  readonly embedding: EmbedResult<VALUE>['embedding'];\n  readonly usage: EmbedResult<VALUE>['usage'];\n  readonly rawResponse: EmbedResult<VALUE>['rawResponse'];\n\n  constructor(options: {\n    value: EmbedResult<VALUE>['value'];\n    embedding: EmbedResult<VALUE>['embedding'];\n    usage: EmbedResult<VALUE>['usage'];\n    rawResponse?: EmbedResult<VALUE>['rawResponse'];\n  }) {\n    this.value = options.value;\n    this.embedding = options.embedding;\n    this.usage = options.usage;\n    this.rawResponse = options.rawResponse;\n  }\n}\n", "/**\n * Splits an array into chunks of a specified size.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} array - The array to split.\n * @param {number} chunkSize - The size of each chunk.\n * @returns {T[][]} - A new array containing the chunks.\n */\nexport function splitArray<T>(array: T[], chunkSize: number): T[][] {\n  if (chunkSize <= 0) {\n    throw new Error('chunkSize must be greater than 0');\n  }\n\n  const result = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.slice(i, i + chunkSize));\n  }\n\n  return result;\n}\n", "import { prepareRetries } from '../prompt/prepare-retries';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { Embedding, EmbeddingModel } from '../types';\nimport { splitArray } from '../util/split-array';\nimport { EmbedManyResult } from './embed-many-result';\n\n/**\nEmbed several values using an embedding model. The type of the value is defined\nby the embedding model.\n\n`embedMany` automatically splits large requests into smaller chunks if the model\nhas a limit on how many embeddings can be generated in a single call.\n\n@param model - The embedding model to use.\n@param values - The values that should be embedded.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the embeddings, the value, and additional information.\n */\nexport async function embedMany<VALUE>({\n  model,\n  values,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n}: {\n  /**\nThe embedding model to use.\n     */\n  model: EmbeddingModel<VALUE>;\n\n  /**\nThe values that should be embedded.\n   */\n  values: Array<VALUE>;\n\n  /**\nMaximum number of retries per embedding model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n\n  /**\n   * Optional telemetry configuration (experimental).\n   */\n  experimental_telemetry?: TelemetrySettings;\n}): Promise<EmbedManyResult<VALUE>> {\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.embedMany',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: 'ai.embedMany', telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        'ai.values': {\n          input: () => values.map(value => JSON.stringify(value)),\n        },\n      },\n    }),\n    tracer,\n    fn: async span => {\n      const maxEmbeddingsPerCall = model.maxEmbeddingsPerCall;\n\n      // the model has not specified limits on\n      // how many embeddings can be generated in a single call\n      if (maxEmbeddingsPerCall == null) {\n        const { embeddings, usage } = await retry(() => {\n          // nested spans to align with the embedMany telemetry data:\n          return recordSpan({\n            name: 'ai.embedMany.doEmbed',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.embedMany.doEmbed',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                'ai.values': {\n                  input: () => values.map(value => JSON.stringify(value)),\n                },\n              },\n            }),\n            tracer,\n            fn: async doEmbedSpan => {\n              const modelResponse = await model.doEmbed({\n                values,\n                abortSignal,\n                headers,\n              });\n\n              const embeddings = modelResponse.embeddings;\n              const usage = modelResponse.usage ?? { tokens: NaN };\n\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.embeddings': {\n                      output: () =>\n                        embeddings.map(embedding => JSON.stringify(embedding)),\n                    },\n                    'ai.usage.tokens': usage.tokens,\n                  },\n                }),\n              );\n\n              return { embeddings, usage };\n            },\n          });\n        });\n\n        span.setAttributes(\n          selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              'ai.embeddings': {\n                output: () =>\n                  embeddings.map(embedding => JSON.stringify(embedding)),\n              },\n              'ai.usage.tokens': usage.tokens,\n            },\n          }),\n        );\n\n        return new DefaultEmbedManyResult({ values, embeddings, usage });\n      }\n\n      // split the values into chunks that are small enough for the model:\n      const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n\n      // serially embed the chunks:\n      const embeddings: Array<Embedding> = [];\n      let tokens = 0;\n\n      for (const chunk of valueChunks) {\n        const { embeddings: responseEmbeddings, usage } = await retry(() => {\n          // nested spans to align with the embedMany telemetry data:\n          return recordSpan({\n            name: 'ai.embedMany.doEmbed',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.embedMany.doEmbed',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                'ai.values': {\n                  input: () => chunk.map(value => JSON.stringify(value)),\n                },\n              },\n            }),\n            tracer,\n            fn: async doEmbedSpan => {\n              const modelResponse = await model.doEmbed({\n                values: chunk,\n                abortSignal,\n                headers,\n              });\n\n              const embeddings = modelResponse.embeddings;\n              const usage = modelResponse.usage ?? { tokens: NaN };\n\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.embeddings': {\n                      output: () =>\n                        embeddings.map(embedding => JSON.stringify(embedding)),\n                    },\n                    'ai.usage.tokens': usage.tokens,\n                  },\n                }),\n              );\n\n              return { embeddings, usage };\n            },\n          });\n        });\n\n        embeddings.push(...responseEmbeddings);\n        tokens += usage.tokens;\n      }\n\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.embeddings': {\n              output: () =>\n                embeddings.map(embedding => JSON.stringify(embedding)),\n            },\n            'ai.usage.tokens': tokens,\n          },\n        }),\n      );\n\n      return new DefaultEmbedManyResult({\n        values,\n        embeddings,\n        usage: { tokens },\n      });\n    },\n  });\n}\n\nclass DefaultEmbedManyResult<VALUE> implements EmbedManyResult<VALUE> {\n  readonly values: EmbedManyResult<VALUE>['values'];\n  readonly embeddings: EmbedManyResult<VALUE>['embeddings'];\n  readonly usage: EmbedManyResult<VALUE>['usage'];\n\n  constructor(options: {\n    values: EmbedManyResult<VALUE>['values'];\n    embeddings: EmbedManyResult<VALUE>['embeddings'];\n    usage: EmbedManyResult<VALUE>['usage'];\n  }) {\n    this.values = options.values;\n    this.embeddings = options.embeddings;\n    this.usage = options.usage;\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\nimport { ImageModelResponseMetadata } from '../core/types/image-model-response-metadata';\n\nconst name = 'AI_NoImageGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when no image could be generated. This can have multiple causes:\n\n- The model failed to generate a response.\n- The model generated a response that could not be parsed.\n */\nexport class NoImageGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\nThe response metadata for each call.\n   */\n  readonly responses: Array<ImageModelResponseMetadata> | undefined;\n\n  constructor({\n    message = 'No image generated.',\n    cause,\n    responses,\n  }: {\n    message?: string;\n    cause?: Error;\n    responses?: Array<ImageModelResponseMetadata>;\n  }) {\n    super({ name, message, cause });\n\n    this.responses = responses;\n  }\n\n  static isInstance(error: unknown): error is NoImageGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import {\n  convertBase64ToUint8Array,\n  convertUint8ArrayToBase64,\n} from '@ai-sdk/provider-utils';\n\n/**\n * A generated file.\n */\nexport interface GeneratedFile {\n  /**\nFile as a base64 encoded string.\n     */\n  readonly base64: string;\n\n  /**\nFile as a Uint8Array.\n     */\n  readonly uint8Array: Uint8Array;\n\n  /**\nMIME type of the file\n   */\n  readonly mimeType: string;\n}\n\nexport class DefaultGeneratedFile implements GeneratedFile {\n  private base64Data: string | undefined;\n  private uint8ArrayData: Uint8Array | undefined;\n\n  readonly mimeType: string;\n\n  constructor({\n    data,\n    mimeType,\n  }: {\n    data: string | Uint8Array;\n    mimeType: string;\n  }) {\n    const isUint8Array = data instanceof Uint8Array;\n    this.base64Data = isUint8Array ? undefined : data;\n    this.uint8ArrayData = isUint8Array ? data : undefined;\n    this.mimeType = mimeType;\n  }\n\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get base64() {\n    if (this.base64Data == null) {\n      this.base64Data = convertUint8ArrayToBase64(this.uint8ArrayData!);\n    }\n    return this.base64Data;\n  }\n\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get uint8Array() {\n    if (this.uint8ArrayData == null) {\n      this.uint8ArrayData = convertBase64ToUint8Array(this.base64Data!);\n    }\n    return this.uint8ArrayData;\n  }\n}\n\nexport class DefaultGeneratedFileWithType extends DefaultGeneratedFile {\n  readonly type = 'file';\n\n  constructor(options: { data: string | Uint8Array; mimeType: string }) {\n    super(options);\n  }\n}\n", "import { convertBase64ToUint8Array } from '@ai-sdk/provider-utils';\n\nexport const imageMimeTypeSignatures = [\n  {\n    mimeType: 'image/gif' as const,\n    bytesPrefix: [0x47, 0x49, 0x46],\n    base64Prefix: 'R0lG',\n  },\n  {\n    mimeType: 'image/png' as const,\n    bytesPrefix: [0x89, 0x50, 0x4e, 0x47],\n    base64Prefix: 'iVBORw',\n  },\n  {\n    mimeType: 'image/jpeg' as const,\n    bytesPrefix: [0xff, 0xd8],\n    base64Prefix: '/9j/',\n  },\n  {\n    mimeType: 'image/webp' as const,\n    bytesPrefix: [0x52, 0x49, 0x46, 0x46],\n    base64Prefix: 'UklGRg',\n  },\n  {\n    mimeType: 'image/bmp' as const,\n    bytesPrefix: [0x42, 0x4d],\n    base64Prefix: 'Qk',\n  },\n  {\n    mimeType: 'image/tiff' as const,\n    bytesPrefix: [0x49, 0x49, 0x2a, 0x00],\n    base64Prefix: 'SUkqAA',\n  },\n  {\n    mimeType: 'image/tiff' as const,\n    bytesPrefix: [0x4d, 0x4d, 0x00, 0x2a],\n    base64Prefix: 'TU0AKg',\n  },\n  {\n    mimeType: 'image/avif' as const,\n    bytesPrefix: [\n      0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70, 0x61, 0x76, 0x69, 0x66,\n    ],\n    base64Prefix: 'AAAAIGZ0eXBhdmlm',\n  },\n  {\n    mimeType: 'image/heic' as const,\n    bytesPrefix: [\n      0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70, 0x68, 0x65, 0x69, 0x63,\n    ],\n    base64Prefix: 'AAAAIGZ0eXBoZWlj',\n  },\n] as const;\n\nexport const audioMimeTypeSignatures = [\n  {\n    mimeType: 'audio/mpeg' as const,\n    bytesPrefix: [0xff, 0xfb],\n    base64Prefix: '//s=',\n  },\n  {\n    mimeType: 'audio/wav' as const,\n    bytesPrefix: [0x52, 0x49, 0x46, 0x46],\n    base64Prefix: 'UklGR',\n  },\n  {\n    mimeType: 'audio/ogg' as const,\n    bytesPrefix: [0x4f, 0x67, 0x67, 0x53],\n    base64Prefix: 'T2dnUw',\n  },\n  {\n    mimeType: 'audio/flac' as const,\n    bytesPrefix: [0x66, 0x4c, 0x61, 0x43],\n    base64Prefix: 'ZkxhQw',\n  },\n  {\n    mimeType: 'audio/aac' as const,\n    bytesPrefix: [0x40, 0x15, 0x00, 0x00],\n    base64Prefix: 'QBUA',\n  },\n  {\n    mimeType: 'audio/mp4' as const,\n    bytesPrefix: [0x66, 0x74, 0x79, 0x70],\n    base64Prefix: 'ZnR5cA',\n  },\n] as const;\n\nconst stripID3 = (data: Uint8Array | string) => {\n  const bytes =\n    typeof data === 'string' ? convertBase64ToUint8Array(data) : data;\n  const id3Size =\n    ((bytes[6] & 0x7f) << 21) |\n    ((bytes[7] & 0x7f) << 14) |\n    ((bytes[8] & 0x7f) << 7) |\n    (bytes[9] & 0x7f);\n\n  // The raw MP3 starts here\n  return bytes.slice(id3Size + 10);\n};\n\nfunction stripID3TagsIfPresent(data: Uint8Array | string): Uint8Array | string {\n  const hasId3 =\n    (typeof data === 'string' && data.startsWith('SUQz')) ||\n    (typeof data !== 'string' &&\n      data.length > 10 &&\n      data[0] === 0x49 && // 'I'\n      data[1] === 0x44 && // 'D'\n      data[2] === 0x33); // '3'\n\n  return hasId3 ? stripID3(data) : data;\n}\n\nexport function detectMimeType({\n  data,\n  signatures,\n}: {\n  data: Uint8Array | string;\n  signatures: typeof audioMimeTypeSignatures | typeof imageMimeTypeSignatures;\n}): (typeof signatures)[number]['mimeType'] | undefined {\n  const processedData = stripID3TagsIfPresent(data);\n\n  for (const signature of signatures) {\n    if (\n      typeof processedData === 'string'\n        ? processedData.startsWith(signature.base64Prefix)\n        : processedData.length >= signature.bytesPrefix.length &&\n          signature.bytesPrefix.every(\n            (byte, index) => processedData[index] === byte,\n          )\n    ) {\n      return signature.mimeType;\n    }\n  }\n\n  return undefined;\n}\n", "import { AISDKError, ImageModelV1, JSONValue } from '@ai-sdk/provider';\nimport { NoImageGeneratedError } from '../../errors/no-image-generated-error';\nimport {\n  DefaultGeneratedFile,\n  GeneratedFile,\n} from '../generate-text/generated-file';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { ImageGenerationWarning } from '../types/image-model';\nimport { ImageModelResponseMetadata } from '../types/image-model-response-metadata';\nimport { GenerateImageResult } from './generate-image-result';\nimport {\n  detectMimeType,\n  imageMimeTypeSignatures,\n} from '../util/detect-mimetype';\n\n/**\nGenerates images using an image model.\n\n@param model - The image model to use.\n@param prompt - The prompt that should be used to generate the image.\n@param n - Number of images to generate. Default: 1.\n@param size - Size of the images to generate. Must have the format `{width}x{height}`.\n@param aspectRatio - Aspect ratio of the images to generate. Must have the format `{width}:{height}`.\n@param seed - Seed for the image generation.\n@param providerOptions - Additional provider-specific options that are passed through to the provider\nas body parameters.\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the generated images.\n */\nexport async function generateImage({\n  model,\n  prompt,\n  n = 1,\n  size,\n  aspectRatio,\n  seed,\n  providerOptions,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n}: {\n  /**\nThe image model to use.\n     */\n  model: ImageModelV1;\n\n  /**\nThe prompt that should be used to generate the image.\n   */\n  prompt: string;\n\n  /**\nNumber of images to generate.\n   */\n  n?: number;\n\n  /**\nSize of the images to generate. Must have the format `{width}x{height}`. If not provided, the default size will be used.\n   */\n  size?: `${number}x${number}`;\n\n  /**\nAspect ratio of the images to generate. Must have the format `{width}:{height}`. If not provided, the default aspect ratio will be used.\n   */\n  aspectRatio?: `${number}:${number}`;\n\n  /**\nSeed for the image generation. If not provided, the default seed will be used.\n   */\n  seed?: number;\n\n  /**\nAdditional provider-specific options that are passed through to the provider\nas body parameters.\n\nThe outer record is keyed by the provider name, and the inner\nrecord is keyed by the provider-specific metadata key.\n```ts\n{\n  \"openai\": {\n    \"style\": \"vivid\"\n  }\n}\n```\n     */\n  providerOptions?: Record<string, Record<string, JSONValue>>;\n\n  /**\nMaximum number of retries per embedding model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n}): Promise<GenerateImageResult> {\n  const { retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  // default to 1 if the model has not specified limits on\n  // how many images can be generated in a single call\n  const maxImagesPerCall = model.maxImagesPerCall ?? 1;\n\n  // parallelize calls to the model:\n  const callCount = Math.ceil(n / maxImagesPerCall);\n  const callImageCounts = Array.from({ length: callCount }, (_, i) => {\n    if (i < callCount - 1) {\n      return maxImagesPerCall;\n    }\n\n    const remainder = n % maxImagesPerCall;\n    return remainder === 0 ? maxImagesPerCall : remainder;\n  });\n  const results = await Promise.all(\n    callImageCounts.map(async callImageCount =>\n      retry(() =>\n        model.doGenerate({\n          prompt,\n          n: callImageCount,\n          abortSignal,\n          headers,\n          size,\n          aspectRatio,\n          seed,\n          providerOptions: providerOptions ?? {},\n        }),\n      ),\n    ),\n  );\n\n  // collect result images, warnings, and response metadata\n  const images: Array<DefaultGeneratedFile> = [];\n  const warnings: Array<ImageGenerationWarning> = [];\n  const responses: Array<ImageModelResponseMetadata> = [];\n  for (const result of results) {\n    images.push(\n      ...result.images.map(\n        image =>\n          new DefaultGeneratedFile({\n            data: image,\n            mimeType:\n              detectMimeType({\n                data: image,\n                signatures: imageMimeTypeSignatures,\n              }) ?? 'image/png',\n          }),\n      ),\n    );\n    warnings.push(...result.warnings);\n    responses.push(result.response);\n  }\n\n  if (!images.length) {\n    throw new NoImageGeneratedError({ responses });\n  }\n\n  return new DefaultGenerateImageResult({ images, warnings, responses });\n}\n\nclass DefaultGenerateImageResult implements GenerateImageResult {\n  readonly images: Array<GeneratedFile>;\n  readonly warnings: Array<ImageGenerationWarning>;\n  readonly responses: Array<ImageModelResponseMetadata>;\n\n  constructor(options: {\n    images: Array<GeneratedFile>;\n    warnings: Array<ImageGenerationWarning>;\n    responses: Array<ImageModelResponseMetadata>;\n  }) {\n    this.images = options.images;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n  }\n\n  get image() {\n    return this.images[0];\n  }\n}\n", "import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport { createIdGenerator, safeParseJSON } from '@ai-sdk/provider-utils';\nimport { Schema } from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { NoObjectGeneratedError } from '../../errors/no-object-generated-error';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  CallWarning,\n  FinishReason,\n  LanguageModel,\n  LogProbs,\n  ProviderMetadata,\n} from '../types';\nimport { LanguageModelRequestMetadata } from '../types/language-model-request-metadata';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { ProviderOptions } from '../types/provider-metadata';\nimport { calculateLanguageModelUsage } from '../types/usage';\nimport { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { GenerateObjectResult } from './generate-object-result';\nimport { injectJsonInstruction } from './inject-json-instruction';\nimport { getOutputStrategy } from './output-strategy';\nimport { validateObjectGenerationInput } from './validate-object-generation-input';\nimport { stringifyForTelemetry } from '../prompt/stringify-for-telemetry';\n\nconst originalGenerateId = createIdGenerator({ prefix: 'aiobj', size: 24 });\n\n/**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n\nShould return the repaired text or null if the text cannot be repaired.\n     */\nexport type RepairTextFunction = (options: {\n  text: string;\n  error: JSONParseError | TypeValidationError;\n}) => Promise<string | null>;\n\n/**\nGenerate a structured, typed object for a given prompt and schema using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamObject` instead.\n\n@returns\nA result object that contains the generated object, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject<OBJECT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output?: 'object' | undefined;\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe schema of the object that the model should generate.\n     */\n      schema: z.Schema<OBJECT, z.ZodTypeDef, any> | Schema<OBJECT>;\n\n      /**\nOptional name of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n     */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n     */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\nOptional telemetry configuration (experimental).\n       */\n\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<OBJECT>>;\n/**\nGenerate an array with structured, typed elements for a given prompt and element schema using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamObject` instead.\n\n@return\nA result object that contains the generated object, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject<ELEMENT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'array';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe element schema of the array that the model should generate.\n */\n      schema: z.Schema<ELEMENT, z.ZodTypeDef, any> | Schema<ELEMENT>;\n\n      /**\nOptional name of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n     */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<Array<ELEMENT>>>;\n/**\nGenerate a value from an enum (limited list of string values) using a language model.\n\nThis function does not stream the output.\n\n@return\nA result object that contains the generated value, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject<ENUM extends string>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'enum';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe enum values that the model should use.\n     */\n      enum: Array<ENUM>;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n     */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<ENUM>>;\n/**\nGenerate JSON with any schema for a given prompt using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamObject` instead.\n\n@returns\nA result object that contains the generated object, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'no-schema';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe mode to use for object generation. Must be \"json\" for no-schema output.\n     */\n      mode?: 'json';\n\n      /**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n     */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\nOptional telemetry configuration (experimental).\n       */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<JSONValue>>;\nexport async function generateObject<SCHEMA, RESULT>({\n  model,\n  enum: enumValues, // rename bc enum is reserved by typescript\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  output = 'object',\n  system,\n  prompt,\n  messages,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_repairText: repairText,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  _internal: {\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n  } = {},\n  ...settings\n}: Omit<CallSettings, 'stopSequences'> &\n  Prompt & {\n    /**\n     * The expected structure of the output.\n     *\n     * - 'object': Generate a single object that conforms to the schema.\n     * - 'array': Generate an array of objects that conform to the schema.\n     * - 'no-schema': Generate any JSON object. No schema is specified.\n     *\n     * Default is 'object' if not specified.\n     */\n    output?: 'object' | 'array' | 'enum' | 'no-schema';\n\n    model: LanguageModel;\n    enum?: Array<SCHEMA>;\n    schema?: z.Schema<SCHEMA, z.ZodTypeDef, any> | Schema<SCHEMA>;\n    schemaName?: string;\n    schemaDescription?: string;\n    mode?: 'auto' | 'json' | 'tool';\n    experimental_repairText?: RepairTextFunction;\n    experimental_telemetry?: TelemetrySettings;\n    experimental_providerMetadata?: ProviderMetadata;\n    providerOptions?: ProviderOptions;\n\n    /**\n     * Internal. For test use only. May change without notice.\n     */\n    _internal?: {\n      generateId?: () => string;\n      currentDate?: () => Date;\n    };\n  }): Promise<GenerateObjectResult<RESULT>> {\n  validateObjectGenerationInput({\n    output,\n    mode,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues,\n  });\n\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues,\n  });\n\n  // automatically set mode to 'json' for no-schema output\n  if (outputStrategy.type === 'no-schema' && mode === undefined) {\n    mode = 'json';\n  }\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.generateObject',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: 'ai.generateObject',\n          telemetry,\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        'ai.prompt': {\n          input: () => JSON.stringify({ system, prompt, messages }),\n        },\n        'ai.schema':\n          outputStrategy.jsonSchema != null\n            ? { input: () => JSON.stringify(outputStrategy.jsonSchema) }\n            : undefined,\n        'ai.schema.name': schemaName,\n        'ai.schema.description': schemaDescription,\n        'ai.settings.output': outputStrategy.type,\n        'ai.settings.mode': mode,\n      },\n    }),\n    tracer,\n    fn: async span => {\n      // use the default provider mode when the mode is set to 'auto' or unspecified\n      if (mode === 'auto' || mode == null) {\n        mode = model.defaultObjectGenerationMode;\n      }\n\n      let result: string;\n      let finishReason: FinishReason;\n      let usage: Parameters<typeof calculateLanguageModelUsage>[0];\n      let warnings: CallWarning[] | undefined;\n      let rawResponse:\n        | { headers?: Record<string, string>; body?: unknown }\n        | undefined;\n      let response: LanguageModelResponseMetadata;\n      let request: LanguageModelRequestMetadata;\n      let logprobs: LogProbs | undefined;\n      let resultProviderMetadata: ProviderMetadata | undefined;\n\n      switch (mode) {\n        case 'json': {\n          const standardizedPrompt = standardizePrompt({\n            prompt: {\n              system:\n                outputStrategy.jsonSchema == null\n                  ? injectJsonInstruction({ prompt: system })\n                  : model.supportsStructuredOutputs\n                    ? system\n                    : injectJsonInstruction({\n                        prompt: system,\n                        schema: outputStrategy.jsonSchema,\n                      }),\n              prompt,\n              messages,\n            },\n            tools: undefined,\n          });\n\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: standardizedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls,\n            modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context\n          });\n\n          const generateResult = await retry(() =>\n            recordSpan({\n              name: 'ai.generateObject.doGenerate',\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: 'ai.generateObject.doGenerate',\n                    telemetry,\n                  }),\n                  ...baseTelemetryAttributes,\n                  'ai.prompt.format': {\n                    input: () => standardizedPrompt.type,\n                  },\n                  'ai.prompt.messages': {\n                    input: () => JSON.stringify(promptMessages),\n                  },\n                  'ai.settings.mode': mode,\n\n                  // standardized gen-ai llm span attributes:\n                  'gen_ai.system': model.provider,\n                  'gen_ai.request.model': model.modelId,\n                  'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                  'gen_ai.request.max_tokens': settings.maxTokens,\n                  'gen_ai.request.presence_penalty': settings.presencePenalty,\n                  'gen_ai.request.temperature': settings.temperature,\n                  'gen_ai.request.top_k': settings.topK,\n                  'gen_ai.request.top_p': settings.topP,\n                },\n              }),\n              tracer,\n              fn: async span => {\n                const result = await model.doGenerate({\n                  mode: {\n                    type: 'object-json',\n                    schema: outputStrategy.jsonSchema,\n                    name: schemaName,\n                    description: schemaDescription,\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat: standardizedPrompt.type,\n                  prompt: promptMessages,\n                  providerMetadata: providerOptions,\n                  abortSignal,\n                  headers,\n                });\n\n                const responseData = {\n                  id: result.response?.id ?? generateId(),\n                  timestamp: result.response?.timestamp ?? currentDate(),\n                  modelId: result.response?.modelId ?? model.modelId,\n                };\n\n                if (result.text === undefined) {\n                  throw new NoObjectGeneratedError({\n                    message:\n                      'No object generated: the model did not return a response.',\n                    response: responseData,\n                    usage: calculateLanguageModelUsage(result.usage),\n                    finishReason: result.finishReason,\n                  });\n                }\n\n                // Add response information to the span:\n                span.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      'ai.response.finishReason': result.finishReason,\n                      'ai.response.object': { output: () => result.text },\n                      'ai.response.id': responseData.id,\n                      'ai.response.model': responseData.modelId,\n                      'ai.response.timestamp':\n                        responseData.timestamp.toISOString(),\n\n                      'ai.usage.promptTokens': result.usage.promptTokens,\n                      'ai.usage.completionTokens':\n                        result.usage.completionTokens,\n\n                      // standardized gen-ai llm span attributes:\n                      'gen_ai.response.finish_reasons': [result.finishReason],\n                      'gen_ai.response.id': responseData.id,\n                      'gen_ai.response.model': responseData.modelId,\n                      'gen_ai.usage.prompt_tokens': result.usage.promptTokens,\n                      'gen_ai.usage.completion_tokens':\n                        result.usage.completionTokens,\n                    },\n                  }),\n                );\n\n                return { ...result, objectText: result.text, responseData };\n              },\n            }),\n          );\n\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          resultProviderMetadata = generateResult.providerMetadata;\n          request = generateResult.request ?? {};\n          response = generateResult.responseData;\n\n          break;\n        }\n\n        case 'tool': {\n          const standardizedPrompt = standardizePrompt({\n            prompt: { system, prompt, messages },\n            tools: undefined,\n          });\n\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: standardizedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls,\n            modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context,\n          });\n          const inputFormat = standardizedPrompt.type;\n\n          const generateResult = await retry(() =>\n            recordSpan({\n              name: 'ai.generateObject.doGenerate',\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: 'ai.generateObject.doGenerate',\n                    telemetry,\n                  }),\n                  ...baseTelemetryAttributes,\n                  'ai.prompt.format': {\n                    input: () => inputFormat,\n                  },\n                  'ai.prompt.messages': {\n                    input: () => stringifyForTelemetry(promptMessages),\n                  },\n                  'ai.settings.mode': mode,\n\n                  // standardized gen-ai llm span attributes:\n                  'gen_ai.system': model.provider,\n                  'gen_ai.request.model': model.modelId,\n                  'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                  'gen_ai.request.max_tokens': settings.maxTokens,\n                  'gen_ai.request.presence_penalty': settings.presencePenalty,\n                  'gen_ai.request.temperature': settings.temperature,\n                  'gen_ai.request.top_k': settings.topK,\n                  'gen_ai.request.top_p': settings.topP,\n                },\n              }),\n              tracer,\n              fn: async span => {\n                const result = await model.doGenerate({\n                  mode: {\n                    type: 'object-tool',\n                    tool: {\n                      type: 'function',\n                      name: schemaName ?? 'json',\n                      description:\n                        schemaDescription ?? 'Respond with a JSON object.',\n                      parameters: outputStrategy.jsonSchema!,\n                    },\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat,\n                  prompt: promptMessages,\n                  providerMetadata: providerOptions,\n                  abortSignal,\n                  headers,\n                });\n\n                const objectText = result.toolCalls?.[0]?.args;\n\n                const responseData = {\n                  id: result.response?.id ?? generateId(),\n                  timestamp: result.response?.timestamp ?? currentDate(),\n                  modelId: result.response?.modelId ?? model.modelId,\n                };\n\n                if (objectText === undefined) {\n                  throw new NoObjectGeneratedError({\n                    message: 'No object generated: the tool was not called.',\n                    response: responseData,\n                    usage: calculateLanguageModelUsage(result.usage),\n                    finishReason: result.finishReason,\n                  });\n                }\n\n                // Add response information to the span:\n                span.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      'ai.response.finishReason': result.finishReason,\n                      'ai.response.object': { output: () => objectText },\n                      'ai.response.id': responseData.id,\n                      'ai.response.model': responseData.modelId,\n                      'ai.response.timestamp':\n                        responseData.timestamp.toISOString(),\n\n                      'ai.usage.promptTokens': result.usage.promptTokens,\n                      'ai.usage.completionTokens':\n                        result.usage.completionTokens,\n\n                      // standardized gen-ai llm span attributes:\n                      'gen_ai.response.finish_reasons': [result.finishReason],\n                      'gen_ai.response.id': responseData.id,\n                      'gen_ai.response.model': responseData.modelId,\n                      'gen_ai.usage.input_tokens': result.usage.promptTokens,\n                      'gen_ai.usage.output_tokens':\n                        result.usage.completionTokens,\n                    },\n                  }),\n                );\n\n                return { ...result, objectText, responseData };\n              },\n            }),\n          );\n\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          resultProviderMetadata = generateResult.providerMetadata;\n          request = generateResult.request ?? {};\n          response = generateResult.responseData;\n\n          break;\n        }\n\n        case undefined: {\n          throw new Error(\n            'Model does not have a default object generation mode.',\n          );\n        }\n\n        default: {\n          const _exhaustiveCheck: never = mode;\n          throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n        }\n      }\n\n      function processResult(result: string): RESULT {\n        const parseResult = safeParseJSON({ text: result });\n\n        if (!parseResult.success) {\n          throw new NoObjectGeneratedError({\n            message: 'No object generated: could not parse the response.',\n            cause: parseResult.error,\n            text: result,\n            response,\n            usage: calculateLanguageModelUsage(usage),\n            finishReason: finishReason,\n          });\n        }\n\n        const validationResult = outputStrategy.validateFinalResult(\n          parseResult.value,\n          {\n            text: result,\n            response,\n            usage: calculateLanguageModelUsage(usage),\n          },\n        );\n\n        if (!validationResult.success) {\n          throw new NoObjectGeneratedError({\n            message: 'No object generated: response did not match schema.',\n            cause: validationResult.error,\n            text: result,\n            response,\n            usage: calculateLanguageModelUsage(usage),\n            finishReason: finishReason,\n          });\n        }\n\n        return validationResult.value;\n      }\n\n      let object: RESULT;\n      try {\n        object = processResult(result);\n      } catch (error) {\n        if (\n          repairText != null &&\n          NoObjectGeneratedError.isInstance(error) &&\n          (JSONParseError.isInstance(error.cause) ||\n            TypeValidationError.isInstance(error.cause))\n        ) {\n          const repairedText = await repairText({\n            text: result,\n            error: error.cause,\n          });\n\n          if (repairedText === null) {\n            throw error;\n          }\n\n          object = processResult(repairedText);\n        } else {\n          throw error;\n        }\n      }\n\n      // Add response information to the span:\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.response.finishReason': finishReason,\n            'ai.response.object': {\n              output: () => JSON.stringify(object),\n            },\n\n            'ai.usage.promptTokens': usage.promptTokens,\n            'ai.usage.completionTokens': usage.completionTokens,\n          },\n        }),\n      );\n\n      return new DefaultGenerateObjectResult({\n        object,\n        finishReason,\n        usage: calculateLanguageModelUsage(usage),\n        warnings,\n        request,\n        response: {\n          ...response,\n          headers: rawResponse?.headers,\n          body: rawResponse?.body,\n        },\n        logprobs,\n        providerMetadata: resultProviderMetadata,\n      });\n    },\n  });\n}\n\nclass DefaultGenerateObjectResult<T> implements GenerateObjectResult<T> {\n  readonly object: GenerateObjectResult<T>['object'];\n  readonly finishReason: GenerateObjectResult<T>['finishReason'];\n  readonly usage: GenerateObjectResult<T>['usage'];\n  readonly warnings: GenerateObjectResult<T>['warnings'];\n  readonly logprobs: GenerateObjectResult<T>['logprobs'];\n  readonly experimental_providerMetadata: GenerateObjectResult<T>['experimental_providerMetadata'];\n  readonly providerMetadata: GenerateObjectResult<T>['providerMetadata'];\n  readonly response: GenerateObjectResult<T>['response'];\n  readonly request: GenerateObjectResult<T>['request'];\n\n  constructor(options: {\n    object: GenerateObjectResult<T>['object'];\n    finishReason: GenerateObjectResult<T>['finishReason'];\n    usage: GenerateObjectResult<T>['usage'];\n    warnings: GenerateObjectResult<T>['warnings'];\n    logprobs: GenerateObjectResult<T>['logprobs'];\n    providerMetadata: GenerateObjectResult<T>['providerMetadata'];\n    response: GenerateObjectResult<T>['response'];\n    request: GenerateObjectResult<T>['request'];\n  }) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.providerMetadata = options.providerMetadata;\n    this.experimental_providerMetadata = options.providerMetadata;\n    this.response = options.response;\n    this.request = options.request;\n    this.logprobs = options.logprobs;\n  }\n\n  toJsonResponse(init?: ResponseInit): Response {\n    return new Response(JSON.stringify(this.object), {\n      status: init?.status ?? 200,\n      headers: prepareResponseHeaders(init?.headers, {\n        contentType: 'application/json; charset=utf-8',\n      }),\n    });\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\nimport { LanguageModelResponseMetadata } from '../core/types/language-model-response-metadata';\nimport { LanguageModelUsage } from '../core/types/usage';\nimport { FinishReason } from '../core';\n\nconst name = 'AI_NoObjectGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when no object could be generated. This can have several causes:\n\n- The model failed to generate a response.\n- The model generated a response that could not be parsed.\n- The model generated a response that could not be validated against the schema.\n\nThe error contains the following properties:\n\n- `text`: The text that was generated by the model. This can be the raw text or the tool call text, depending on the model.\n */\nexport class NoObjectGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n  The text that was generated by the model. This can be the raw text or the tool call text, depending on the model.\n   */\n  readonly text: string | undefined;\n\n  /**\n  The response metadata.\n   */\n  readonly response: LanguageModelResponseMetadata | undefined;\n\n  /**\n  The usage of the model.\n   */\n  readonly usage: LanguageModelUsage | undefined;\n\n  /**\n  Reason why the model finished generating a response.\n   */\n  readonly finishReason: FinishReason | undefined;\n\n  constructor({\n    message = 'No object generated.',\n    cause,\n    text,\n    response,\n    usage,\n    finishReason,\n  }: {\n    message?: string;\n    cause?: Error;\n    text?: string;\n    response: LanguageModelResponseMetadata;\n    usage: LanguageModelUsage;\n    finishReason: FinishReason;\n  }) {\n    super({ name, message, cause });\n\n    this.text = text;\n    this.response = response;\n    this.usage = usage;\n    this.finishReason = finishReason;\n  }\n\n  static isInstance(error: unknown): error is NoObjectGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n\nexport function verifyNoObjectGeneratedError(\n  error: unknown,\n  expected: {\n    message: string;\n    response: LanguageModelResponseMetadata;\n    usage: LanguageModelUsage;\n    finishReason: FinishReason;\n  },\n) {\n  expect(NoObjectGeneratedError.isInstance(error)).toBeTruthy();\n  const noObjectGeneratedError = error as NoObjectGeneratedError;\n  expect(noObjectGeneratedError.message).toStrictEqual(expected.message);\n  expect(noObjectGeneratedError.response).toStrictEqual(expected.response);\n  expect(noObjectGeneratedError.usage).toStrictEqual(expected.usage);\n  expect(noObjectGeneratedError.finishReason).toStrictEqual(\n    expected.finishReason,\n  );\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_DownloadError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class DownloadError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly url: string;\n  readonly statusCode?: number;\n  readonly statusText?: string;\n\n  constructor({\n    url,\n    statusCode,\n    statusText,\n    cause,\n    message = cause == null\n      ? `Failed to download ${url}: ${statusCode} ${statusText}`\n      : `Failed to download ${url}: ${cause}`,\n  }: {\n    url: string;\n    statusCode?: number;\n    statusText?: string;\n    message?: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.url = url;\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n  }\n\n  static isInstance(error: unknown): error is DownloadError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { DownloadError } from './download-error';\n\nexport async function download({ url }: { url: URL }): Promise<{\n  data: Uint8Array;\n  mimeType: string | undefined;\n}> {\n  const urlText = url.toString();\n  try {\n    const response = await fetch(urlText);\n\n    if (!response.ok) {\n      throw new DownloadError({\n        url: urlText,\n        statusCode: response.status,\n        statusText: response.statusText,\n      });\n    }\n\n    return {\n      data: new Uint8Array(await response.arrayBuffer()),\n      mimeType: response.headers.get('content-type') ?? undefined,\n    };\n  } catch (error) {\n    if (DownloadError.isInstance(error)) {\n      throw error;\n    }\n\n    throw new DownloadError({ url: urlText, cause: error });\n  }\n}\n", "import {\n  convertBase64ToUint8Array,\n  convertUint8ArrayToBase64,\n} from '@ai-sdk/provider-utils';\nimport { InvalidDataContentError } from './invalid-data-content-error';\nimport { z } from 'zod';\n\n/**\nData content. Can either be a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer.\n */\nexport type DataContent = string | Uint8Array | ArrayBuffer | Buffer;\n\n/**\n@internal\n */\nexport const dataContentSchema: z.ZodType<DataContent> = z.union([\n  z.string(),\n  z.instanceof(Uint8Array),\n  z.instanceof(ArrayBuffer),\n  z.custom(\n    // Buffer might not be available in some environments such as CloudFlare:\n    (value: unknown): value is Buffer =>\n      globalThis.Buffer?.isBuffer(value) ?? false,\n    { message: 'Must be a Buffer' },\n  ),\n]);\n\n/**\nConverts data content to a base64-encoded string.\n\n@param content - Data content to convert.\n@returns Base64-encoded string.\n*/\nexport function convertDataContentToBase64String(content: DataContent): string {\n  if (typeof content === 'string') {\n    return content;\n  }\n\n  if (content instanceof ArrayBuffer) {\n    return convertUint8ArrayToBase64(new Uint8Array(content));\n  }\n\n  return convertUint8ArrayToBase64(content);\n}\n\n/**\nConverts data content to a Uint8Array.\n\n@param content - Data content to convert.\n@returns Uint8Array.\n */\nexport function convertDataContentToUint8Array(\n  content: DataContent,\n): Uint8Array {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n\n  if (typeof content === 'string') {\n    try {\n      return convertBase64ToUint8Array(content);\n    } catch (error) {\n      throw new InvalidDataContentError({\n        message:\n          'Invalid data content. Content string is not a base64-encoded media.',\n        content,\n        cause: error,\n      });\n    }\n  }\n\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n\n  throw new InvalidDataContentError({ content });\n}\n\n/**\n * Converts a Uint8Array to a string of text.\n *\n * @param uint8Array - The Uint8Array to convert.\n * @returns The converted string.\n */\nexport function convertUint8ArrayToText(uint8Array: Uint8Array): string {\n  try {\n    return new TextDecoder().decode(uint8Array);\n  } catch (error) {\n    throw new Error('Error decoding Uint8Array to text');\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidDataContentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidDataContentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly content: unknown;\n\n  constructor({\n    content,\n    cause,\n    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`,\n  }: {\n    content: unknown;\n    cause?: unknown;\n    message?: string;\n  }) {\n    super({ name, message, cause });\n\n    this.content = content;\n  }\n\n  static isInstance(error: unknown): error is InvalidDataContentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidMessageRoleError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidMessageRoleError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly role: string;\n\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`,\n  }: {\n    role: string;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.role = role;\n  }\n\n  static isInstance(error: unknown): error is InvalidMessageRoleError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "export function splitDataUrl(dataUrl: string): {\n  mimeType: string | undefined;\n  base64Content: string | undefined;\n} {\n  try {\n    const [header, base64Content] = dataUrl.split(',');\n    return {\n      mimeType: header.split(';')[0].split(':')[1],\n      base64Content,\n    };\n  } catch (error) {\n    return {\n      mimeType: undefined,\n      base64Content: undefined,\n    };\n  }\n}\n", "import {\n  LanguageModelV1FilePart,\n  LanguageModelV1ImagePart,\n  LanguageModelV1Message,\n  LanguageModelV1Prompt,\n  LanguageModelV1TextPart,\n} from '@ai-sdk/provider';\nimport { download } from '../../util/download';\nimport { CoreMessage } from '../prompt/message';\nimport {\n  detectMimeType,\n  imageMimeTypeSignatures,\n} from '../util/detect-mimetype';\nimport { FilePart, ImagePart, TextPart } from './content-part';\nimport {\n  convertDataContentToBase64String,\n  convertDataContentToUint8Array,\n  DataContent,\n} from './data-content';\nimport { InvalidMessageRoleError } from './invalid-message-role-error';\nimport { splitDataUrl } from './split-data-url';\nimport { StandardizedPrompt } from './standardize-prompt';\n\nexport async function convertToLanguageModelPrompt({\n  prompt,\n  modelSupportsImageUrls = true,\n  modelSupportsUrl = () => false,\n  downloadImplementation = download,\n}: {\n  prompt: StandardizedPrompt;\n  modelSupportsImageUrls: boolean | undefined;\n  modelSupportsUrl: undefined | ((url: URL) => boolean);\n  downloadImplementation?: typeof download;\n}): Promise<LanguageModelV1Prompt> {\n  const downloadedAssets = await downloadAssets(\n    prompt.messages,\n    downloadImplementation,\n    modelSupportsImageUrls,\n    modelSupportsUrl,\n  );\n\n  return [\n    ...(prompt.system != null\n      ? [{ role: 'system' as const, content: prompt.system }]\n      : []),\n    ...prompt.messages.map(message =>\n      convertToLanguageModelMessage(message, downloadedAssets),\n    ),\n  ];\n}\n\n/**\n * Convert a CoreMessage to a LanguageModelV1Message.\n *\n * @param message The CoreMessage to convert.\n * @param downloadedAssets A map of URLs to their downloaded data. Only\n *   available if the model does not support URLs, null otherwise.\n */\nexport function convertToLanguageModelMessage(\n  message: CoreMessage,\n  downloadedAssets: Record<\n    string,\n    { mimeType: string | undefined; data: Uint8Array }\n  >,\n): LanguageModelV1Message {\n  const role = message.role;\n  switch (role) {\n    case 'system': {\n      return {\n        role: 'system',\n        content: message.content,\n        providerMetadata:\n          message.providerOptions ?? message.experimental_providerMetadata,\n      };\n    }\n\n    case 'user': {\n      if (typeof message.content === 'string') {\n        return {\n          role: 'user',\n          content: [{ type: 'text', text: message.content }],\n          providerMetadata:\n            message.providerOptions ?? message.experimental_providerMetadata,\n        };\n      }\n\n      return {\n        role: 'user',\n        content: message.content\n          .map(part => convertPartToLanguageModelPart(part, downloadedAssets))\n          // remove empty text parts:\n          .filter(part => part.type !== 'text' || part.text !== ''),\n        providerMetadata:\n          message.providerOptions ?? message.experimental_providerMetadata,\n      };\n    }\n\n    case 'assistant': {\n      if (typeof message.content === 'string') {\n        return {\n          role: 'assistant',\n          content: [{ type: 'text', text: message.content }],\n          providerMetadata:\n            message.providerOptions ?? message.experimental_providerMetadata,\n        };\n      }\n\n      return {\n        role: 'assistant',\n        content: message.content\n          .filter(\n            // remove empty text parts:\n            part => part.type !== 'text' || part.text !== '',\n          )\n          .map(part => {\n            const providerOptions =\n              part.providerOptions ?? part.experimental_providerMetadata;\n\n            switch (part.type) {\n              case 'file': {\n                return {\n                  type: 'file',\n                  data:\n                    part.data instanceof URL\n                      ? part.data\n                      : convertDataContentToBase64String(part.data),\n                  filename: part.filename,\n                  mimeType: part.mimeType,\n                  providerMetadata: providerOptions,\n                };\n              }\n              case 'reasoning': {\n                return {\n                  type: 'reasoning',\n                  text: part.text,\n                  signature: part.signature,\n                  providerMetadata: providerOptions,\n                };\n              }\n              case 'redacted-reasoning': {\n                return {\n                  type: 'redacted-reasoning',\n                  data: part.data,\n                  providerMetadata: providerOptions,\n                };\n              }\n              case 'text': {\n                return {\n                  type: 'text' as const,\n                  text: part.text,\n                  providerMetadata: providerOptions,\n                };\n              }\n              case 'tool-call': {\n                return {\n                  type: 'tool-call' as const,\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  args: part.args,\n                  providerMetadata: providerOptions,\n                };\n              }\n            }\n          }),\n        providerMetadata:\n          message.providerOptions ?? message.experimental_providerMetadata,\n      };\n    }\n\n    case 'tool': {\n      return {\n        role: 'tool',\n        content: message.content.map(part => ({\n          type: 'tool-result',\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          result: part.result,\n          content: part.experimental_content,\n          isError: part.isError,\n          providerMetadata:\n            part.providerOptions ?? part.experimental_providerMetadata,\n        })),\n        providerMetadata:\n          message.providerOptions ?? message.experimental_providerMetadata,\n      };\n    }\n\n    default: {\n      const _exhaustiveCheck: never = role;\n      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });\n    }\n  }\n}\n\n/**\n * Downloads images and files from URLs in the messages.\n */\nasync function downloadAssets(\n  messages: CoreMessage[],\n  downloadImplementation: typeof download,\n  modelSupportsImageUrls: boolean | undefined,\n  modelSupportsUrl: (url: URL) => boolean,\n): Promise<Record<string, { mimeType: string | undefined; data: Uint8Array }>> {\n  const urls = messages\n    .filter(message => message.role === 'user')\n    .map(message => message.content)\n    .filter((content): content is Array<TextPart | ImagePart | FilePart> =>\n      Array.isArray(content),\n    )\n    .flat()\n    .filter(\n      (part): part is ImagePart | FilePart =>\n        part.type === 'image' || part.type === 'file',\n    )\n    /**\n     * Filter out image parts if the model supports image URLs, before letting it\n     * decide if it supports a particular URL.\n     */\n    .filter(\n      (part): part is ImagePart | FilePart =>\n        !(part.type === 'image' && modelSupportsImageUrls === true),\n    )\n    .map(part => (part.type === 'image' ? part.image : part.data))\n    .map(part =>\n      // support string urls:\n      typeof part === 'string' &&\n      (part.startsWith('http:') || part.startsWith('https:'))\n        ? new URL(part)\n        : part,\n    )\n    .filter((image): image is URL => image instanceof URL)\n    /**\n     * Filter out URLs that the model supports natively, so we don't download them.\n     */\n    .filter(url => !modelSupportsUrl(url));\n\n  // download in parallel:\n  const downloadedImages = await Promise.all(\n    urls.map(async url => ({\n      url,\n      data: await downloadImplementation({ url }),\n    })),\n  );\n\n  return Object.fromEntries(\n    downloadedImages.map(({ url, data }) => [url.toString(), data]),\n  );\n}\n\n/**\n * Convert part of a message to a LanguageModelV1Part.\n * @param part The part to convert.\n * @param downloadedAssets A map of URLs to their downloaded data. Only\n *  available if the model does not support URLs, null otherwise.\n *\n * @returns The converted part.\n */\nfunction convertPartToLanguageModelPart(\n  part: TextPart | ImagePart | FilePart,\n  downloadedAssets: Record<\n    string,\n    { mimeType: string | undefined; data: Uint8Array }\n  >,\n):\n  | LanguageModelV1TextPart\n  | LanguageModelV1ImagePart\n  | LanguageModelV1FilePart {\n  if (part.type === 'text') {\n    return {\n      type: 'text',\n      text: part.text,\n      providerMetadata:\n        part.providerOptions ?? part.experimental_providerMetadata,\n    };\n  }\n\n  let mimeType: string | undefined = part.mimeType;\n  let data: DataContent | URL;\n  let content: URL | ArrayBuffer | string;\n  let normalizedData: Uint8Array | URL;\n\n  const type = part.type;\n  switch (type) {\n    case 'image':\n      data = part.image;\n      break;\n    case 'file':\n      data = part.data;\n      break;\n    default:\n      throw new Error(`Unsupported part type: ${type}`);\n  }\n\n  // Attempt to create a URL from the data. If it fails, we can assume the data\n  // is not a URL and likely some other sort of data.\n  try {\n    content = typeof data === 'string' ? new URL(data) : data;\n  } catch (error) {\n    content = data;\n  }\n\n  // If we successfully created a URL, we can use that to normalize the data\n  // either by passing it through or converting normalizing the base64 content\n  // to a Uint8Array.\n  if (content instanceof URL) {\n    // If the content is a data URL, we want to convert that to a Uint8Array\n    if (content.protocol === 'data:') {\n      const { mimeType: dataUrlMimeType, base64Content } = splitDataUrl(\n        content.toString(),\n      );\n\n      if (dataUrlMimeType == null || base64Content == null) {\n        throw new Error(`Invalid data URL format in part ${type}`);\n      }\n\n      mimeType = dataUrlMimeType;\n      normalizedData = convertDataContentToUint8Array(base64Content);\n    } else {\n      /**\n       * If the content is a URL, we should first see if it was downloaded. And if not,\n       * we can let the model decide if it wants to support the URL. This also allows\n       * for non-HTTP URLs to be passed through (e.g. gs://).\n       */\n      const downloadedFile = downloadedAssets[content.toString()];\n      if (downloadedFile) {\n        normalizedData = downloadedFile.data;\n        mimeType ??= downloadedFile.mimeType;\n      } else {\n        normalizedData = content;\n      }\n    }\n  } else {\n    // Since we know now the content is not a URL, we can attempt to normalize\n    // the data assuming it is some sort of data.\n    normalizedData = convertDataContentToUint8Array(content);\n  }\n\n  // Now that we have the normalized data either as a URL or a Uint8Array,\n  // we can create the LanguageModelV1Part.\n  switch (type) {\n    case 'image': {\n      // When possible, try to detect the mimetype automatically\n      // to deal with incorrect mimetype inputs.\n      // When detection fails, use provided mimetype.\n\n      if (normalizedData instanceof Uint8Array) {\n        mimeType =\n          detectMimeType({\n            data: normalizedData,\n            signatures: imageMimeTypeSignatures,\n          }) ?? mimeType;\n      }\n      return {\n        type: 'image',\n        image: normalizedData,\n        mimeType,\n        providerMetadata:\n          part.providerOptions ?? part.experimental_providerMetadata,\n      };\n    }\n\n    case 'file': {\n      // We should have a mimeType at this point, if not, throw an error.\n      if (mimeType == null) {\n        throw new Error(`Mime type is missing for file part`);\n      }\n\n      return {\n        type: 'file',\n        data:\n          normalizedData instanceof Uint8Array\n            ? convertDataContentToBase64String(normalizedData)\n            : normalizedData,\n        filename: part.filename,\n        mimeType,\n        providerMetadata:\n          part.providerOptions ?? part.experimental_providerMetadata,\n      };\n    }\n  }\n}\n", "import { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport { CallSettings } from './call-settings';\n\n/**\n * Validates call settings and sets default values.\n */\nexport function prepareCallSettings({\n  maxTokens,\n  temperature,\n  topP,\n  topK,\n  presencePenalty,\n  frequencyPenalty,\n  stopSequences,\n  seed,\n}: Omit<CallSettings, 'abortSignal' | 'headers' | 'maxRetries'>): Omit<\n  CallSettings,\n  'abortSignal' | 'headers' | 'maxRetries'\n> {\n  if (maxTokens != null) {\n    if (!Number.isInteger(maxTokens)) {\n      throw new InvalidArgumentError({\n        parameter: 'maxTokens',\n        value: maxTokens,\n        message: 'maxTokens must be an integer',\n      });\n    }\n\n    if (maxTokens < 1) {\n      throw new InvalidArgumentError({\n        parameter: 'maxTokens',\n        value: maxTokens,\n        message: 'maxTokens must be >= 1',\n      });\n    }\n  }\n\n  if (temperature != null) {\n    if (typeof temperature !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'temperature',\n        value: temperature,\n        message: 'temperature must be a number',\n      });\n    }\n  }\n\n  if (topP != null) {\n    if (typeof topP !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'topP',\n        value: topP,\n        message: 'topP must be a number',\n      });\n    }\n  }\n\n  if (topK != null) {\n    if (typeof topK !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'topK',\n        value: topK,\n        message: 'topK must be a number',\n      });\n    }\n  }\n\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'presencePenalty',\n        value: presencePenalty,\n        message: 'presencePenalty must be a number',\n      });\n    }\n  }\n\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'frequencyPenalty',\n        value: frequencyPenalty,\n        message: 'frequencyPenalty must be a number',\n      });\n    }\n  }\n\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new InvalidArgumentError({\n        parameter: 'seed',\n        value: seed,\n        message: 'seed must be an integer',\n      });\n    }\n  }\n\n  return {\n    maxTokens,\n    // TODO v5 remove default 0 for temperature\n    temperature: temperature ?? 0,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    stopSequences:\n      stopSequences != null && stopSequences.length > 0\n        ? stopSequences\n        : undefined,\n    seed,\n  };\n}\n", "import { InvalidPromptError } from '@ai-sdk/provider';\nimport { safeValidateTypes } from '@ai-sdk/provider-utils';\nimport { Message } from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { ToolSet } from '../generate-text/tool-set';\nimport { convertToCoreMessages } from './convert-to-core-messages';\nimport { CoreMessage, coreMessageSchema } from './message';\nimport { Prompt } from './prompt';\n\nexport type StandardizedPrompt = {\n  /**\n   * Original prompt type. This is forwarded to the providers and can be used\n   * to write send raw text to providers that support it.\n   */\n  type: 'prompt' | 'messages';\n\n  /**\n   * System message.\n   */\n  system?: string;\n\n  /**\n   * Messages.\n   */\n  messages: CoreMessage[];\n};\n\nexport function standardizePrompt<TOOLS extends ToolSet>({\n  prompt,\n  tools,\n}: {\n  prompt: Prompt;\n  tools: undefined | TOOLS;\n}): StandardizedPrompt {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'prompt or messages must be defined',\n    });\n  }\n\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'prompt and messages cannot be defined at the same time',\n    });\n  }\n\n  // validate that system is a string\n  if (prompt.system != null && typeof prompt.system !== 'string') {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'system must be a string',\n    });\n  }\n\n  // type: prompt\n  if (prompt.prompt != null) {\n    // validate that prompt is a string\n    if (typeof prompt.prompt !== 'string') {\n      throw new InvalidPromptError({\n        prompt,\n        message: 'prompt must be a string',\n      });\n    }\n\n    return {\n      type: 'prompt',\n      system: prompt.system,\n      messages: [\n        {\n          role: 'user',\n          content: prompt.prompt,\n        },\n      ],\n    };\n  }\n\n  // type: messages\n  if (prompt.messages != null) {\n    const promptType = detectPromptType(prompt.messages);\n\n    const messages: CoreMessage[] =\n      promptType === 'ui-messages'\n        ? convertToCoreMessages(prompt.messages as Omit<Message, 'id'>[], {\n            tools,\n          })\n        : (prompt.messages as CoreMessage[]);\n\n    if (messages.length === 0) {\n      throw new InvalidPromptError({\n        prompt,\n        message: 'messages must not be empty',\n      });\n    }\n\n    const validationResult = safeValidateTypes({\n      value: messages,\n      schema: z.array(coreMessageSchema),\n    });\n\n    if (!validationResult.success) {\n      throw new InvalidPromptError({\n        prompt,\n        message: [\n          'message must be a CoreMessage or a UI message',\n          `Validation error: ${validationResult.error.message}`,\n        ].join('\\n'),\n        cause: validationResult.error,\n      });\n    }\n\n    return {\n      type: 'messages',\n      messages,\n      system: prompt.system,\n    };\n  }\n\n  throw new Error('unreachable');\n}\n\nfunction detectPromptType(\n  prompt: Array<any>,\n): 'ui-messages' | 'messages' | 'other' {\n  if (!Array.isArray(prompt)) {\n    throw new InvalidPromptError({\n      prompt,\n      message: [\n        'messages must be an array of CoreMessage or UIMessage',\n        `Received non-array value: ${JSON.stringify(prompt)}`,\n      ].join('\\n'),\n      cause: prompt,\n    });\n  }\n\n  if (prompt.length === 0) {\n    return 'messages';\n  }\n\n  const characteristics = prompt.map(detectSingleMessageCharacteristics);\n\n  if (characteristics.some(c => c === 'has-ui-specific-parts')) {\n    return 'ui-messages';\n  }\n\n  const nonMessageIndex = characteristics.findIndex(\n    c => c !== 'has-core-specific-parts' && c !== 'message',\n  );\n\n  if (nonMessageIndex === -1) {\n    return 'messages';\n  }\n\n  throw new InvalidPromptError({\n    prompt,\n    message: [\n      'messages must be an array of CoreMessage or UIMessage',\n      `Received message of type: \"${characteristics[nonMessageIndex]}\" at index ${nonMessageIndex}`,\n      `messages[${nonMessageIndex}]: ${JSON.stringify(prompt[nonMessageIndex])}`,\n    ].join('\\n'),\n    cause: prompt,\n  });\n}\n\nfunction detectSingleMessageCharacteristics(\n  message: any,\n): 'has-ui-specific-parts' | 'has-core-specific-parts' | 'message' | 'other' {\n  if (\n    typeof message === 'object' &&\n    message !== null &&\n    (message.role === 'function' || // UI-only role\n      message.role === 'data' || // UI-only role\n      'toolInvocations' in message || // UI-specific field\n      'parts' in message || // UI-specific field\n      'experimental_attachments' in message)\n  ) {\n    return 'has-ui-specific-parts';\n  } else if (\n    typeof message === 'object' &&\n    message !== null &&\n    'content' in message &&\n    (Array.isArray(message.content) || // Core messages can have array content\n      'experimental_providerMetadata' in message ||\n      'providerOptions' in message)\n  ) {\n    return 'has-core-specific-parts';\n  } else if (\n    typeof message === 'object' &&\n    message !== null &&\n    'role' in message &&\n    'content' in message &&\n    typeof message.content === 'string' &&\n    ['system', 'user', 'assistant', 'tool'].includes(message.role)\n  ) {\n    return 'message';\n  } else {\n    return 'other';\n  }\n}\n", "import { Attachment } from '@ai-sdk/ui-utils';\nimport { FilePart, ImagePart, TextPart } from './content-part';\nimport {\n  convertDataContentToUint8Array,\n  convertUint8ArrayToText,\n} from './data-content';\n\ntype ContentPart = TextPart | ImagePart | FilePart;\n\n/**\n * Converts a list of attachments to a list of content parts\n * for consumption by `ai/core` functions.\n * Currently only supports images and text attachments.\n */\nexport function attachmentsToParts(attachments: Attachment[]): ContentPart[] {\n  const parts: ContentPart[] = [];\n\n  for (const attachment of attachments) {\n    let url;\n\n    try {\n      url = new URL(attachment.url);\n    } catch (error) {\n      throw new Error(`Invalid URL: ${attachment.url}`);\n    }\n\n    switch (url.protocol) {\n      case 'http:':\n      case 'https:': {\n        if (attachment.contentType?.startsWith('image/')) {\n          parts.push({ type: 'image', image: url });\n        } else {\n          if (!attachment.contentType) {\n            throw new Error(\n              'If the attachment is not an image, it must specify a content type',\n            );\n          }\n\n          parts.push({\n            type: 'file',\n            data: url,\n            mimeType: attachment.contentType,\n          });\n        }\n        break;\n      }\n\n      case 'data:': {\n        let header;\n        let base64Content;\n        let mimeType;\n\n        try {\n          [header, base64Content] = attachment.url.split(',');\n          mimeType = header.split(';')[0].split(':')[1];\n        } catch (error) {\n          throw new Error(`Error processing data URL: ${attachment.url}`);\n        }\n\n        if (mimeType == null || base64Content == null) {\n          throw new Error(`Invalid data URL format: ${attachment.url}`);\n        }\n\n        if (attachment.contentType?.startsWith('image/')) {\n          parts.push({\n            type: 'image',\n            image: convertDataContentToUint8Array(base64Content),\n          });\n        } else if (attachment.contentType?.startsWith('text/')) {\n          parts.push({\n            type: 'text',\n            text: convertUint8ArrayToText(\n              convertDataContentToUint8Array(base64Content),\n            ),\n          });\n        } else {\n          if (!attachment.contentType) {\n            throw new Error(\n              'If the attachment is not an image or text, it must specify a content type',\n            );\n          }\n\n          parts.push({\n            type: 'file',\n            data: base64Content,\n            mimeType: attachment.contentType,\n          });\n        }\n\n        break;\n      }\n\n      default: {\n        throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n      }\n    }\n  }\n\n  return parts;\n}\n", "import { AISDKError } from '@ai-sdk/provider';\nimport { Message } from '@ai-sdk/ui-utils';\n\nconst name = 'AI_MessageConversionError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class MessageConversionError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly originalMessage: Omit<Message, 'id'>;\n\n  constructor({\n    originalMessage,\n    message,\n  }: {\n    originalMessage: Omit<Message, 'id'>;\n    message: string;\n  }) {\n    super({ name, message });\n\n    this.originalMessage = originalMessage;\n  }\n\n  static isInstance(error: unknown): error is MessageConversionError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import {\n  FileUIPart,\n  Message,\n  ReasoningUIPart,\n  TextUIPart,\n  ToolInvocationUIPart,\n} from '@ai-sdk/ui-utils';\nimport { ToolSet } from '../generate-text/tool-set';\nimport {\n  AssistantContent,\n  CoreMessage,\n  ToolCallPart,\n  ToolResultPart,\n} from '../prompt';\nimport { attachmentsToParts } from './attachments-to-parts';\nimport { MessageConversionError } from './message-conversion-error';\n\n/**\nConverts an array of messages from useChat into an array of CoreMessages that can be used\nwith the AI core functions (e.g. `streamText`).\n */\nexport function convertToCoreMessages<TOOLS extends ToolSet = never>(\n  messages: Array<Omit<Message, 'id'>>,\n  options?: { tools?: TOOLS },\n) {\n  const tools = options?.tools ?? ({} as TOOLS);\n  const coreMessages: CoreMessage[] = [];\n\n  for (let i = 0; i < messages.length; i++) {\n    const message = messages[i];\n    const isLastMessage = i === messages.length - 1;\n    const { role, content, experimental_attachments } = message;\n\n    switch (role) {\n      case 'system': {\n        coreMessages.push({\n          role: 'system',\n          content,\n        });\n        break;\n      }\n\n      case 'user': {\n        if (message.parts == null) {\n          coreMessages.push({\n            role: 'user',\n            content: experimental_attachments\n              ? [\n                  { type: 'text', text: content },\n                  ...attachmentsToParts(experimental_attachments),\n                ]\n              : content,\n          });\n        } else {\n          const textParts = message.parts\n            .filter(part => part.type === 'text')\n            .map(part => ({\n              type: 'text' as const,\n              text: part.text,\n            }));\n\n          coreMessages.push({\n            role: 'user',\n            content: experimental_attachments\n              ? [...textParts, ...attachmentsToParts(experimental_attachments)]\n              : textParts,\n          });\n        }\n        break;\n      }\n\n      case 'assistant': {\n        if (message.parts != null) {\n          let currentStep = 0;\n          let blockHasToolInvocations = false;\n          let block: Array<\n            TextUIPart | ToolInvocationUIPart | ReasoningUIPart | FileUIPart\n          > = [];\n\n          function processBlock() {\n            const content: AssistantContent = [];\n\n            for (const part of block) {\n              switch (part.type) {\n                case 'file':\n                case 'text': {\n                  content.push(part);\n                  break;\n                }\n                case 'reasoning': {\n                  for (const detail of part.details) {\n                    switch (detail.type) {\n                      case 'text':\n                        content.push({\n                          type: 'reasoning' as const,\n                          text: detail.text,\n                          signature: detail.signature,\n                        });\n                        break;\n                      case 'redacted':\n                        content.push({\n                          type: 'redacted-reasoning' as const,\n                          data: detail.data,\n                        });\n                        break;\n                    }\n                  }\n                  break;\n                }\n                case 'tool-invocation':\n                  content.push({\n                    type: 'tool-call' as const,\n                    toolCallId: part.toolInvocation.toolCallId,\n                    toolName: part.toolInvocation.toolName,\n                    args: part.toolInvocation.args,\n                  });\n                  break;\n                default: {\n                  const _exhaustiveCheck: never = part;\n                  throw new Error(`Unsupported part: ${_exhaustiveCheck}`);\n                }\n              }\n            }\n\n            coreMessages.push({\n              role: 'assistant',\n              content,\n            });\n\n            // check if there are tool invocations with results in the block\n            const stepInvocations = block\n              .filter(\n                (\n                  part:\n                    | TextUIPart\n                    | ToolInvocationUIPart\n                    | ReasoningUIPart\n                    | FileUIPart,\n                ): part is ToolInvocationUIPart =>\n                  part.type === 'tool-invocation',\n              )\n              .map(part => part.toolInvocation);\n\n            // tool message with tool results\n            if (stepInvocations.length > 0) {\n              coreMessages.push({\n                role: 'tool',\n                content: stepInvocations.map(\n                  (toolInvocation): ToolResultPart => {\n                    if (!('result' in toolInvocation)) {\n                      throw new MessageConversionError({\n                        originalMessage: message,\n                        message:\n                          'ToolInvocation must have a result: ' +\n                          JSON.stringify(toolInvocation),\n                      });\n                    }\n\n                    const { toolCallId, toolName, result } = toolInvocation;\n\n                    const tool = tools[toolName];\n                    return tool?.experimental_toToolResultContent != null\n                      ? {\n                          type: 'tool-result',\n                          toolCallId,\n                          toolName,\n                          result: tool.experimental_toToolResultContent(result),\n                          experimental_content:\n                            tool.experimental_toToolResultContent(result),\n                        }\n                      : {\n                          type: 'tool-result',\n                          toolCallId,\n                          toolName,\n                          result,\n                        };\n                  },\n                ),\n              });\n            }\n\n            // updates for next block\n            block = [];\n            blockHasToolInvocations = false;\n            currentStep++;\n          }\n\n          for (const part of message.parts) {\n            switch (part.type) {\n              case 'text': {\n                if (blockHasToolInvocations) {\n                  processBlock(); // text must come before tool invocations\n                }\n                block.push(part);\n                break;\n              }\n              case 'file':\n              case 'reasoning': {\n                block.push(part);\n                break;\n              }\n              case 'tool-invocation': {\n                if ((part.toolInvocation.step ?? 0) !== currentStep) {\n                  processBlock();\n                }\n                block.push(part);\n                blockHasToolInvocations = true;\n                break;\n              }\n            }\n          }\n\n          processBlock();\n\n          break;\n        }\n\n        const toolInvocations = message.toolInvocations;\n\n        if (toolInvocations == null || toolInvocations.length === 0) {\n          coreMessages.push({ role: 'assistant', content });\n          break;\n        }\n\n        const maxStep = toolInvocations.reduce((max, toolInvocation) => {\n          return Math.max(max, toolInvocation.step ?? 0);\n        }, 0);\n\n        for (let i = 0; i <= maxStep; i++) {\n          const stepInvocations = toolInvocations.filter(\n            toolInvocation => (toolInvocation.step ?? 0) === i,\n          );\n\n          if (stepInvocations.length === 0) {\n            continue;\n          }\n\n          // assistant message with tool calls\n          coreMessages.push({\n            role: 'assistant',\n            content: [\n              ...(isLastMessage && content && i === 0\n                ? [{ type: 'text' as const, text: content }]\n                : []),\n              ...stepInvocations.map(\n                ({ toolCallId, toolName, args }): ToolCallPart => ({\n                  type: 'tool-call' as const,\n                  toolCallId,\n                  toolName,\n                  args,\n                }),\n              ),\n            ],\n          });\n\n          // tool message with tool results\n          coreMessages.push({\n            role: 'tool',\n            content: stepInvocations.map((toolInvocation): ToolResultPart => {\n              if (!('result' in toolInvocation)) {\n                throw new MessageConversionError({\n                  originalMessage: message,\n                  message:\n                    'ToolInvocation must have a result: ' +\n                    JSON.stringify(toolInvocation),\n                });\n              }\n\n              const { toolCallId, toolName, result } = toolInvocation;\n\n              const tool = tools[toolName];\n              return tool?.experimental_toToolResultContent != null\n                ? {\n                    type: 'tool-result',\n                    toolCallId,\n                    toolName,\n                    result: tool.experimental_toToolResultContent(result),\n                    experimental_content:\n                      tool.experimental_toToolResultContent(result),\n                  }\n                : {\n                    type: 'tool-result',\n                    toolCallId,\n                    toolName,\n                    result,\n                  };\n            }),\n          });\n        }\n\n        if (content && !isLastMessage) {\n          coreMessages.push({ role: 'assistant', content });\n        }\n\n        break;\n      }\n\n      case 'data': {\n        // ignore\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new MessageConversionError({\n          originalMessage: message,\n          message: `Unsupported role: ${_exhaustiveCheck}`,\n        });\n      }\n    }\n  }\n\n  return coreMessages;\n}\n", "import { z } from 'zod';\nimport { ProviderMetadata } from '../types';\nimport {\n  providerMetadataSchema,\n  ProviderOptions,\n} from '../types/provider-metadata';\nimport {\n  FilePart,\n  filePartSchema,\n  ImagePart,\n  imagePartSchema,\n  ReasoningPart,\n  reasoningPartSchema,\n  RedactedReasoningPart,\n  redactedReasoningPartSchema,\n  TextPart,\n  textPartSchema,\n  ToolCallPart,\n  toolCallPartSchema,\n  ToolResultPart,\n  toolResultPartSchema,\n} from './content-part';\n\n/**\n A system message. It can contain system information.\n\n Note: using the \"system\" part of the prompt is strongly preferred\n to increase the resilience against prompt injection attacks,\n and because not all providers support several system messages.\n */\nexport type CoreSystemMessage = {\n  role: 'system';\n  content: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreSystemMessageSchema: z.ZodType<CoreSystemMessage> = z.object({\n  role: z.literal('system'),\n  content: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nA user message. It can contain text or a combination of text and images.\n */\nexport type CoreUserMessage = {\n  role: 'user';\n  content: UserContent;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n*/\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreUserMessageSchema: z.ZodType<CoreUserMessage> = z.object({\n  role: z.literal('user'),\n  content: z.union([\n    z.string(),\n    z.array(z.union([textPartSchema, imagePartSchema, filePartSchema])),\n  ]),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nContent of a user message. It can be a string or an array of text and image parts.\n */\nexport type UserContent = string | Array<TextPart | ImagePart | FilePart>;\n\n/**\nAn assistant message. It can contain text, tool calls, or a combination of text and tool calls.\n */\nexport type CoreAssistantMessage = {\n  role: 'assistant';\n  content: AssistantContent;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n*/\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreAssistantMessageSchema: z.ZodType<CoreAssistantMessage> =\n  z.object({\n    role: z.literal('assistant'),\n    content: z.union([\n      z.string(),\n      z.array(\n        z.union([\n          textPartSchema,\n          filePartSchema,\n          reasoningPartSchema,\n          redactedReasoningPartSchema,\n          toolCallPartSchema,\n        ]),\n      ),\n    ]),\n    providerOptions: providerMetadataSchema.optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional(),\n  });\n\n/**\nContent of an assistant message.\nIt can be a string or an array of text, image, reasoning, redacted reasoning, and tool call parts.\n */\nexport type AssistantContent =\n  | string\n  | Array<\n      TextPart | FilePart | ReasoningPart | RedactedReasoningPart | ToolCallPart\n    >;\n\n/**\nA tool message. It contains the result of one or more tool calls.\n */\nexport type CoreToolMessage = {\n  role: 'tool';\n  content: ToolContent;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n*/\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreToolMessageSchema: z.ZodType<CoreToolMessage> = z.object({\n  role: z.literal('tool'),\n  content: z.array(toolResultPartSchema),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nContent of a tool message. It is an array of tool result parts.\n */\nexport type ToolContent = Array<ToolResultPart>;\n\n/**\nA message that can be used in the `messages` field of a prompt.\nIt can be a user message, an assistant message, or a tool message.\n */\nexport type CoreMessage =\n  | CoreSystemMessage\n  | CoreUserMessage\n  | CoreAssistantMessage\n  | CoreToolMessage;\n\nexport const coreMessageSchema: z.ZodType<CoreMessage> = z.union([\n  coreSystemMessageSchema,\n  coreUserMessageSchema,\n  coreAssistantMessageSchema,\n  coreToolMessageSchema,\n]);\n", "import { LanguageModelV1ProviderMetadata } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { jsonValueSchema } from './json-value';\n\n/**\nAdditional provider-specific metadata that is returned from the provider.\n\nThis is needed to enable provider-specific functionality that can be\nfully encapsulated in the provider.\n */\nexport type ProviderMetadata = LanguageModelV1ProviderMetadata;\n\n/**\nAdditional provider-specific options.\n\nThey are passed through to the provider from the AI SDK and enable\nprovider-specific functionality that can be fully encapsulated in the provider.\n */\n// TODO change to LanguageModelV2ProviderOptions in language model v2\nexport type ProviderOptions = LanguageModelV1ProviderMetadata;\n\nexport const providerMetadataSchema: z.ZodType<ProviderMetadata> = z.record(\n  z.string(),\n  z.record(z.string(), jsonValueSchema),\n);\n", "import { JSONValue } from '@ai-sdk/provider';\nimport { z } from 'zod';\n\nexport const jsonValueSchema: z.ZodType<JSONValue> = z.lazy(() =>\n  z.union([\n    z.null(),\n    z.string(),\n    z.number(),\n    z.boolean(),\n    z.record(z.string(), jsonValueSchema),\n    z.array(jsonValueSchema),\n  ]),\n);\n", "import { z } from 'zod';\nimport {\n  ProviderMetadata,\n  providerMetadataSchema,\n  ProviderOptions,\n} from '../types/provider-metadata';\nimport { DataContent, dataContentSchema } from './data-content';\nimport {\n  ToolResultContent,\n  toolResultContentSchema,\n} from './tool-result-content';\n\n/**\nText content part of a prompt. It contains a string of text.\n */\nexport interface TextPart {\n  type: 'text';\n\n  /**\nThe text content.\n   */\n  text: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const textPartSchema: z.ZodType<TextPart> = z.object({\n  type: z.literal('text'),\n  text: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nImage content part of a prompt. It contains an image.\n */\nexport interface ImagePart {\n  type: 'image';\n\n  /**\nImage data. Can either be:\n\n- data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer\n- URL: a URL that points to the image\n   */\n  image: DataContent | URL;\n\n  /**\nOptional mime type of the image.\n   */\n  mimeType?: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const imagePartSchema: z.ZodType<ImagePart> = z.object({\n  type: z.literal('image'),\n  image: z.union([dataContentSchema, z.instanceof(URL)]),\n  mimeType: z.string().optional(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nFile content part of a prompt. It contains a file.\n */\nexport interface FilePart {\n  type: 'file';\n\n  /**\nFile data. Can either be:\n\n- data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer\n- URL: a URL that points to the image\n   */\n  data: DataContent | URL;\n\n  /**\nOptional filename of the file.\n   */\n  filename?: string;\n\n  /**\nMime type of the file.\n   */\n  mimeType: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const filePartSchema: z.ZodType<FilePart> = z.object({\n  type: z.literal('file'),\n  data: z.union([dataContentSchema, z.instanceof(URL)]),\n  filename: z.string().optional(),\n  mimeType: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\n * Reasoning content part of a prompt. It contains a reasoning.\n */\nexport interface ReasoningPart {\n  type: 'reasoning';\n\n  /**\nThe reasoning text.\n   */\n  text: string;\n\n  /**\nAn optional signature for verifying that the reasoning originated from the model.\n   */\n  signature?: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const reasoningPartSchema: z.ZodType<ReasoningPart> = z.object({\n  type: z.literal('reasoning'),\n  text: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nRedacted reasoning content part of a prompt.\n */\nexport interface RedactedReasoningPart {\n  type: 'redacted-reasoning';\n\n  /**\nRedacted reasoning data.\n   */\n  data: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const redactedReasoningPartSchema: z.ZodType<RedactedReasoningPart> =\n  z.object({\n    type: z.literal('redacted-reasoning'),\n    data: z.string(),\n    providerOptions: providerMetadataSchema.optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional(),\n  });\n\n/**\nTool call content part of a prompt. It contains a tool call (usually generated by the AI model).\n */\nexport interface ToolCallPart {\n  type: 'tool-call';\n\n  /**\nID of the tool call. This ID is used to match the tool call with the tool result.\n */\n  toolCallId: string;\n\n  /**\nName of the tool that is being called.\n */\n  toolName: string;\n\n  /**\nArguments of the tool call. This is a JSON-serializable object that matches the tool's input schema.\n   */\n  args: unknown;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const toolCallPartSchema: z.ZodType<ToolCallPart> = z.object({\n  type: z.literal('tool-call'),\n  toolCallId: z.string(),\n  toolName: z.string(),\n  args: z.unknown(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n}) as z.ZodType<ToolCallPart>; // necessary bc args is optional on Zod type\n\n/**\nTool result content part of a prompt. It contains the result of the tool call with the matching ID.\n */\nexport interface ToolResultPart {\n  type: 'tool-result';\n\n  /**\nID of the tool call that this result is associated with.\n */\n  toolCallId: string;\n\n  /**\nName of the tool that generated this result.\n  */\n  toolName: string;\n\n  /**\nResult of the tool call. This is a JSON-serializable object.\n   */\n  result: unknown;\n\n  /**\nMulti-part content of the tool result. Only for tools that support multipart results.\n   */\n  experimental_content?: ToolResultContent;\n\n  /**\nOptional flag if the result is an error or an error message.\n   */\n  isError?: boolean;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const toolResultPartSchema: z.ZodType<ToolResultPart> = z.object({\n  type: z.literal('tool-result'),\n  toolCallId: z.string(),\n  toolName: z.string(),\n  result: z.unknown(),\n  content: toolResultContentSchema.optional(),\n  isError: z.boolean().optional(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n}) as z.ZodType<ToolResultPart>; // necessary bc result is optional on Zod type\n", "import { z } from 'zod';\n\nexport type ToolResultContent = Array<\n  | {\n      type: 'text';\n      text: string;\n    }\n  | {\n      type: 'image';\n      data: string; // base64 encoded png image, e.g. screenshot\n      mimeType?: string; // e.g. 'image/png';\n    }\n>;\n\nexport const toolResultContentSchema: z.ZodType<ToolResultContent> = z.array(\n  z.union([\n    z.object({ type: z.literal('text'), text: z.string() }),\n    z.object({\n      type: z.literal('image'),\n      data: z.string(),\n      mimeType: z.string().optional(),\n    }),\n  ]),\n);\n\nexport function isToolResultContent(\n  value: unknown,\n): value is ToolResultContent {\n  if (!Array.isArray(value) || value.length === 0) {\n    return false;\n  }\n\n  return value.every(part => {\n    if (typeof part !== 'object' || part === null) {\n      return false;\n    }\n\n    if (part.type === 'text') {\n      return typeof part.text === 'string';\n    }\n\n    if (part.type === 'image') {\n      return (\n        typeof part.data === 'string' &&\n        (part.mimeType === undefined || typeof part.mimeType === 'string')\n      );\n    }\n\n    return false;\n  });\n}\n", "/**\nRepresents the number of tokens used in a prompt and completion.\n */\nexport type LanguageModelUsage = {\n  /**\nThe number of tokens used in the prompt.\n   */\n  promptTokens: number;\n\n  /**\nThe number of tokens used in the completion.\n */\n  completionTokens: number;\n\n  /**\nThe total number of tokens used (promptTokens + completionTokens).\n   */\n  totalTokens: number;\n};\n\n/**\nRepresents the number of tokens used in an embedding.\n */\nexport type EmbeddingModelUsage = {\n  /**\nThe number of tokens used in the embedding.\n   */\n  tokens: number;\n};\n\nexport function calculateLanguageModelUsage({\n  promptTokens,\n  completionTokens,\n}: {\n  promptTokens: number;\n  completionTokens: number;\n}): LanguageModelUsage {\n  return {\n    promptTokens,\n    completionTokens,\n    totalTokens: promptTokens + completionTokens,\n  };\n}\n\nexport function addLanguageModelUsage(\n  usage1: LanguageModelUsage,\n  usage2: LanguageModelUsage,\n): LanguageModelUsage {\n  return {\n    promptTokens: usage1.promptTokens + usage2.promptTokens,\n    completionTokens: usage1.completionTokens + usage2.completionTokens,\n    totalTokens: usage1.totalTokens + usage2.totalTokens,\n  };\n}\n", "import { JSONSchema7 } from '@ai-sdk/provider';\n\nconst DEFAULT_SCHEMA_PREFIX = 'JSON schema:';\nconst DEFAULT_SCHEMA_SUFFIX =\n  'You MUST answer with a JSON object that matches the JSON schema above.';\nconst DEFAULT_GENERIC_SUFFIX = 'You MUST answer with JSON.';\n\nexport function injectJsonInstruction({\n  prompt,\n  schema,\n  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : undefined,\n  schemaSuffix = schema != null\n    ? DEFAULT_SCHEMA_SUFFIX\n    : DEFAULT_GENERIC_SUFFIX,\n}: {\n  prompt?: string;\n  schema?: JSONSchema7;\n  schemaPrefix?: string;\n  schemaSuffix?: string;\n}): string {\n  return [\n    prompt != null && prompt.length > 0 ? prompt : undefined,\n    prompt != null && prompt.length > 0 ? '' : undefined, // add a newline if prompt is not null\n    schemaPrefix,\n    schema != null ? JSON.stringify(schema) : undefined,\n    schemaSuffix,\n  ]\n    .filter(line => line != null)\n    .join('\\n');\n}\n", "import {\n  isJSONArray,\n  isJSONObject,\n  JSONObject,\n  JSONSchema7,\n  JSONValue,\n  TypeValidationError,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { safeValidateTypes, ValidationResult } from '@ai-sdk/provider-utils';\nimport { asSchema, DeepPartial, Schema } from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { NoObjectGeneratedError } from '../../errors/no-object-generated-error';\nimport {\n  AsyncIterableStream,\n  createAsyncIterableStream,\n} from '../util/async-iterable-stream';\nimport { ObjectStreamPart } from './stream-object-result';\nimport {\n  FinishReason,\n  LanguageModelResponseMetadata,\n  LanguageModelUsage,\n} from '../types';\n\nexport interface OutputStrategy<PARTIAL, RESULT, ELEMENT_STREAM> {\n  readonly type: 'object' | 'array' | 'enum' | 'no-schema';\n  readonly jsonSchema: JSONSchema7 | undefined;\n\n  validatePartialResult({\n    value,\n    textDelta,\n    isFinalDelta,\n  }: {\n    value: JSONValue;\n    textDelta: string;\n    isFirstDelta: boolean;\n    isFinalDelta: boolean;\n    latestObject: PARTIAL | undefined;\n  }): ValidationResult<{\n    partial: PARTIAL;\n    textDelta: string;\n  }>;\n  validateFinalResult(\n    value: JSONValue | undefined,\n    context: {\n      text: string;\n      response: LanguageModelResponseMetadata;\n      usage: LanguageModelUsage;\n    },\n  ): ValidationResult<RESULT>;\n\n  createElementStream(\n    originalStream: ReadableStream<ObjectStreamPart<PARTIAL>>,\n  ): ELEMENT_STREAM;\n}\n\nconst noSchemaOutputStrategy: OutputStrategy<JSONValue, JSONValue, never> = {\n  type: 'no-schema',\n  jsonSchema: undefined,\n\n  validatePartialResult({ value, textDelta }) {\n    return { success: true, value: { partial: value, textDelta } };\n  },\n\n  validateFinalResult(\n    value: JSONValue | undefined,\n    context: {\n      text: string;\n      response: LanguageModelResponseMetadata;\n      usage: LanguageModelUsage;\n      finishReason: FinishReason;\n    },\n  ): ValidationResult<JSONValue> {\n    return value === undefined\n      ? {\n          success: false,\n          error: new NoObjectGeneratedError({\n            message: 'No object generated: response did not match schema.',\n            text: context.text,\n            response: context.response,\n            usage: context.usage,\n            finishReason: context.finishReason,\n          }),\n        }\n      : { success: true, value };\n  },\n\n  createElementStream() {\n    throw new UnsupportedFunctionalityError({\n      functionality: 'element streams in no-schema mode',\n    });\n  },\n};\n\nconst objectOutputStrategy = <OBJECT>(\n  schema: Schema<OBJECT>,\n): OutputStrategy<DeepPartial<OBJECT>, OBJECT, never> => ({\n  type: 'object',\n  jsonSchema: schema.jsonSchema,\n\n  validatePartialResult({ value, textDelta }) {\n    return {\n      success: true,\n      value: {\n        // Note: currently no validation of partial results:\n        partial: value as DeepPartial<OBJECT>,\n        textDelta,\n      },\n    };\n  },\n\n  validateFinalResult(value: JSONValue | undefined): ValidationResult<OBJECT> {\n    return safeValidateTypes({ value, schema });\n  },\n\n  createElementStream() {\n    throw new UnsupportedFunctionalityError({\n      functionality: 'element streams in object mode',\n    });\n  },\n});\n\nconst arrayOutputStrategy = <ELEMENT>(\n  schema: Schema<ELEMENT>,\n): OutputStrategy<ELEMENT[], ELEMENT[], AsyncIterableStream<ELEMENT>> => {\n  // remove $schema from schema.jsonSchema:\n  const { $schema, ...itemSchema } = schema.jsonSchema;\n\n  return {\n    type: 'enum',\n\n    // wrap in object that contains array of elements, since most LLMs will not\n    // be able to generate an array directly:\n    // possible future optimization: use arrays directly when model supports grammar-guided generation\n    jsonSchema: {\n      $schema: 'http://json-schema.org/draft-07/schema#',\n      type: 'object',\n      properties: {\n        elements: { type: 'array', items: itemSchema },\n      },\n      required: ['elements'],\n      additionalProperties: false,\n    },\n\n    validatePartialResult({ value, latestObject, isFirstDelta, isFinalDelta }) {\n      // check that the value is an object that contains an array of elements:\n      if (!isJSONObject(value) || !isJSONArray(value.elements)) {\n        return {\n          success: false,\n          error: new TypeValidationError({\n            value,\n            cause: 'value must be an object that contains an array of elements',\n          }),\n        };\n      }\n\n      const inputArray = value.elements as Array<JSONObject>;\n      const resultArray: Array<ELEMENT> = [];\n\n      for (let i = 0; i < inputArray.length; i++) {\n        const element = inputArray[i];\n        const result = safeValidateTypes({ value: element, schema });\n\n        // special treatment for last processed element:\n        // ignore parse or validation failures, since they indicate that the\n        // last element is incomplete and should not be included in the result,\n        // unless it is the final delta\n        if (i === inputArray.length - 1 && !isFinalDelta) {\n          continue;\n        }\n\n        if (!result.success) {\n          return result;\n        }\n\n        resultArray.push(result.value);\n      }\n\n      // calculate delta:\n      const publishedElementCount = latestObject?.length ?? 0;\n\n      let textDelta = '';\n\n      if (isFirstDelta) {\n        textDelta += '[';\n      }\n\n      if (publishedElementCount > 0) {\n        textDelta += ',';\n      }\n\n      textDelta += resultArray\n        .slice(publishedElementCount) // only new elements\n        .map(element => JSON.stringify(element))\n        .join(',');\n\n      if (isFinalDelta) {\n        textDelta += ']';\n      }\n\n      return {\n        success: true,\n        value: {\n          partial: resultArray,\n          textDelta,\n        },\n      };\n    },\n\n    validateFinalResult(\n      value: JSONValue | undefined,\n    ): ValidationResult<Array<ELEMENT>> {\n      // check that the value is an object that contains an array of elements:\n      if (!isJSONObject(value) || !isJSONArray(value.elements)) {\n        return {\n          success: false,\n          error: new TypeValidationError({\n            value,\n            cause: 'value must be an object that contains an array of elements',\n          }),\n        };\n      }\n\n      const inputArray = value.elements as Array<JSONObject>;\n\n      // check that each element in the array is of the correct type:\n      for (const element of inputArray) {\n        const result = safeValidateTypes({ value: element, schema });\n        if (!result.success) {\n          return result;\n        }\n      }\n\n      return { success: true, value: inputArray as Array<ELEMENT> };\n    },\n\n    createElementStream(\n      originalStream: ReadableStream<ObjectStreamPart<ELEMENT[]>>,\n    ) {\n      let publishedElements = 0;\n\n      return createAsyncIterableStream(\n        originalStream.pipeThrough(\n          new TransformStream<ObjectStreamPart<ELEMENT[]>, ELEMENT>({\n            transform(chunk, controller) {\n              switch (chunk.type) {\n                case 'object': {\n                  const array = chunk.object;\n\n                  // publish new elements one by one:\n                  for (\n                    ;\n                    publishedElements < array.length;\n                    publishedElements++\n                  ) {\n                    controller.enqueue(array[publishedElements]);\n                  }\n\n                  break;\n                }\n\n                case 'text-delta':\n                case 'finish':\n                case 'error': // suppress error (use onError instead)\n                  break;\n\n                default: {\n                  const _exhaustiveCheck: never = chunk;\n                  throw new Error(\n                    `Unsupported chunk type: ${_exhaustiveCheck}`,\n                  );\n                }\n              }\n            },\n          }),\n        ),\n      );\n    },\n  };\n};\n\nconst enumOutputStrategy = <ENUM extends string>(\n  enumValues: Array<ENUM>,\n): OutputStrategy<ENUM, ENUM, never> => {\n  return {\n    type: 'enum',\n\n    // wrap in object that contains result, since most LLMs will not\n    // be able to generate an enum value directly:\n    // possible future optimization: use enums directly when model supports top-level enums\n    jsonSchema: {\n      $schema: 'http://json-schema.org/draft-07/schema#',\n      type: 'object',\n      properties: {\n        result: { type: 'string', enum: enumValues },\n      },\n      required: ['result'],\n      additionalProperties: false,\n    },\n\n    validateFinalResult(value: JSONValue | undefined): ValidationResult<ENUM> {\n      // check that the value is an object that contains an array of elements:\n      if (!isJSONObject(value) || typeof value.result !== 'string') {\n        return {\n          success: false,\n          error: new TypeValidationError({\n            value,\n            cause:\n              'value must be an object that contains a string in the \"result\" property.',\n          }),\n        };\n      }\n\n      const result = value.result as string;\n\n      return enumValues.includes(result as ENUM)\n        ? { success: true, value: result as ENUM }\n        : {\n            success: false,\n            error: new TypeValidationError({\n              value,\n              cause: 'value must be a string in the enum',\n            }),\n          };\n    },\n\n    validatePartialResult() {\n      // no streaming in enum mode\n      throw new UnsupportedFunctionalityError({\n        functionality: 'partial results in enum mode',\n      });\n    },\n\n    createElementStream() {\n      // no streaming in enum mode\n      throw new UnsupportedFunctionalityError({\n        functionality: 'element streams in enum mode',\n      });\n    },\n  };\n};\n\nexport function getOutputStrategy<SCHEMA>({\n  output,\n  schema,\n  enumValues,\n}: {\n  output: 'object' | 'array' | 'enum' | 'no-schema';\n  schema?: z.Schema<SCHEMA, z.ZodTypeDef, any> | Schema<SCHEMA>;\n  enumValues?: Array<SCHEMA>;\n}): OutputStrategy<any, any, any> {\n  switch (output) {\n    case 'object':\n      return objectOutputStrategy(asSchema(schema!));\n    case 'array':\n      return arrayOutputStrategy(asSchema(schema!));\n    case 'enum':\n      return enumOutputStrategy(enumValues! as Array<string>);\n    case 'no-schema':\n      return noSchemaOutputStrategy;\n    default: {\n      const _exhaustiveCheck: never = output;\n      throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n    }\n  }\n}\n", "export type AsyncIterableStream<T> = AsyncIterable<T> & ReadableStream<T>;\n\nexport function createAsyncIterableStream<T>(\n  source: ReadableStream<T>,\n): AsyncIterableStream<T> {\n  const stream = source.pipeThrough(new TransformStream<T, T>());\n\n  (stream as AsyncIterableStream<T>)[Symbol.asyncIterator] = () => {\n    const reader = stream.getReader();\n    return {\n      async next(): Promise<IteratorResult<T>> {\n        const { done, value } = await reader.read();\n        return done ? { done: true, value: undefined } : { done: false, value };\n      },\n    };\n  };\n\n  return stream as AsyncIterableStream<T>;\n}\n", "import { z } from 'zod';\nimport { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport { Schema } from '@ai-sdk/ui-utils';\n\nexport function validateObjectGenerationInput({\n  output,\n  mode,\n  schema,\n  schemaName,\n  schemaDescription,\n  enumValues,\n}: {\n  output?: 'object' | 'array' | 'enum' | 'no-schema';\n  schema?: z.Schema<any, z.ZodTypeDef, any> | Schema<any>;\n  schemaName?: string;\n  schemaDescription?: string;\n  enumValues?: Array<unknown>;\n  mode?: 'auto' | 'json' | 'tool';\n}) {\n  if (\n    output != null &&\n    output !== 'object' &&\n    output !== 'array' &&\n    output !== 'enum' &&\n    output !== 'no-schema'\n  ) {\n    throw new InvalidArgumentError({\n      parameter: 'output',\n      value: output,\n      message: 'Invalid output type.',\n    });\n  }\n\n  if (output === 'no-schema') {\n    if (mode === 'auto' || mode === 'tool') {\n      throw new InvalidArgumentError({\n        parameter: 'mode',\n        value: mode,\n        message: 'Mode must be \"json\" for no-schema output.',\n      });\n    }\n\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Schema is not supported for no-schema output.',\n      });\n    }\n\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaDescription',\n        value: schemaDescription,\n        message: 'Schema description is not supported for no-schema output.',\n      });\n    }\n\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaName',\n        value: schemaName,\n        message: 'Schema name is not supported for no-schema output.',\n      });\n    }\n\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are not supported for no-schema output.',\n      });\n    }\n  }\n\n  if (output === 'object') {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Schema is required for object output.',\n      });\n    }\n\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are not supported for object output.',\n      });\n    }\n  }\n\n  if (output === 'array') {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Element schema is required for array output.',\n      });\n    }\n\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are not supported for array output.',\n      });\n    }\n  }\n\n  if (output === 'enum') {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Schema is not supported for enum output.',\n      });\n    }\n\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaDescription',\n        value: schemaDescription,\n        message: 'Schema description is not supported for enum output.',\n      });\n    }\n\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaName',\n        value: schemaName,\n        message: 'Schema name is not supported for enum output.',\n      });\n    }\n\n    if (enumValues == null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are required for enum output.',\n      });\n    }\n\n    for (const value of enumValues) {\n      if (typeof value !== 'string') {\n        throw new InvalidArgumentError({\n          parameter: 'enumValues',\n          value,\n          message: 'Enum values must be strings.',\n        });\n      }\n    }\n  }\n}\n", "/**\n * Helper utility to serialize prompt content for OpenTelemetry tracing.\n * It is initially created because normalized LanguageModelV1Prompt carries\n * images as Uint8Arrays, on which JSON.stringify acts weirdly, converting\n * them to objects with stringified indices as keys, e.g. {\"0\": 42, \"1\": 69 }.\n */\n\nimport {\n  LanguageModelV1ImagePart,\n  LanguageModelV1Message,\n  LanguageModelV1Prompt,\n  LanguageModelV1ProviderMetadata,\n} from '@ai-sdk/provider';\nimport { convertDataContentToBase64String } from './data-content';\n\nexport function stringifyForTelemetry(prompt: LanguageModelV1Prompt): string {\n  const processedPrompt = prompt.map((message: LanguageModelV1Message) => {\n    return {\n      ...message,\n      content:\n        typeof message.content === 'string'\n          ? message.content\n          : message.content.map(processPart),\n    };\n  });\n\n  return JSON.stringify(processedPrompt);\n}\n\ntype MessageContentPart = Exclude<\n  LanguageModelV1Message['content'],\n  string\n>[number];\ntype ProcessedMessageContentPart =\n  | Exclude<MessageContentPart, LanguageModelV1ImagePart>\n  | {\n      type: 'image';\n      image: string | URL;\n      mimeType?: string;\n      providerMetadata?: LanguageModelV1ProviderMetadata;\n    };\n\nfunction processPart(part: MessageContentPart): ProcessedMessageContentPart {\n  if (part.type === 'image') {\n    return {\n      ...part,\n      image:\n        part.image instanceof Uint8Array\n          ? convertDataContentToBase64String(part.image)\n          : part.image,\n    };\n  }\n  return part;\n}\n", "import {\n  JSONValue,\n  LanguageModelV1CallOptions,\n  LanguageModelV1FinishReason,\n  LanguageModelV1StreamPart,\n} from '@ai-sdk/provider';\nimport { createIdGenerator } from '@ai-sdk/provider-utils';\nimport {\n  DeepPartial,\n  Schema,\n  isDeepEqualData,\n  parsePartialJson,\n} from '@ai-sdk/ui-utils';\nimport { ServerResponse } from 'http';\nimport { z } from 'zod';\nimport { NoObjectGeneratedError } from '../../errors/no-object-generated-error';\nimport { DelayedPromise } from '../../util/delayed-promise';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  CallWarning,\n  FinishReason,\n  LanguageModel,\n  LogProbs,\n} from '../types/language-model';\nimport { LanguageModelRequestMetadata } from '../types/language-model-request-metadata';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { ProviderMetadata, ProviderOptions } from '../types/provider-metadata';\nimport {\n  LanguageModelUsage,\n  calculateLanguageModelUsage,\n} from '../types/usage';\nimport {\n  AsyncIterableStream,\n  createAsyncIterableStream,\n} from '../util/async-iterable-stream';\nimport { createStitchableStream } from '../util/create-stitchable-stream';\nimport { now as originalNow } from '../util/now';\nimport { prepareOutgoingHttpHeaders } from '../util/prepare-outgoing-http-headers';\nimport { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { writeToServerResponse } from '../util/write-to-server-response';\nimport { injectJsonInstruction } from './inject-json-instruction';\nimport { OutputStrategy, getOutputStrategy } from './output-strategy';\nimport { ObjectStreamPart, StreamObjectResult } from './stream-object-result';\nimport { validateObjectGenerationInput } from './validate-object-generation-input';\nimport { stringifyForTelemetry } from '../prompt/stringify-for-telemetry';\n\nconst originalGenerateId = createIdGenerator({ prefix: 'aiobj', size: 24 });\n\n/**\nCallback that is set using the `onError` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamObjectOnErrorCallback = (event: {\n  error: unknown;\n}) => Promise<void> | void;\n\n/**\nCallback that is set using the `onFinish` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamObjectOnFinishCallback<RESULT> = (event: {\n  /**\nThe token usage of the generated response.\n*/\n  usage: LanguageModelUsage;\n\n  /**\nThe generated object. Can be undefined if the final object does not match the schema.\n*/\n  object: RESULT | undefined;\n\n  /**\nOptional error object. This is e.g. a TypeValidationError when the final object does not match the schema.\n*/\n  error: unknown | undefined;\n\n  /**\nResponse metadata.\n */\n  response: LanguageModelResponseMetadata;\n\n  /**\nWarnings from the model provider (e.g. unsupported settings).\n*/\n  warnings?: CallWarning[];\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n*/\n  providerMetadata: ProviderMetadata | undefined;\n\n  /**\n@deprecated Use `providerMetadata` instead.\n*/\n  experimental_providerMetadata?: ProviderMetadata;\n}) => Promise<void> | void;\n\n/**\nGenerate a structured, typed object for a given prompt and schema using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateObject` instead.\n\n@return\nA result object for accessing the partial object stream and additional information.\n */\nexport function streamObject<OBJECT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output?: 'object' | undefined;\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe schema of the object that the model should generate.\n */\n      schema: z.Schema<OBJECT, z.ZodTypeDef, any> | Schema<OBJECT>;\n\n      /**\nOptional name of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n      onError?: StreamObjectOnErrorCallback;\n\n      /**\nCallback that is called when the LLM response and the final object validation are finished.\n     */\n      onFinish?: StreamObjectOnFinishCallback<OBJECT>;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n        now?: () => number;\n      };\n    },\n): StreamObjectResult<DeepPartial<OBJECT>, OBJECT, never>;\n/**\nGenerate an array with structured, typed elements for a given prompt and element schema using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateObject` instead.\n\n@return\nA result object for accessing the partial object stream and additional information.\n */\nexport function streamObject<ELEMENT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'array';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe element schema of the array that the model should generate.\n */\n      schema: z.Schema<ELEMENT, z.ZodTypeDef, any> | Schema<ELEMENT>;\n\n      /**\nOptional name of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n      onError?: StreamObjectOnErrorCallback;\n\n      /**\nCallback that is called when the LLM response and the final object validation are finished.\n     */\n      onFinish?: StreamObjectOnFinishCallback<Array<ELEMENT>>;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n        now?: () => number;\n      };\n    },\n): StreamObjectResult<\n  Array<ELEMENT>,\n  Array<ELEMENT>,\n  AsyncIterableStream<ELEMENT>\n>;\n/**\nGenerate JSON with any schema for a given prompt using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateObject` instead.\n\n@return\nA result object for accessing the partial object stream and additional information.\n */\nexport function streamObject(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'no-schema';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe mode to use for object generation. Must be \"json\" for no-schema output.\n     */\n      mode?: 'json';\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n      onError?: StreamObjectOnErrorCallback;\n\n      /**\nCallback that is called when the LLM response and the final object validation are finished.\n     */\n      onFinish?: StreamObjectOnFinishCallback<JSONValue>;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n        now?: () => number;\n      };\n    },\n): StreamObjectResult<JSONValue, JSONValue, never>;\nexport function streamObject<SCHEMA, PARTIAL, RESULT, ELEMENT_STREAM>({\n  model,\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  output = 'object',\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  onError,\n  onFinish,\n  _internal: {\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n    now = originalNow,\n  } = {},\n  ...settings\n}: Omit<CallSettings, 'stopSequences'> &\n  Prompt & {\n    /**\n     * The expected structure of the output.\n     *\n     * - 'object': Generate a single object that conforms to the schema.\n     * - 'array': Generate an array of objects that conform to the schema.\n     * - 'no-schema': Generate any JSON object. No schema is specified.\n     *\n     * Default is 'object' if not specified.\n     */\n    output?: 'object' | 'array' | 'no-schema';\n\n    model: LanguageModel;\n    schema?: z.Schema<SCHEMA, z.ZodTypeDef, any> | Schema<SCHEMA>;\n    schemaName?: string;\n    schemaDescription?: string;\n    mode?: 'auto' | 'json' | 'tool';\n    experimental_telemetry?: TelemetrySettings;\n    providerOptions?: ProviderOptions;\n    experimental_providerMetadata?: ProviderMetadata;\n    onError?: StreamObjectOnErrorCallback;\n    onFinish?: StreamObjectOnFinishCallback<RESULT>;\n    _internal?: {\n      generateId?: () => string;\n      currentDate?: () => Date;\n      now?: () => number;\n    };\n  }): StreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM> {\n  validateObjectGenerationInput({\n    output,\n    mode,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n  });\n\n  const outputStrategy = getOutputStrategy({ output, schema: inputSchema });\n\n  // automatically set mode to 'json' for no-schema output\n  if (outputStrategy.type === 'no-schema' && mode === undefined) {\n    mode = 'json';\n  }\n\n  return new DefaultStreamObjectResult({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    mode,\n    onError,\n    onFinish,\n    generateId,\n    currentDate,\n    now,\n  });\n}\n\nclass DefaultStreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM>\n  implements StreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM>\n{\n  private readonly objectPromise = new DelayedPromise<RESULT>();\n  private readonly usagePromise = new DelayedPromise<LanguageModelUsage>();\n  private readonly providerMetadataPromise = new DelayedPromise<\n    ProviderMetadata | undefined\n  >();\n  private readonly warningsPromise = new DelayedPromise<\n    CallWarning[] | undefined\n  >();\n  private readonly requestPromise =\n    new DelayedPromise<LanguageModelRequestMetadata>();\n  private readonly responsePromise =\n    new DelayedPromise<LanguageModelResponseMetadata>();\n\n  private readonly baseStream: ReadableStream<ObjectStreamPart<PARTIAL>>;\n\n  private readonly outputStrategy: OutputStrategy<\n    PARTIAL,\n    RESULT,\n    ELEMENT_STREAM\n  >;\n\n  constructor({\n    model,\n    headers,\n    telemetry,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    mode,\n    onError,\n    onFinish,\n    generateId,\n    currentDate,\n    now,\n  }: {\n    model: LanguageModel;\n    telemetry: TelemetrySettings | undefined;\n    headers: Record<string, string | undefined> | undefined;\n    settings: Omit<CallSettings, 'abortSignal' | 'headers'>;\n    maxRetries: number | undefined;\n    abortSignal: AbortSignal | undefined;\n    outputStrategy: OutputStrategy<PARTIAL, RESULT, ELEMENT_STREAM>;\n    system: Prompt['system'];\n    prompt: Prompt['prompt'];\n    messages: Prompt['messages'];\n    schemaName: string | undefined;\n    schemaDescription: string | undefined;\n    providerOptions: ProviderOptions | undefined;\n    mode: 'auto' | 'json' | 'tool' | undefined;\n    onError: StreamObjectOnErrorCallback | undefined;\n    onFinish: StreamObjectOnFinishCallback<RESULT> | undefined;\n    generateId: () => string;\n    currentDate: () => Date;\n    now: () => number;\n  }) {\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n    });\n\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...settings, maxRetries },\n    });\n\n    const tracer = getTracer(telemetry);\n    const self = this;\n\n    const stitchableStream =\n      createStitchableStream<ObjectStreamPart<PARTIAL>>();\n\n    const eventProcessor = new TransformStream<\n      ObjectStreamPart<PARTIAL>,\n      ObjectStreamPart<PARTIAL>\n    >({\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n\n        if (chunk.type === 'error') {\n          onError?.({ error: chunk.error });\n        }\n      },\n    });\n\n    this.baseStream = stitchableStream.stream.pipeThrough(eventProcessor);\n\n    recordSpan({\n      name: 'ai.streamObject',\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: 'ai.streamObject',\n            telemetry,\n          }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          'ai.prompt': {\n            input: () => JSON.stringify({ system, prompt, messages }),\n          },\n          'ai.schema':\n            outputStrategy.jsonSchema != null\n              ? { input: () => JSON.stringify(outputStrategy.jsonSchema) }\n              : undefined,\n          'ai.schema.name': schemaName,\n          'ai.schema.description': schemaDescription,\n          'ai.settings.output': outputStrategy.type,\n          'ai.settings.mode': mode,\n        },\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async rootSpan => {\n        // use the default provider mode when the mode is set to 'auto' or unspecified\n        if (mode === 'auto' || mode == null) {\n          mode = model.defaultObjectGenerationMode;\n        }\n\n        let callOptions: LanguageModelV1CallOptions;\n        let transformer: Transformer<\n          LanguageModelV1StreamPart,\n          string | Omit<LanguageModelV1StreamPart, 'text-delta'>\n        >;\n\n        switch (mode) {\n          case 'json': {\n            const standardizedPrompt = standardizePrompt({\n              prompt: {\n                system:\n                  outputStrategy.jsonSchema == null\n                    ? injectJsonInstruction({ prompt: system })\n                    : model.supportsStructuredOutputs\n                      ? system\n                      : injectJsonInstruction({\n                          prompt: system,\n                          schema: outputStrategy.jsonSchema,\n                        }),\n                prompt,\n                messages,\n              },\n              tools: undefined,\n            });\n\n            callOptions = {\n              mode: {\n                type: 'object-json',\n                schema: outputStrategy.jsonSchema,\n                name: schemaName,\n                description: schemaDescription,\n              },\n              ...prepareCallSettings(settings),\n              inputFormat: standardizedPrompt.type,\n              prompt: await convertToLanguageModelPrompt({\n                prompt: standardizedPrompt,\n                modelSupportsImageUrls: model.supportsImageUrls,\n                modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context\n              }),\n              providerMetadata: providerOptions,\n              abortSignal,\n              headers,\n            };\n\n            transformer = {\n              transform: (chunk, controller) => {\n                switch (chunk.type) {\n                  case 'text-delta':\n                    controller.enqueue(chunk.textDelta);\n                    break;\n                  case 'response-metadata':\n                  case 'finish':\n                  case 'error':\n                    controller.enqueue(chunk);\n                    break;\n                }\n              },\n            };\n\n            break;\n          }\n\n          case 'tool': {\n            const standardizedPrompt = standardizePrompt({\n              prompt: { system, prompt, messages },\n              tools: undefined,\n            });\n\n            callOptions = {\n              mode: {\n                type: 'object-tool',\n                tool: {\n                  type: 'function',\n                  name: schemaName ?? 'json',\n                  description:\n                    schemaDescription ?? 'Respond with a JSON object.',\n                  parameters: outputStrategy.jsonSchema!,\n                },\n              },\n              ...prepareCallSettings(settings),\n              inputFormat: standardizedPrompt.type,\n              prompt: await convertToLanguageModelPrompt({\n                prompt: standardizedPrompt,\n                modelSupportsImageUrls: model.supportsImageUrls,\n                modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context,\n              }),\n              providerMetadata: providerOptions,\n              abortSignal,\n              headers,\n            };\n\n            transformer = {\n              transform(chunk, controller) {\n                switch (chunk.type) {\n                  case 'tool-call-delta':\n                    controller.enqueue(chunk.argsTextDelta);\n                    break;\n                  case 'response-metadata':\n                  case 'finish':\n                  case 'error':\n                    controller.enqueue(chunk);\n                    break;\n                }\n              },\n            };\n\n            break;\n          }\n\n          case undefined: {\n            throw new Error(\n              'Model does not have a default object generation mode.',\n            );\n          }\n\n          default: {\n            const _exhaustiveCheck: never = mode;\n            throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n          }\n        }\n\n        const {\n          result: { stream, warnings, rawResponse, request },\n          doStreamSpan,\n          startTimestampMs,\n        } = await retry(() =>\n          recordSpan({\n            name: 'ai.streamObject.doStream',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.streamObject.doStream',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                'ai.prompt.format': {\n                  input: () => callOptions.inputFormat,\n                },\n                'ai.prompt.messages': {\n                  input: () => stringifyForTelemetry(callOptions.prompt),\n                },\n                'ai.settings.mode': mode,\n\n                // standardized gen-ai llm span attributes:\n                'gen_ai.system': model.provider,\n                'gen_ai.request.model': model.modelId,\n                'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                'gen_ai.request.max_tokens': settings.maxTokens,\n                'gen_ai.request.presence_penalty': settings.presencePenalty,\n                'gen_ai.request.temperature': settings.temperature,\n                'gen_ai.request.top_k': settings.topK,\n                'gen_ai.request.top_p': settings.topP,\n              },\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async doStreamSpan => ({\n              startTimestampMs: now(),\n              doStreamSpan,\n              result: await model.doStream(callOptions),\n            }),\n          }),\n        );\n\n        self.requestPromise.resolve(request ?? {});\n\n        // store information for onFinish callback:\n        let usage: LanguageModelUsage | undefined;\n        let finishReason: LanguageModelV1FinishReason | undefined;\n        let providerMetadata: ProviderMetadata | undefined;\n        let object: RESULT | undefined;\n        let error: unknown | undefined;\n\n        // pipe chunks through a transformation stream that extracts metadata:\n        let accumulatedText = '';\n        let textDelta = '';\n        let response: {\n          id: string;\n          timestamp: Date;\n          modelId: string;\n        } = {\n          id: generateId(),\n          timestamp: currentDate(),\n          modelId: model.modelId,\n        };\n\n        // Keep track of raw parse result before type validation, since e.g. Zod might\n        // change the object by mapping properties.\n        let latestObjectJson: JSONValue | undefined = undefined;\n        let latestObject: PARTIAL | undefined = undefined;\n        let isFirstChunk = true;\n        let isFirstDelta = true;\n\n        const transformedStream = stream\n          .pipeThrough(new TransformStream(transformer))\n          .pipeThrough(\n            new TransformStream<\n              string | ObjectStreamInputPart,\n              ObjectStreamPart<PARTIAL>\n            >({\n              async transform(chunk, controller): Promise<void> {\n                // Telemetry event for first chunk:\n                if (isFirstChunk) {\n                  const msToFirstChunk = now() - startTimestampMs;\n\n                  isFirstChunk = false;\n\n                  doStreamSpan.addEvent('ai.stream.firstChunk', {\n                    'ai.stream.msToFirstChunk': msToFirstChunk,\n                  });\n\n                  doStreamSpan.setAttributes({\n                    'ai.stream.msToFirstChunk': msToFirstChunk,\n                  });\n                }\n\n                // process partial text chunks\n                if (typeof chunk === 'string') {\n                  accumulatedText += chunk;\n                  textDelta += chunk;\n\n                  const { value: currentObjectJson, state: parseState } =\n                    parsePartialJson(accumulatedText);\n\n                  if (\n                    currentObjectJson !== undefined &&\n                    !isDeepEqualData(latestObjectJson, currentObjectJson)\n                  ) {\n                    const validationResult =\n                      outputStrategy.validatePartialResult({\n                        value: currentObjectJson,\n                        textDelta,\n                        latestObject,\n                        isFirstDelta,\n                        isFinalDelta: parseState === 'successful-parse',\n                      });\n\n                    if (\n                      validationResult.success &&\n                      !isDeepEqualData(\n                        latestObject,\n                        validationResult.value.partial,\n                      )\n                    ) {\n                      // inside inner check to correctly parse the final element in array mode:\n                      latestObjectJson = currentObjectJson;\n                      latestObject = validationResult.value.partial;\n\n                      controller.enqueue({\n                        type: 'object',\n                        object: latestObject,\n                      });\n\n                      controller.enqueue({\n                        type: 'text-delta',\n                        textDelta: validationResult.value.textDelta,\n                      });\n\n                      textDelta = '';\n                      isFirstDelta = false;\n                    }\n                  }\n\n                  return;\n                }\n\n                switch (chunk.type) {\n                  case 'response-metadata': {\n                    response = {\n                      id: chunk.id ?? response.id,\n                      timestamp: chunk.timestamp ?? response.timestamp,\n                      modelId: chunk.modelId ?? response.modelId,\n                    };\n                    break;\n                  }\n\n                  case 'finish': {\n                    // send final text delta:\n                    if (textDelta !== '') {\n                      controller.enqueue({ type: 'text-delta', textDelta });\n                    }\n\n                    // store finish reason for telemetry:\n                    finishReason = chunk.finishReason;\n\n                    // store usage and metadata for promises and onFinish callback:\n                    usage = calculateLanguageModelUsage(chunk.usage);\n                    providerMetadata = chunk.providerMetadata;\n\n                    controller.enqueue({ ...chunk, usage, response });\n\n                    // resolve promises that can be resolved now:\n                    self.usagePromise.resolve(usage);\n                    self.providerMetadataPromise.resolve(providerMetadata);\n                    self.responsePromise.resolve({\n                      ...response,\n                      headers: rawResponse?.headers,\n                    });\n\n                    // resolve the object promise with the latest object:\n                    const validationResult = outputStrategy.validateFinalResult(\n                      latestObjectJson,\n                      {\n                        text: accumulatedText,\n                        response,\n                        usage,\n                      },\n                    );\n\n                    if (validationResult.success) {\n                      object = validationResult.value;\n                      self.objectPromise.resolve(object);\n                    } else {\n                      error = new NoObjectGeneratedError({\n                        message:\n                          'No object generated: response did not match schema.',\n                        cause: validationResult.error,\n                        text: accumulatedText,\n                        response,\n                        usage,\n                        finishReason: finishReason,\n                      });\n                      self.objectPromise.reject(error);\n                    }\n\n                    break;\n                  }\n\n                  default: {\n                    controller.enqueue(chunk);\n                    break;\n                  }\n                }\n              },\n\n              // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n              async flush(controller) {\n                try {\n                  const finalUsage = usage ?? {\n                    promptTokens: NaN,\n                    completionTokens: NaN,\n                    totalTokens: NaN,\n                  };\n\n                  doStreamSpan.setAttributes(\n                    selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        'ai.response.finishReason': finishReason,\n                        'ai.response.object': {\n                          output: () => JSON.stringify(object),\n                        },\n                        'ai.response.id': response.id,\n                        'ai.response.model': response.modelId,\n                        'ai.response.timestamp':\n                          response.timestamp.toISOString(),\n\n                        'ai.usage.promptTokens': finalUsage.promptTokens,\n                        'ai.usage.completionTokens':\n                          finalUsage.completionTokens,\n\n                        // standardized gen-ai llm span attributes:\n                        'gen_ai.response.finish_reasons': [finishReason],\n                        'gen_ai.response.id': response.id,\n                        'gen_ai.response.model': response.modelId,\n                        'gen_ai.usage.input_tokens': finalUsage.promptTokens,\n                        'gen_ai.usage.output_tokens':\n                          finalUsage.completionTokens,\n                      },\n                    }),\n                  );\n\n                  // finish doStreamSpan before other operations for correct timing:\n                  doStreamSpan.end();\n\n                  // Add response information to the root span:\n                  rootSpan.setAttributes(\n                    selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        'ai.usage.promptTokens': finalUsage.promptTokens,\n                        'ai.usage.completionTokens':\n                          finalUsage.completionTokens,\n                        'ai.response.object': {\n                          output: () => JSON.stringify(object),\n                        },\n                      },\n                    }),\n                  );\n\n                  // call onFinish callback:\n                  await onFinish?.({\n                    usage: finalUsage,\n                    object,\n                    error,\n                    response: {\n                      ...response,\n                      headers: rawResponse?.headers,\n                    },\n                    warnings,\n                    providerMetadata,\n                    experimental_providerMetadata: providerMetadata,\n                  });\n                } catch (error) {\n                  controller.enqueue({ type: 'error', error });\n                } finally {\n                  rootSpan.end();\n                }\n              },\n            }),\n          );\n\n        stitchableStream.addStream(transformedStream);\n      },\n    })\n      .catch(error => {\n        // add an empty stream with an error to break the stream:\n        stitchableStream.addStream(\n          new ReadableStream({\n            start(controller) {\n              controller.enqueue({ type: 'error', error });\n              controller.close();\n            },\n          }),\n        );\n      })\n      .finally(() => {\n        stitchableStream.close();\n      });\n\n    this.outputStrategy = outputStrategy;\n  }\n\n  get object() {\n    return this.objectPromise.value;\n  }\n\n  get usage() {\n    return this.usagePromise.value;\n  }\n\n  get experimental_providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n\n  get providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n\n  get warnings() {\n    return this.warningsPromise.value;\n  }\n\n  get request() {\n    return this.requestPromise.value;\n  }\n\n  get response() {\n    return this.responsePromise.value;\n  }\n\n  get partialObjectStream(): AsyncIterableStream<PARTIAL> {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream<ObjectStreamPart<PARTIAL>, PARTIAL>({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case 'object':\n                controller.enqueue(chunk.object);\n                break;\n\n              case 'text-delta':\n              case 'finish':\n              case 'error': // suppress error (use onError instead)\n                break;\n\n              default: {\n                const _exhaustiveCheck: never = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  get elementStream(): ELEMENT_STREAM {\n    return this.outputStrategy.createElementStream(this.baseStream);\n  }\n\n  get textStream(): AsyncIterableStream<string> {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream<ObjectStreamPart<PARTIAL>, string>({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case 'text-delta':\n                controller.enqueue(chunk.textDelta);\n                break;\n\n              case 'object':\n              case 'finish':\n              case 'error': // suppress error (use onError instead)\n                break;\n\n              default: {\n                const _exhaustiveCheck: never = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  get fullStream(): AsyncIterableStream<ObjectStreamPart<PARTIAL>> {\n    return createAsyncIterableStream(this.baseStream);\n  }\n\n  pipeTextStreamToResponse(response: ServerResponse, init?: ResponseInit) {\n    writeToServerResponse({\n      response,\n      status: init?.status,\n      statusText: init?.statusText,\n      headers: prepareOutgoingHttpHeaders(init?.headers, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n      stream: this.textStream.pipeThrough(new TextEncoderStream()),\n    });\n  }\n\n  toTextStreamResponse(init?: ResponseInit): Response {\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: init?.status ?? 200,\n      headers: prepareResponseHeaders(init?.headers, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n    });\n  }\n}\n\nexport type ObjectStreamInputPart =\n  | {\n      type: 'error';\n      error: unknown;\n    }\n  | {\n      type: 'response-metadata';\n      id?: string;\n      timestamp?: Date;\n      modelId?: string;\n    }\n  | {\n      type: 'finish';\n      finishReason: FinishReason;\n      logprobs?: LogProbs;\n      usage: LanguageModelUsage;\n      providerMetadata?: ProviderMetadata;\n    };\n", "/**\n * Delayed promise. It is only constructed once the value is accessed.\n * This is useful to avoid unhandled promise rejections when the promise is created\n * but not accessed.\n */\nexport class DelayedPromise<T> {\n  private status:\n    | { type: 'pending' }\n    | { type: 'resolved'; value: T }\n    | { type: 'rejected'; error: unknown } = { type: 'pending' };\n  private promise: Promise<T> | undefined;\n  private _resolve: undefined | ((value: T) => void) = undefined;\n  private _reject: undefined | ((error: unknown) => void) = undefined;\n\n  get value(): Promise<T> {\n    if (this.promise) {\n      return this.promise;\n    }\n\n    this.promise = new Promise<T>((resolve, reject) => {\n      if (this.status.type === 'resolved') {\n        resolve(this.status.value);\n      } else if (this.status.type === 'rejected') {\n        reject(this.status.error);\n      }\n\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n\n    return this.promise;\n  }\n\n  resolve(value: T): void {\n    this.status = { type: 'resolved', value };\n\n    if (this.promise) {\n      this._resolve?.(value);\n    }\n  }\n\n  reject(error: unknown): void {\n    this.status = { type: 'rejected', error };\n\n    if (this.promise) {\n      this._reject?.(error);\n    }\n  }\n}\n", "/**\n * Creates a Promise with externally accessible resolve and reject functions.\n *\n * @template T - The type of the value that the Promise will resolve to.\n * @returns An object containing:\n *   - promise: A Promise that can be resolved or rejected externally.\n *   - resolve: A function to resolve the Promise with a value of type T.\n *   - reject: A function to reject the Promise with an error.\n */\nexport function createResolvablePromise<T = any>(): {\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (error: unknown) => void;\n} {\n  let resolve: (value: T) => void;\n  let reject: (error: unknown) => void;\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return {\n    promise,\n    resolve: resolve!,\n    reject: reject!,\n  };\n}\n", "import { createResolvablePromise } from '../../util/create-resolvable-promise';\n\n/**\n * Creates a stitchable stream that can pipe one stream at a time.\n *\n * @template T - The type of values emitted by the streams.\n * @returns {Object} An object containing the stitchable stream and control methods.\n */\nexport function createStitchableStream<T>(): {\n  stream: ReadableStream<T>;\n  addStream: (innerStream: ReadableStream<T>) => void;\n  close: () => void;\n  terminate: () => void;\n} {\n  let innerStreamReaders: ReadableStreamDefaultReader<T>[] = [];\n  let controller: ReadableStreamDefaultController<T> | null = null;\n  let isClosed = false;\n  let waitForNewStream = createResolvablePromise<void>();\n\n  const processPull = async () => {\n    // Case 1: Outer stream is closed and no more inner streams\n    if (isClosed && innerStreamReaders.length === 0) {\n      controller?.close();\n      return;\n    }\n\n    // Case 2: No inner streams available, but outer stream is open\n    // wait for a new inner stream to be added or the outer stream to close\n    if (innerStreamReaders.length === 0) {\n      waitForNewStream = createResolvablePromise<void>();\n      await waitForNewStream.promise;\n      return processPull();\n    }\n\n    try {\n      const { value, done } = await innerStreamReaders[0].read();\n\n      if (done) {\n        // Case 3: Current inner stream is done\n        innerStreamReaders.shift(); // Remove the finished stream\n\n        // Continue pulling from the next stream if available\n        if (innerStreamReaders.length > 0) {\n          await processPull();\n        } else if (isClosed) {\n          controller?.close();\n        }\n      } else {\n        // Case 4: Current inner stream returns an item\n        controller?.enqueue(value);\n      }\n    } catch (error) {\n      // Case 5: Current inner stream throws an error\n      controller?.error(error);\n      innerStreamReaders.shift(); // Remove the errored stream\n\n      if (isClosed && innerStreamReaders.length === 0) {\n        controller?.close();\n      }\n    }\n  };\n\n  return {\n    stream: new ReadableStream<T>({\n      start(controllerParam) {\n        controller = controllerParam;\n      },\n      pull: processPull,\n      async cancel() {\n        for (const reader of innerStreamReaders) {\n          await reader.cancel();\n        }\n        innerStreamReaders = [];\n        isClosed = true;\n      },\n    }),\n    addStream: (innerStream: ReadableStream<T>) => {\n      if (isClosed) {\n        throw new Error('Cannot add inner stream: outer stream is closed');\n      }\n\n      innerStreamReaders.push(innerStream.getReader());\n      waitForNewStream.resolve();\n    },\n\n    /**\n     * Gracefully close the outer stream. This will let the inner streams\n     * finish processing and then close the outer stream.\n     */\n    close: () => {\n      isClosed = true;\n      waitForNewStream.resolve();\n\n      if (innerStreamReaders.length === 0) {\n        controller?.close();\n      }\n    },\n\n    /**\n     * Immediately close the outer stream. This will cancel all inner streams\n     * and close the outer stream.\n     */\n    terminate: () => {\n      isClosed = true;\n      waitForNewStream.resolve();\n\n      innerStreamReaders.forEach(reader => reader.cancel());\n      innerStreamReaders = [];\n      controller?.close();\n    },\n  };\n}\n", "// Shim for performance.now() to support environments that don't have it:\nexport function now(): number {\n  return globalThis?.performance?.now() ?? Date.now();\n}\n", "import { createIdGenerator, IDGenerator } from '@ai-sdk/provider-utils';\nimport { Tracer } from '@opentelemetry/api';\nimport { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport { NoOutputSpecifiedError } from '../../errors/no-output-specified-error';\nimport { ToolExecutionError } from '../../errors/tool-execution-error';\nimport { CoreAssistantMessage, CoreMessage } from '../prompt';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { prepareToolsAndToolChoice } from '../prompt/prepare-tools-and-tool-choice';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { LanguageModel, ToolChoice } from '../types';\nimport { ProviderMetadata, ProviderOptions } from '../types/provider-metadata';\nimport {\n  addLanguageModelUsage,\n  calculateLanguageModelUsage,\n  LanguageModelUsage,\n} from '../types/usage';\nimport { removeTextAfterLastWhitespace } from '../util/remove-text-after-last-whitespace';\nimport { GenerateTextResult } from './generate-text-result';\nimport { DefaultGeneratedFile, GeneratedFile } from './generated-file';\nimport { Output } from './output';\nimport { parseToolCall } from './parse-tool-call';\nimport { asReasoningText, ReasoningDetail } from './reasoning-detail';\nimport { ResponseMessage, StepResult } from './step-result';\nimport { toResponseMessages } from './to-response-messages';\nimport { ToolCallArray } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair';\nimport { ToolResultArray } from './tool-result';\nimport { ToolSet } from './tool-set';\nimport { stringifyForTelemetry } from '../prompt/stringify-for-telemetry';\n\nconst originalGenerateId = createIdGenerator({\n  prefix: 'aitxt',\n  size: 24,\n});\n\nconst originalGenerateMessageId = createIdGenerator({\n  prefix: 'msg',\n  size: 24,\n});\n\n/**\nCallback that is set using the `onStepFinish` option.\n\n@param stepResult - The result of the step.\n */\nexport type GenerateTextOnStepFinishCallback<TOOLS extends ToolSet> = (\n  stepResult: StepResult<TOOLS>,\n) => Promise<void> | void;\n\n/**\nGenerate a text and call tools for a given prompt using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamText` instead.\n\n@param model - The language model to use.\n\n@param tools - Tools that are accessible to and can be called by the model. The model needs to support calling tools.\n@param toolChoice - The tool choice strategy. Default: 'auto'.\n\n@param system - A system message that will be part of the prompt.\n@param prompt - A simple text prompt. You can either use `prompt` or `messages` but not both.\n@param messages - A list of messages. You can either use `prompt` or `messages` but not both.\n\n@param maxTokens - Maximum number of tokens to generate.\n@param temperature - Temperature setting.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topP - Nucleus sampling.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topK - Only sample from the top K options for each subsequent token.\nUsed to remove \"long tail\" low probability responses.\nRecommended for advanced use cases only. You usually only need to use temperature.\n@param presencePenalty - Presence penalty setting.\nIt affects the likelihood of the model to repeat information that is already in the prompt.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param frequencyPenalty - Frequency penalty setting.\nIt affects the likelihood of the model to repeatedly use the same words or phrases.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param stopSequences - Stop sequences.\nIf set, the model will stop generating text when one of the stop sequences is generated.\n@param seed - The seed (integer) to use for random sampling.\nIf set and supported by the model, calls will generate deterministic results.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@param maxSteps - Maximum number of sequential LLM calls (steps), e.g. when you use tool calls.\n@param experimental_generateMessageId - Generate a unique ID for each message.\n\n@param onStepFinish - Callback that is called when each step (LLM call) is finished, including intermediate steps.\n\n@returns\nA result object that contains the generated text, the results of the tool calls, and additional information.\n */\nexport async function generateText<\n  TOOLS extends ToolSet,\n  OUTPUT = never,\n  OUTPUT_PARTIAL = never,\n>({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  maxSteps = 1,\n  experimental_generateMessageId: generateMessageId = originalGenerateMessageId,\n  experimental_output: output,\n  experimental_continueSteps: continueSteps = false,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  experimental_activeTools: activeTools,\n  experimental_prepareStep: prepareStep,\n  experimental_repairToolCall: repairToolCall,\n  _internal: {\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n  } = {},\n  onStepFinish,\n  ...settings\n}: CallSettings &\n  Prompt & {\n    /**\nThe language model to use.\n     */\n    model: LanguageModel;\n\n    /**\nThe tools that the model can call. The model needs to support calling tools.\n*/\n    tools?: TOOLS;\n\n    /**\nThe tool choice strategy. Default: 'auto'.\n     */\n    toolChoice?: ToolChoice<TOOLS>;\n\n    /**\nMaximum number of sequential LLM calls (steps), e.g. when you use tool calls. Must be at least 1.\n\nA maximum number is required to prevent infinite loops in the case of misconfigured tools.\n\nBy default, it's set to 1, which means that only a single LLM call is made.\n     */\n    maxSteps?: number;\n\n    /**\nGenerate a unique ID for each message.\n     */\n    experimental_generateMessageId?: IDGenerator;\n\n    /**\nWhen enabled, the model will perform additional steps if the finish reason is \"length\" (experimental).\n\nBy default, it's set to false.\n     */\n    experimental_continueSteps?: boolean;\n\n    /**\nOptional telemetry configuration (experimental).\n     */\n    experimental_telemetry?: TelemetrySettings;\n\n    /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n    providerOptions?: ProviderOptions;\n\n    /**\n@deprecated Use `providerOptions` instead.\n     */\n    experimental_providerMetadata?: ProviderMetadata;\n\n    /**\nLimits the tools that are available for the model to call without\nchanging the tool call and result types in the result.\n     */\n    experimental_activeTools?: Array<keyof TOOLS>;\n\n    /**\nOptional specification for parsing structured outputs from the LLM response.\n     */\n    experimental_output?: Output<OUTPUT, OUTPUT_PARTIAL>;\n\n    /**\nOptional function that you can use to provide different settings for a step.\n\n@param options - The options for the step.\n@param options.steps - The steps that have been executed so far.\n@param options.stepNumber - The number of the step that is being executed.\n@param options.maxSteps - The maximum number of steps.\n@param options.model - The model that is being used.\n\n@returns An object that contains the settings for the step.\nIf you return undefined (or for undefined settings), the settings from the outer level will be used.\n    */\n    experimental_prepareStep?: (options: {\n      steps: Array<StepResult<TOOLS>>;\n      stepNumber: number;\n      maxSteps: number;\n      model: LanguageModel;\n    }) => PromiseLike<\n      | {\n          model?: LanguageModel;\n          toolChoice?: ToolChoice<TOOLS>;\n          experimental_activeTools?: Array<keyof TOOLS>;\n        }\n      | undefined\n    >;\n\n    /**\nA function that attempts to repair a tool call that failed to parse.\n     */\n    experimental_repairToolCall?: ToolCallRepairFunction<TOOLS>;\n\n    /**\n    Callback that is called when each step (LLM call) is finished, including intermediate steps.\n    */\n    onStepFinish?: GenerateTextOnStepFinishCallback<TOOLS>;\n\n    /**\n     * Internal. For test use only. May change without notice.\n     */\n    _internal?: {\n      generateId?: IDGenerator;\n      currentDate?: () => Date;\n    };\n  }): Promise<GenerateTextResult<TOOLS, OUTPUT>> {\n  if (maxSteps < 1) {\n    throw new InvalidArgumentError({\n      parameter: 'maxSteps',\n      value: maxSteps,\n      message: 'maxSteps must be at least 1',\n    });\n  }\n\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries },\n  });\n\n  const initialPrompt = standardizePrompt({\n    prompt: {\n      system: output?.injectIntoSystemPrompt({ system, model }) ?? system,\n      prompt,\n      messages,\n    },\n    tools,\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.generateText',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: 'ai.generateText',\n          telemetry,\n        }),\n        ...baseTelemetryAttributes,\n        // model:\n        'ai.model.provider': model.provider,\n        'ai.model.id': model.modelId,\n        // specific settings that only make sense on the outer level:\n        'ai.prompt': {\n          input: () => JSON.stringify({ system, prompt, messages }),\n        },\n        'ai.settings.maxSteps': maxSteps,\n      },\n    }),\n    tracer,\n    fn: async span => {\n      const callSettings = prepareCallSettings(settings);\n\n      let currentModelResponse: Awaited<\n        ReturnType<LanguageModel['doGenerate']>\n      > & { response: { id: string; timestamp: Date; modelId: string } };\n      let currentToolCalls: ToolCallArray<TOOLS> = [];\n      let currentToolResults: ToolResultArray<TOOLS> = [];\n      let currentReasoningDetails: Array<ReasoningDetail> = [];\n      let stepCount = 0;\n      const responseMessages: Array<ResponseMessage> = [];\n      let text = '';\n      const sources: GenerateTextResult<TOOLS, OUTPUT>['sources'] = [];\n      const steps: GenerateTextResult<TOOLS, OUTPUT>['steps'] = [];\n      let usage: LanguageModelUsage = {\n        completionTokens: 0,\n        promptTokens: 0,\n        totalTokens: 0,\n      };\n\n      let stepType: 'initial' | 'tool-result' | 'continue' | 'done' = 'initial';\n\n      do {\n        // after the 1st step, we need to switch to messages format:\n        const promptFormat = stepCount === 0 ? initialPrompt.type : 'messages';\n\n        const stepInputMessages = [\n          ...initialPrompt.messages,\n          ...responseMessages,\n        ];\n\n        const prepareStepResult = await prepareStep?.({\n          model,\n          steps,\n          maxSteps,\n          stepNumber: stepCount,\n        });\n\n        const stepToolChoice = prepareStepResult?.toolChoice ?? toolChoice;\n        const stepActiveTools =\n          prepareStepResult?.experimental_activeTools ?? activeTools;\n        const stepModel = prepareStepResult?.model ?? model;\n\n        const promptMessages = await convertToLanguageModelPrompt({\n          prompt: {\n            type: promptFormat,\n            system: initialPrompt.system,\n            messages: stepInputMessages,\n          },\n          modelSupportsImageUrls: stepModel.supportsImageUrls,\n          modelSupportsUrl: stepModel.supportsUrl?.bind(stepModel), // support 'this' context\n        });\n\n        const mode = {\n          type: 'regular' as const,\n          ...prepareToolsAndToolChoice({\n            tools,\n            toolChoice: stepToolChoice,\n            activeTools: stepActiveTools,\n          }),\n        };\n\n        currentModelResponse = await retry(() =>\n          recordSpan({\n            name: 'ai.generateText.doGenerate',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.generateText.doGenerate',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                // model:\n                'ai.model.provider': stepModel.provider,\n                'ai.model.id': stepModel.modelId,\n                // prompt:\n                'ai.prompt.format': { input: () => promptFormat },\n                'ai.prompt.messages': {\n                  input: () => stringifyForTelemetry(promptMessages),\n                },\n                'ai.prompt.tools': {\n                  // convert the language model level tools:\n                  input: () => mode.tools?.map(tool => JSON.stringify(tool)),\n                },\n                'ai.prompt.toolChoice': {\n                  input: () =>\n                    mode.toolChoice != null\n                      ? JSON.stringify(mode.toolChoice)\n                      : undefined,\n                },\n\n                // standardized gen-ai llm span attributes:\n                'gen_ai.system': stepModel.provider,\n                'gen_ai.request.model': stepModel.modelId,\n                'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                'gen_ai.request.max_tokens': settings.maxTokens,\n                'gen_ai.request.presence_penalty': settings.presencePenalty,\n                'gen_ai.request.stop_sequences': settings.stopSequences,\n                'gen_ai.request.temperature': settings.temperature,\n                'gen_ai.request.top_k': settings.topK,\n                'gen_ai.request.top_p': settings.topP,\n              },\n            }),\n            tracer,\n            fn: async span => {\n              const result = await stepModel.doGenerate({\n                mode,\n                ...callSettings,\n                inputFormat: promptFormat,\n                responseFormat: output?.responseFormat({ model }),\n                prompt: promptMessages,\n                providerMetadata: providerOptions,\n                abortSignal,\n                headers,\n              });\n\n              // Fill in default values:\n              const responseData = {\n                id: result.response?.id ?? generateId(),\n                timestamp: result.response?.timestamp ?? currentDate(),\n                modelId: result.response?.modelId ?? stepModel.modelId,\n              };\n\n              // Add response information to the span:\n              span.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.response.finishReason': result.finishReason,\n                    'ai.response.text': {\n                      output: () => result.text,\n                    },\n                    'ai.response.toolCalls': {\n                      output: () => JSON.stringify(result.toolCalls),\n                    },\n                    'ai.response.id': responseData.id,\n                    'ai.response.model': responseData.modelId,\n                    'ai.response.timestamp':\n                      responseData.timestamp.toISOString(),\n\n                    'ai.usage.promptTokens': result.usage.promptTokens,\n                    'ai.usage.completionTokens': result.usage.completionTokens,\n\n                    // standardized gen-ai llm span attributes:\n                    'gen_ai.response.finish_reasons': [result.finishReason],\n                    'gen_ai.response.id': responseData.id,\n                    'gen_ai.response.model': responseData.modelId,\n                    'gen_ai.usage.input_tokens': result.usage.promptTokens,\n                    'gen_ai.usage.output_tokens': result.usage.completionTokens,\n                  },\n                }),\n              );\n\n              return { ...result, response: responseData };\n            },\n          }),\n        );\n\n        // parse tool calls:\n        currentToolCalls = await Promise.all(\n          (currentModelResponse.toolCalls ?? []).map(toolCall =>\n            parseToolCall({\n              toolCall,\n              tools,\n              repairToolCall,\n              system,\n              messages: stepInputMessages,\n            }),\n          ),\n        );\n\n        // execute tools:\n        currentToolResults =\n          tools == null\n            ? []\n            : await executeTools({\n                toolCalls: currentToolCalls,\n                tools,\n                tracer,\n                telemetry,\n                messages: stepInputMessages,\n                abortSignal,\n              });\n\n        // token usage:\n        const currentUsage = calculateLanguageModelUsage(\n          currentModelResponse.usage,\n        );\n        usage = addLanguageModelUsage(usage, currentUsage);\n\n        // check if another step is needed:\n        let nextStepType: 'done' | 'continue' | 'tool-result' = 'done';\n        if (++stepCount < maxSteps) {\n          if (\n            continueSteps &&\n            currentModelResponse.finishReason === 'length' &&\n            // only use continue when there are no tool calls:\n            currentToolCalls.length === 0\n          ) {\n            nextStepType = 'continue';\n          } else if (\n            // there are tool calls:\n            currentToolCalls.length > 0 &&\n            // all current tool calls have results:\n            currentToolResults.length === currentToolCalls.length\n          ) {\n            nextStepType = 'tool-result';\n          }\n        }\n\n        // text:\n        const originalText = currentModelResponse.text ?? '';\n        const stepTextLeadingWhitespaceTrimmed =\n          stepType === 'continue' && // only for continue steps\n          text.trimEnd() !== text // only trim when there is preceding whitespace\n            ? originalText.trimStart()\n            : originalText;\n        const stepText =\n          nextStepType === 'continue'\n            ? removeTextAfterLastWhitespace(stepTextLeadingWhitespaceTrimmed)\n            : stepTextLeadingWhitespaceTrimmed;\n\n        text =\n          nextStepType === 'continue' || stepType === 'continue'\n            ? text + stepText\n            : stepText;\n\n        currentReasoningDetails = asReasoningDetails(\n          currentModelResponse.reasoning,\n        );\n\n        // sources:\n        sources.push(...(currentModelResponse.sources ?? []));\n\n        // append to messages for potential next step:\n        if (stepType === 'continue') {\n          // continue step: update the last assistant message\n          // continue is only possible when there are no tool calls,\n          // so we can assume that there is a single last assistant message:\n          const lastMessage = responseMessages[\n            responseMessages.length - 1\n          ] as CoreAssistantMessage;\n\n          if (typeof lastMessage.content === 'string') {\n            lastMessage.content += stepText;\n          } else {\n            lastMessage.content.push({\n              text: stepText,\n              type: 'text',\n            });\n          }\n        } else {\n          responseMessages.push(\n            ...toResponseMessages({\n              text,\n              files: asFiles(currentModelResponse.files),\n              reasoning: asReasoningDetails(currentModelResponse.reasoning),\n              tools: tools ?? ({} as TOOLS),\n              toolCalls: currentToolCalls,\n              toolResults: currentToolResults,\n              messageId: generateMessageId(),\n              generateMessageId,\n            }),\n          );\n        }\n\n        // Add step information (after response messages are updated):\n        const currentStepResult: StepResult<TOOLS> = {\n          stepType,\n          text: stepText,\n          // TODO v5: rename reasoning to reasoningText (and use reasoning for composite array)\n          reasoning: asReasoningText(currentReasoningDetails),\n          reasoningDetails: currentReasoningDetails,\n          files: asFiles(currentModelResponse.files),\n          sources: currentModelResponse.sources ?? [],\n          toolCalls: currentToolCalls,\n          toolResults: currentToolResults,\n          finishReason: currentModelResponse.finishReason,\n          usage: currentUsage,\n          warnings: currentModelResponse.warnings,\n          logprobs: currentModelResponse.logprobs,\n          request: currentModelResponse.request ?? {},\n          response: {\n            ...currentModelResponse.response,\n            headers: currentModelResponse.rawResponse?.headers,\n            body: currentModelResponse.rawResponse?.body,\n\n            // deep clone msgs to avoid mutating past messages in multi-step:\n            messages: structuredClone(responseMessages),\n          },\n          providerMetadata: currentModelResponse.providerMetadata,\n          experimental_providerMetadata: currentModelResponse.providerMetadata,\n          isContinued: nextStepType === 'continue',\n        };\n        steps.push(currentStepResult);\n        await onStepFinish?.(currentStepResult);\n\n        stepType = nextStepType;\n      } while (stepType !== 'done');\n\n      // Add response information to the span:\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.response.finishReason': currentModelResponse.finishReason,\n            'ai.response.text': {\n              output: () => currentModelResponse.text,\n            },\n            'ai.response.toolCalls': {\n              output: () => JSON.stringify(currentModelResponse.toolCalls),\n            },\n\n            'ai.usage.promptTokens': currentModelResponse.usage.promptTokens,\n            'ai.usage.completionTokens':\n              currentModelResponse.usage.completionTokens,\n          },\n        }),\n      );\n\n      return new DefaultGenerateTextResult({\n        text,\n        files: asFiles(currentModelResponse.files),\n        reasoning: asReasoningText(currentReasoningDetails),\n        reasoningDetails: currentReasoningDetails,\n        sources,\n        outputResolver: () => {\n          if (output == null) {\n            throw new NoOutputSpecifiedError();\n          }\n\n          return output.parseOutput(\n            { text },\n            {\n              response: currentModelResponse.response,\n              usage,\n              finishReason: currentModelResponse.finishReason,\n            },\n          );\n        },\n        toolCalls: currentToolCalls,\n        toolResults: currentToolResults,\n        finishReason: currentModelResponse.finishReason,\n        usage,\n        warnings: currentModelResponse.warnings,\n        request: currentModelResponse.request ?? {},\n        response: {\n          ...currentModelResponse.response,\n          headers: currentModelResponse.rawResponse?.headers,\n          body: currentModelResponse.rawResponse?.body,\n          messages: responseMessages,\n        },\n        logprobs: currentModelResponse.logprobs,\n        steps,\n        providerMetadata: currentModelResponse.providerMetadata,\n      });\n    },\n  });\n}\n\nasync function executeTools<TOOLS extends ToolSet>({\n  toolCalls,\n  tools,\n  tracer,\n  telemetry,\n  messages,\n  abortSignal,\n}: {\n  toolCalls: ToolCallArray<TOOLS>;\n  tools: TOOLS;\n  tracer: Tracer;\n  telemetry: TelemetrySettings | undefined;\n  messages: CoreMessage[];\n  abortSignal: AbortSignal | undefined;\n}): Promise<ToolResultArray<TOOLS>> {\n  const toolResults = await Promise.all(\n    toolCalls.map(async ({ toolCallId, toolName, args }) => {\n      const tool = tools[toolName];\n\n      if (tool?.execute == null) {\n        return undefined;\n      }\n\n      const result = await recordSpan({\n        name: 'ai.toolCall',\n        attributes: selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            ...assembleOperationName({\n              operationId: 'ai.toolCall',\n              telemetry,\n            }),\n            'ai.toolCall.name': toolName,\n            'ai.toolCall.id': toolCallId,\n            'ai.toolCall.args': {\n              output: () => JSON.stringify(args),\n            },\n          },\n        }),\n        tracer,\n        fn: async span => {\n          try {\n            const result = await tool.execute!(args, {\n              toolCallId,\n              messages,\n              abortSignal,\n            });\n\n            try {\n              span.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.toolCall.result': {\n                      output: () => JSON.stringify(result),\n                    },\n                  },\n                }),\n              );\n            } catch (ignored) {\n              // JSON stringify might fail if the result is not serializable,\n              // in which case we just ignore it. In the future we might want to\n              // add an optional serialize method to the tool interface and warn\n              // if the result is not serializable.\n            }\n\n            return result;\n          } catch (error) {\n            throw new ToolExecutionError({\n              toolCallId,\n              toolName,\n              toolArgs: args,\n              cause: error,\n            });\n          }\n        },\n      });\n\n      return {\n        type: 'tool-result',\n        toolCallId,\n        toolName,\n        args,\n        result,\n      } as ToolResultArray<TOOLS>[number];\n    }),\n  );\n\n  return toolResults.filter(\n    (result): result is NonNullable<typeof result> => result != null,\n  );\n}\n\nclass DefaultGenerateTextResult<TOOLS extends ToolSet, OUTPUT>\n  implements GenerateTextResult<TOOLS, OUTPUT>\n{\n  readonly text: GenerateTextResult<TOOLS, OUTPUT>['text'];\n  readonly files: GenerateTextResult<TOOLS, OUTPUT>['files'];\n  readonly reasoning: GenerateTextResult<TOOLS, OUTPUT>['reasoning'];\n  readonly reasoningDetails: GenerateTextResult<\n    TOOLS,\n    OUTPUT\n  >['reasoningDetails'];\n  readonly toolCalls: GenerateTextResult<TOOLS, OUTPUT>['toolCalls'];\n  readonly toolResults: GenerateTextResult<TOOLS, OUTPUT>['toolResults'];\n  readonly finishReason: GenerateTextResult<TOOLS, OUTPUT>['finishReason'];\n  readonly usage: GenerateTextResult<TOOLS, OUTPUT>['usage'];\n  readonly warnings: GenerateTextResult<TOOLS, OUTPUT>['warnings'];\n  readonly steps: GenerateTextResult<TOOLS, OUTPUT>['steps'];\n  readonly logprobs: GenerateTextResult<TOOLS, OUTPUT>['logprobs'];\n  readonly experimental_providerMetadata: GenerateTextResult<\n    TOOLS,\n    OUTPUT\n  >['experimental_providerMetadata'];\n  readonly providerMetadata: GenerateTextResult<\n    TOOLS,\n    OUTPUT\n  >['providerMetadata'];\n  readonly response: GenerateTextResult<TOOLS, OUTPUT>['response'];\n  readonly request: GenerateTextResult<TOOLS, OUTPUT>['request'];\n  readonly sources: GenerateTextResult<TOOLS, OUTPUT>['sources'];\n\n  private readonly outputResolver: () => GenerateTextResult<\n    TOOLS,\n    OUTPUT\n  >['experimental_output'];\n\n  constructor(options: {\n    text: GenerateTextResult<TOOLS, OUTPUT>['text'];\n    files: GenerateTextResult<TOOLS, OUTPUT>['files'];\n    reasoning: GenerateTextResult<TOOLS, OUTPUT>['reasoning'];\n    reasoningDetails: GenerateTextResult<TOOLS, OUTPUT>['reasoningDetails'];\n    toolCalls: GenerateTextResult<TOOLS, OUTPUT>['toolCalls'];\n    toolResults: GenerateTextResult<TOOLS, OUTPUT>['toolResults'];\n    finishReason: GenerateTextResult<TOOLS, OUTPUT>['finishReason'];\n    usage: GenerateTextResult<TOOLS, OUTPUT>['usage'];\n    warnings: GenerateTextResult<TOOLS, OUTPUT>['warnings'];\n    logprobs: GenerateTextResult<TOOLS, OUTPUT>['logprobs'];\n    steps: GenerateTextResult<TOOLS, OUTPUT>['steps'];\n    providerMetadata: GenerateTextResult<TOOLS, OUTPUT>['providerMetadata'];\n    response: GenerateTextResult<TOOLS, OUTPUT>['response'];\n    request: GenerateTextResult<TOOLS, OUTPUT>['request'];\n    outputResolver: () => GenerateTextResult<\n      TOOLS,\n      OUTPUT\n    >['experimental_output'];\n    sources: GenerateTextResult<TOOLS, OUTPUT>['sources'];\n  }) {\n    this.text = options.text;\n    this.files = options.files;\n    this.reasoning = options.reasoning;\n    this.reasoningDetails = options.reasoningDetails;\n    this.toolCalls = options.toolCalls;\n    this.toolResults = options.toolResults;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.request = options.request;\n    this.response = options.response;\n    this.steps = options.steps;\n    this.experimental_providerMetadata = options.providerMetadata;\n    this.providerMetadata = options.providerMetadata;\n    this.logprobs = options.logprobs;\n    this.outputResolver = options.outputResolver;\n    this.sources = options.sources;\n  }\n\n  get experimental_output() {\n    return this.outputResolver();\n  }\n}\n\nfunction asReasoningDetails(\n  reasoning:\n    | string\n    | Array<\n        | { type: 'text'; text: string; signature?: string }\n        | { type: 'redacted'; data: string }\n      >\n    | undefined,\n): Array<\n  | { type: 'text'; text: string; signature?: string }\n  | { type: 'redacted'; data: string }\n> {\n  if (reasoning == null) {\n    return [];\n  }\n\n  if (typeof reasoning === 'string') {\n    return [{ type: 'text', text: reasoning }];\n  }\n\n  return reasoning;\n}\n\nfunction asFiles(\n  files:\n    | Array<{\n        data: string | Uint8Array;\n        mimeType: string;\n      }>\n    | undefined,\n): Array<GeneratedFile> {\n  return files?.map(file => new DefaultGeneratedFile(file)) ?? [];\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_NoOutputSpecifiedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when no output type is specified and output-related methods are called.\n */\nexport class NoOutputSpecifiedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message = 'No output specified.' }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is NoOutputSpecifiedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError, getErrorMessage, JSONValue } from '@ai-sdk/provider';\n\nconst name = 'AI_ToolExecutionError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class ToolExecutionError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly toolName: string;\n  readonly toolArgs: JSONValue;\n  readonly toolCallId: string;\n\n  constructor({\n    toolArgs,\n    toolName,\n    toolCallId,\n    cause,\n    message = `Error executing tool ${toolName}: ${getErrorMessage(cause)}`,\n  }: {\n    message?: string;\n    toolArgs: JSONValue;\n    toolName: string;\n    toolCallId: string;\n    cause: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.toolArgs = toolArgs;\n    this.toolName = toolName;\n    this.toolCallId = toolCallId;\n  }\n\n  static isInstance(error: unknown): error is ToolExecutionError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import {\n  LanguageModelV1FunctionTool,\n  LanguageModelV1ProviderDefinedTool,\n  LanguageModelV1ToolChoice,\n} from '@ai-sdk/provider';\nimport { asSchema } from '@ai-sdk/ui-utils';\nimport { ToolSet } from '../generate-text';\nimport { ToolChoice } from '../types/language-model';\nimport { isNonEmptyObject } from '../util/is-non-empty-object';\n\nexport function prepareToolsAndToolChoice<TOOLS extends ToolSet>({\n  tools,\n  toolChoice,\n  activeTools,\n}: {\n  tools: TOOLS | undefined;\n  toolChoice: ToolChoice<TOOLS> | undefined;\n  activeTools: Array<keyof TOOLS> | undefined;\n}): {\n  tools:\n    | Array<LanguageModelV1FunctionTool | LanguageModelV1ProviderDefinedTool>\n    | undefined;\n  toolChoice: LanguageModelV1ToolChoice | undefined;\n} {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: undefined,\n      toolChoice: undefined,\n    };\n  }\n\n  // when activeTools is provided, we only include the tools that are in the list:\n  const filteredTools =\n    activeTools != null\n      ? Object.entries(tools).filter(([name]) =>\n          activeTools.includes(name as keyof TOOLS),\n        )\n      : Object.entries(tools);\n\n  return {\n    tools: filteredTools.map(([name, tool]) => {\n      const toolType = tool.type;\n      switch (toolType) {\n        case undefined:\n        case 'function':\n          return {\n            type: 'function' as const,\n            name,\n            description: tool.description,\n            parameters: asSchema(tool.parameters).jsonSchema,\n          };\n        case 'provider-defined':\n          return {\n            type: 'provider-defined' as const,\n            name,\n            id: tool.id,\n            args: tool.args,\n          };\n        default: {\n          const exhaustiveCheck: never = toolType;\n          throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n        }\n      }\n    }),\n    toolChoice:\n      toolChoice == null\n        ? { type: 'auto' }\n        : typeof toolChoice === 'string'\n          ? { type: toolChoice }\n          : { type: 'tool' as const, toolName: toolChoice.toolName as string },\n  };\n}\n", "export function isNonEmptyObject(\n  object: Record<string, unknown> | undefined | null,\n): object is Record<string, unknown> {\n  return object != null && Object.keys(object).length > 0;\n}\n", "const lastWhitespaceRegexp = /^([\\s\\S]*?)(\\s+)(\\S*)$/;\n\n/**\n * Splits the text on the last whitespace.\n *\n * Whitespace is defined as one or more whitespace characters,\n * e.g. space, tab, newline, etc.\n *\n * @param text - The text to split.\n * @returns The prefix, whitespace, and suffix. Undefined if there is no whitespace.\n */\nexport function splitOnLastWhitespace(text: string):\n  | {\n      prefix: string;\n      whitespace: string;\n      suffix: string;\n    }\n  | undefined {\n  const match = text.match(lastWhitespaceRegexp);\n  return match\n    ? { prefix: match[1], whitespace: match[2], suffix: match[3] }\n    : undefined;\n}\n", "import { splitOnLastWhitespace } from './split-on-last-whitespace';\n\nexport function removeTextAfterLastWhitespace(text: string): string {\n  const match = splitOnLastWhitespace(text);\n  return match ? match.prefix + match.whitespace : text;\n}\n", "import { LanguageModelV1FunctionToolCall } from '@ai-sdk/provider';\nimport { safeParseJSON, safeValidateTypes } from '@ai-sdk/provider-utils';\nimport { Schema, asSchema } from '@ai-sdk/ui-utils';\nimport { InvalidToolArgumentsError } from '../../errors/invalid-tool-arguments-error';\nimport { NoSuchToolError } from '../../errors/no-such-tool-error';\nimport { ToolCallRepairError } from '../../errors/tool-call-repair-error';\nimport { CoreMessage } from '../prompt';\nimport { inferParameters } from '../tool/tool';\nimport { ToolCallUnion } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair';\nimport { ToolSet } from './tool-set';\n\nexport async function parseToolCall<TOOLS extends ToolSet>({\n  toolCall,\n  tools,\n  repairToolCall,\n  system,\n  messages,\n}: {\n  toolCall: LanguageModelV1FunctionToolCall;\n  tools: TOOLS | undefined;\n  repairToolCall: ToolCallRepairFunction<TOOLS> | undefined;\n  system: string | undefined;\n  messages: CoreMessage[];\n}): Promise<ToolCallUnion<TOOLS>> {\n  if (tools == null) {\n    throw new NoSuchToolError({ toolName: toolCall.toolName });\n  }\n\n  try {\n    return await doParseToolCall({ toolCall, tools });\n  } catch (error) {\n    if (\n      repairToolCall == null ||\n      !(\n        NoSuchToolError.isInstance(error) ||\n        InvalidToolArgumentsError.isInstance(error)\n      )\n    ) {\n      throw error;\n    }\n\n    let repairedToolCall: LanguageModelV1FunctionToolCall | null = null;\n\n    try {\n      repairedToolCall = await repairToolCall({\n        toolCall,\n        tools,\n        parameterSchema: ({ toolName }) =>\n          asSchema(tools[toolName].parameters).jsonSchema,\n        system,\n        messages,\n        error,\n      });\n    } catch (repairError) {\n      throw new ToolCallRepairError({\n        cause: repairError,\n        originalError: error,\n      });\n    }\n\n    // no repaired tool call returned\n    if (repairedToolCall == null) {\n      throw error;\n    }\n\n    return await doParseToolCall({ toolCall: repairedToolCall, tools });\n  }\n}\n\nasync function doParseToolCall<TOOLS extends ToolSet>({\n  toolCall,\n  tools,\n}: {\n  toolCall: LanguageModelV1FunctionToolCall;\n  tools: TOOLS;\n}): Promise<ToolCallUnion<TOOLS>> {\n  const toolName = toolCall.toolName as keyof TOOLS & string;\n\n  const tool = tools[toolName];\n\n  if (tool == null) {\n    throw new NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools),\n    });\n  }\n\n  const schema = asSchema(tool.parameters) as Schema<\n    inferParameters<TOOLS[keyof TOOLS]['parameters']>\n  >;\n\n  // when the tool call has no arguments, we try passing an empty object to the schema\n  // (many LLMs generate empty strings for tool calls with no arguments)\n  const parseResult =\n    toolCall.args.trim() === ''\n      ? safeValidateTypes({ value: {}, schema })\n      : safeParseJSON({ text: toolCall.args, schema });\n\n  if (parseResult.success === false) {\n    throw new InvalidToolArgumentsError({\n      toolName,\n      toolArgs: toolCall.args,\n      cause: parseResult.error,\n    });\n  }\n\n  return {\n    type: 'tool-call',\n    toolCallId: toolCall.toolCallId,\n    toolName,\n    args: parseResult.value,\n  };\n}\n", "import { AISDKError, getErrorMessage } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidToolArgumentsError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidToolArgumentsError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly toolName: string;\n  readonly toolArgs: string;\n\n  constructor({\n    toolArgs,\n    toolName,\n    cause,\n    message = `Invalid arguments for tool ${toolName}: ${getErrorMessage(\n      cause,\n    )}`,\n  }: {\n    message?: string;\n    toolArgs: string;\n    toolName: string;\n    cause: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.toolArgs = toolArgs;\n    this.toolName = toolName;\n  }\n\n  static isInstance(error: unknown): error is InvalidToolArgumentsError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_NoSuchToolError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchToolError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly toolName: string;\n  readonly availableTools: string[] | undefined;\n\n  constructor({\n    toolName,\n    availableTools = undefined,\n    message = `Model tried to call unavailable tool '${toolName}'. ${\n      availableTools === undefined\n        ? 'No tools are available.'\n        : `Available tools: ${availableTools.join(', ')}.`\n    }`,\n  }: {\n    toolName: string;\n    availableTools?: string[] | undefined;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.toolName = toolName;\n    this.availableTools = availableTools;\n  }\n\n  static isInstance(error: unknown): error is NoSuchToolError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError, getErrorMessage } from '@ai-sdk/provider';\nimport { InvalidToolArgumentsError } from './invalid-tool-arguments-error';\nimport { NoSuchToolError } from './no-such-tool-error';\n\nconst name = 'AI_ToolCallRepairError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class ToolCallRepairError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly originalError: NoSuchToolError | InvalidToolArgumentsError;\n\n  constructor({\n    cause,\n    originalError,\n    message = `Error repairing tool call: ${getErrorMessage(cause)}`,\n  }: {\n    message?: string;\n    cause: unknown;\n    originalError: NoSuchToolError | InvalidToolArgumentsError;\n  }) {\n    super({ name, message, cause });\n    this.originalError = originalError;\n  }\n\n  static isInstance(error: unknown): error is ToolCallRepairError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "export type ReasoningDetail =\n  | { type: 'text'; text: string; signature?: string }\n  | { type: 'redacted'; data: string };\n\nexport function asReasoningText(\n  reasoning: Array<ReasoningDetail>,\n): string | undefined {\n  const reasoningText = reasoning\n    .filter(part => part.type === 'text')\n    .map(part => part.text)\n    .join('');\n\n  return reasoningText.length > 0 ? reasoningText : undefined;\n}\n", "import { ToolResultPart } from '../prompt';\nimport { GeneratedFile } from './generated-file';\nimport { ReasoningDetail } from './reasoning-detail';\nimport { ResponseMessage } from './step-result';\nimport { ToolCallArray } from './tool-call';\nimport { ToolResultArray } from './tool-result';\nimport { ToolSet } from './tool-set';\n\n/**\nConverts the result of a `generateText` or `streamText` call to a list of response messages.\n */\nexport function toResponseMessages<TOOLS extends ToolSet>({\n  text = '',\n  files,\n  reasoning,\n  tools,\n  toolCalls,\n  toolResults,\n  messageId,\n  generateMessageId,\n}: {\n  text: string | undefined;\n  files: Array<GeneratedFile>;\n  reasoning: Array<ReasoningDetail>;\n  tools: TOOLS;\n  toolCalls: ToolCallArray<TOOLS>;\n  toolResults: ToolResultArray<TOOLS>;\n  messageId: string;\n  generateMessageId: () => string;\n}): Array<ResponseMessage> {\n  const responseMessages: Array<ResponseMessage> = [];\n\n  const content = [];\n\n  // TODO language model v2: switch to order response content (instead of type-based ordering)\n\n  if (reasoning.length > 0) {\n    content.push(\n      ...reasoning.map(part =>\n        part.type === 'text'\n          ? { ...part, type: 'reasoning' as const }\n          : { ...part, type: 'redacted-reasoning' as const },\n      ),\n    );\n  }\n\n  if (files.length > 0) {\n    content.push(\n      ...files.map(file => ({\n        type: 'file' as const,\n        data: file.base64,\n        mimeType: file.mimeType,\n      })),\n    );\n  }\n\n  if (text.length > 0) {\n    content.push({ type: 'text' as const, text });\n  }\n\n  if (toolCalls.length > 0) {\n    content.push(...toolCalls);\n  }\n\n  if (content.length > 0) {\n    responseMessages.push({\n      role: 'assistant',\n      content,\n      id: messageId,\n    });\n  }\n\n  if (toolResults.length > 0) {\n    responseMessages.push({\n      role: 'tool',\n      id: generateMessageId(),\n      content: toolResults.map((toolResult): ToolResultPart => {\n        const tool = tools[toolResult.toolName];\n        return tool?.experimental_toToolResultContent != null\n          ? {\n              type: 'tool-result',\n              toolCallId: toolResult.toolCallId,\n              toolName: toolResult.toolName,\n              result: tool.experimental_toToolResultContent(toolResult.result),\n              experimental_content: tool.experimental_toToolResultContent(\n                toolResult.result,\n              ),\n            }\n          : {\n              type: 'tool-result',\n              toolCallId: toolResult.toolCallId,\n              toolName: toolResult.toolName,\n              result: toolResult.result,\n            };\n      }),\n    });\n  }\n\n  return responseMessages;\n}\n", "import { safeParseJSON, safeValidateTypes } from '@ai-sdk/provider-utils';\nimport {\n  asSchema,\n  DeepPartial,\n  parsePartialJson,\n  Schema,\n} from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { NoObjectGeneratedError } from '../../errors';\nimport { injectJsonInstruction } from '../generate-object/inject-json-instruction';\nimport {\n  FinishReason,\n  LanguageModel,\n  LanguageModelV1CallOptions,\n} from '../types/language-model';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { LanguageModelUsage } from '../types/usage';\n\nexport interface Output<OUTPUT, PARTIAL> {\n  readonly type: 'object' | 'text';\n  injectIntoSystemPrompt(options: {\n    system: string | undefined;\n    model: LanguageModel;\n  }): string | undefined;\n\n  responseFormat: (options: {\n    model: LanguageModel;\n  }) => LanguageModelV1CallOptions['responseFormat'];\n\n  parsePartial(options: { text: string }): { partial: PARTIAL } | undefined;\n\n  parseOutput(\n    options: { text: string },\n    context: {\n      response: LanguageModelResponseMetadata;\n      usage: LanguageModelUsage;\n      finishReason: FinishReason;\n    },\n  ): OUTPUT;\n}\n\nexport const text = (): Output<string, string> => ({\n  type: 'text',\n\n  responseFormat: () => ({ type: 'text' }),\n\n  injectIntoSystemPrompt({ system }: { system: string | undefined }) {\n    return system;\n  },\n\n  parsePartial({ text }: { text: string }) {\n    return { partial: text };\n  },\n\n  parseOutput({ text }: { text: string }) {\n    return text;\n  },\n});\n\nexport const object = <OUTPUT>({\n  schema: inputSchema,\n}: {\n  schema: z.Schema<OUTPUT, z.ZodTypeDef, any> | Schema<OUTPUT>;\n}): Output<OUTPUT, DeepPartial<OUTPUT>> => {\n  const schema = asSchema(inputSchema);\n\n  return {\n    type: 'object',\n\n    responseFormat: ({ model }) => ({\n      type: 'json',\n      schema: model.supportsStructuredOutputs ? schema.jsonSchema : undefined,\n    }),\n\n    injectIntoSystemPrompt({ system, model }) {\n      // when the model supports structured outputs,\n      // we can use the system prompt as is:\n      return model.supportsStructuredOutputs\n        ? system\n        : injectJsonInstruction({\n            prompt: system,\n            schema: schema.jsonSchema,\n          });\n    },\n\n    parsePartial({ text }: { text: string }) {\n      const result = parsePartialJson(text);\n\n      switch (result.state) {\n        case 'failed-parse':\n        case 'undefined-input':\n          return undefined;\n\n        case 'repaired-parse':\n        case 'successful-parse':\n          return {\n            // Note: currently no validation of partial results:\n            partial: result.value as DeepPartial<OUTPUT>,\n          };\n\n        default: {\n          const _exhaustiveCheck: never = result.state;\n          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n\n    parseOutput(\n      { text }: { text: string },\n      context: {\n        response: LanguageModelResponseMetadata;\n        usage: LanguageModelUsage;\n        finishReason: FinishReason;\n      },\n    ) {\n      const parseResult = safeParseJSON({ text });\n\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: 'No object generated: could not parse the response.',\n          cause: parseResult.error,\n          text,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason,\n        });\n      }\n\n      const validationResult = safeValidateTypes({\n        value: parseResult.value,\n        schema,\n      });\n\n      if (!validationResult.success) {\n        throw new NoObjectGeneratedError({\n          message: 'No object generated: response did not match schema.',\n          cause: validationResult.error,\n          text,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason,\n        });\n      }\n\n      return validationResult.value;\n    },\n  };\n};\n", "export {\n  AISDKError,\n  APICallError,\n  EmptyResponseBodyError,\n  InvalidPromptError,\n  InvalidResponseDataError,\n  JSONParseError,\n  LoadAPIKeyError,\n  NoContentGeneratedError,\n  NoSuchModelError,\n  TypeValidationError,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\n\nexport { InvalidArgumentError } from './invalid-argument-error';\nexport { InvalidStreamPartError } from './invalid-stream-part-error';\nexport { InvalidToolArgumentsError } from './invalid-tool-arguments-error';\nexport { NoImageGeneratedError } from './no-image-generated-error';\nexport { NoObjectGeneratedError } from './no-object-generated-error';\nexport { NoOutputSpecifiedError } from './no-output-specified-error';\nexport { NoSuchToolError } from './no-such-tool-error';\nexport { ToolCallRepairError } from './tool-call-repair-error';\nexport { ToolExecutionError } from './tool-execution-error';\nexport { MCPClientError } from './mcp-client-error';\n\nexport { InvalidDataContentError } from '../core/prompt/invalid-data-content-error';\nexport { InvalidMessageRoleError } from '../core/prompt/invalid-message-role-error';\nexport { MessageConversionError } from '../core/prompt/message-conversion-error';\nexport { DownloadError } from '../util/download-error';\nexport { RetryError } from '../util/retry-error';\n", "import { AISDKError } from '@ai-sdk/provider';\nimport { SingleRequestTextStreamPart } from '../core/generate-text/run-tools-transformation';\n\nconst name = 'AI_InvalidStreamPartError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidStreamPartError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly chunk: SingleRequestTextStreamPart<any>;\n\n  constructor({\n    chunk,\n    message,\n  }: {\n    chunk: SingleRequestTextStreamPart<any>;\n    message: string;\n  }) {\n    super({ name, message });\n\n    this.chunk = chunk;\n  }\n\n  static isInstance(error: unknown): error is InvalidStreamPartError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_MCPClientError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * An error occurred with the MCP client.\n */\nexport class MCPClientError extends AISDKError {\n  private readonly [symbol] = true;\n\n  constructor({\n    name = 'MCPClientError',\n    message,\n    cause,\n  }: {\n    name?: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n  }\n\n  static isInstance(error: unknown): error is MCPClientError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { delay as originalDelay } from '@ai-sdk/provider-utils';\nimport { TextStreamPart } from './stream-text-result';\nimport { ToolSet } from './tool-set';\nimport { InvalidArgumentError } from '@ai-sdk/provider';\n\nconst CHUNKING_REGEXPS = {\n  word: /\\S+\\s+/m,\n  line: /\\n+/m,\n};\n\n/**\n * Detects the first chunk in a buffer.\n *\n * @param buffer - The buffer to detect the first chunk in.\n *\n * @returns The first detected chunk, or `undefined` if no chunk was detected.\n */\nexport type ChunkDetector = (buffer: string) => string | undefined | null;\n\n/**\n * Smooths text streaming output.\n *\n * @param delayInMs - The delay in milliseconds between each chunk. Defaults to 10ms. Can be set to `null` to skip the delay.\n * @param chunking - Controls how the text is chunked for streaming. Use \"word\" to stream word by word (default), \"line\" to stream line by line, or provide a custom RegExp pattern for custom chunking.\n *\n * @returns A transform stream that smooths text streaming output.\n */\nexport function smoothStream<TOOLS extends ToolSet>({\n  delayInMs = 10,\n  chunking = 'word',\n  _internal: { delay = originalDelay } = {},\n}: {\n  delayInMs?: number | null;\n  chunking?: 'word' | 'line' | RegExp | ChunkDetector;\n  /**\n   * Internal. For test use only. May change without notice.\n   */\n  _internal?: {\n    delay?: (delayInMs: number | null) => Promise<void>;\n  };\n} = {}): (options: {\n  tools: TOOLS;\n}) => TransformStream<TextStreamPart<TOOLS>, TextStreamPart<TOOLS>> {\n  let detectChunk: ChunkDetector;\n\n  if (typeof chunking === 'function') {\n    detectChunk = buffer => {\n      const match = chunking(buffer);\n\n      if (match == null) {\n        return null;\n      }\n\n      if (!match.length) {\n        throw new Error(`Chunking function must return a non-empty string.`);\n      }\n\n      if (!buffer.startsWith(match)) {\n        throw new Error(\n          `Chunking function must return a match that is a prefix of the buffer. Received: \"${match}\" expected to start with \"${buffer}\"`,\n        );\n      }\n\n      return match;\n    };\n  } else {\n    const chunkingRegex =\n      typeof chunking === 'string' ? CHUNKING_REGEXPS[chunking] : chunking;\n\n    if (chunkingRegex == null) {\n      throw new InvalidArgumentError({\n        argument: 'chunking',\n        message: `Chunking must be \"word\" or \"line\" or a RegExp. Received: ${chunking}`,\n      });\n    }\n\n    detectChunk = buffer => {\n      const match = chunkingRegex.exec(buffer);\n\n      if (!match) {\n        return null;\n      }\n\n      return buffer.slice(0, match.index) + match?.[0];\n    };\n  }\n\n  return () => {\n    let buffer = '';\n\n    return new TransformStream<TextStreamPart<TOOLS>, TextStreamPart<TOOLS>>({\n      async transform(chunk, controller) {\n        if (chunk.type !== 'text-delta') {\n          if (buffer.length > 0) {\n            controller.enqueue({ type: 'text-delta', textDelta: buffer });\n            buffer = '';\n          }\n\n          controller.enqueue(chunk);\n          return;\n        }\n\n        buffer += chunk.textDelta;\n\n        let match;\n\n        while ((match = detectChunk(buffer)) != null) {\n          controller.enqueue({ type: 'text-delta', textDelta: match });\n          buffer = buffer.slice(match.length);\n\n          await delay(delayInMs);\n        }\n      },\n    });\n  };\n}\n", "import { AISDKError, LanguageModelV1Source } from '@ai-sdk/provider';\nimport { createIdGenerator, IDGenerator } from '@ai-sdk/provider-utils';\nimport { DataStreamString, formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { Span } from '@opentelemetry/api';\nimport { ServerResponse } from 'node:http';\nimport { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport { InvalidStreamPartError } from '../../errors/invalid-stream-part-error';\nimport { NoOutputSpecifiedError } from '../../errors/no-output-specified-error';\nimport { StreamData } from '../../streams/stream-data';\nimport { asArray } from '../../util/as-array';\nimport { consumeStream } from '../../util/consume-stream';\nimport { DelayedPromise } from '../../util/delayed-promise';\nimport { DataStreamWriter } from '../data-stream/data-stream-writer';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { CoreAssistantMessage } from '../prompt/message';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { prepareToolsAndToolChoice } from '../prompt/prepare-tools-and-tool-choice';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  FinishReason,\n  LanguageModel,\n  LogProbs,\n  ToolChoice,\n} from '../types/language-model';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { ProviderMetadata, ProviderOptions } from '../types/provider-metadata';\nimport { addLanguageModelUsage, LanguageModelUsage } from '../types/usage';\nimport {\n  AsyncIterableStream,\n  createAsyncIterableStream,\n} from '../util/async-iterable-stream';\nimport { createStitchableStream } from '../util/create-stitchable-stream';\nimport { mergeStreams } from '../util/merge-streams';\nimport { now as originalNow } from '../util/now';\nimport { prepareOutgoingHttpHeaders } from '../util/prepare-outgoing-http-headers';\nimport { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { splitOnLastWhitespace } from '../util/split-on-last-whitespace';\nimport { writeToServerResponse } from '../util/write-to-server-response';\nimport { GeneratedFile } from './generated-file';\nimport { Output } from './output';\nimport { asReasoningText, ReasoningDetail } from './reasoning-detail';\nimport {\n  runToolsTransformation,\n  SingleRequestTextStreamPart,\n} from './run-tools-transformation';\nimport { ResponseMessage, StepResult } from './step-result';\nimport {\n  ConsumeStreamOptions,\n  DataStreamOptions,\n  StreamTextResult,\n  TextStreamPart,\n} from './stream-text-result';\nimport { toResponseMessages } from './to-response-messages';\nimport { ToolCallUnion } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair';\nimport { ToolResultUnion } from './tool-result';\nimport { ToolSet } from './tool-set';\nimport { stringifyForTelemetry } from '../prompt/stringify-for-telemetry';\n\nconst originalGenerateId = createIdGenerator({\n  prefix: 'aitxt',\n  size: 24,\n});\n\nconst originalGenerateMessageId = createIdGenerator({\n  prefix: 'msg',\n  size: 24,\n});\n\n/**\nA transformation that is applied to the stream.\n\n@param stopStream - A function that stops the source stream.\n@param tools - The tools that are accessible to and can be called by the model. The model needs to support calling tools.\n */\nexport type StreamTextTransform<TOOLS extends ToolSet> = (options: {\n  tools: TOOLS; // for type inference\n  stopStream: () => void;\n}) => TransformStream<TextStreamPart<TOOLS>, TextStreamPart<TOOLS>>;\n\n/**\nCallback that is set using the `onError` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamTextOnErrorCallback = (event: {\n  error: unknown;\n}) => Promise<void> | void;\n\n/**\nCallback that is set using the `onStepFinish` option.\n\n@param stepResult - The result of the step.\n */\nexport type StreamTextOnStepFinishCallback<TOOLS extends ToolSet> = (\n  stepResult: StepResult<TOOLS>,\n) => Promise<void> | void;\n\n/**\nCallback that is set using the `onChunk` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamTextOnChunkCallback<TOOLS extends ToolSet> = (event: {\n  chunk: Extract<\n    TextStreamPart<TOOLS>,\n    {\n      type:\n        | 'text-delta'\n        | 'reasoning'\n        | 'source'\n        | 'tool-call'\n        | 'tool-call-streaming-start'\n        | 'tool-call-delta'\n        | 'tool-result';\n    }\n  >;\n}) => Promise<void> | void;\n\n/**\nCallback that is set using the `onFinish` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamTextOnFinishCallback<TOOLS extends ToolSet> = (\n  event: Omit<StepResult<TOOLS>, 'stepType' | 'isContinued'> & {\n    /**\nDetails for all steps.\n   */\n    readonly steps: StepResult<TOOLS>[];\n  },\n) => Promise<void> | void;\n\n/**\nGenerate a text and call tools for a given prompt using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateText` instead.\n\n@param model - The language model to use.\n@param tools - Tools that are accessible to and can be called by the model. The model needs to support calling tools.\n\n@param system - A system message that will be part of the prompt.\n@param prompt - A simple text prompt. You can either use `prompt` or `messages` but not both.\n@param messages - A list of messages. You can either use `prompt` or `messages` but not both.\n\n@param maxTokens - Maximum number of tokens to generate.\n@param temperature - Temperature setting.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topP - Nucleus sampling.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topK - Only sample from the top K options for each subsequent token.\nUsed to remove \"long tail\" low probability responses.\nRecommended for advanced use cases only. You usually only need to use temperature.\n@param presencePenalty - Presence penalty setting.\nIt affects the likelihood of the model to repeat information that is already in the prompt.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param frequencyPenalty - Frequency penalty setting.\nIt affects the likelihood of the model to repeatedly use the same words or phrases.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param stopSequences - Stop sequences.\nIf set, the model will stop generating text when one of the stop sequences is generated.\n@param seed - The seed (integer) to use for random sampling.\nIf set and supported by the model, calls will generate deterministic results.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@param maxSteps - Maximum number of sequential LLM calls (steps), e.g. when you use tool calls.\n@param experimental_generateMessageId - Generate a unique ID for each message.\n\n@param onChunk - Callback that is called for each chunk of the stream. The stream processing will pause until the callback promise is resolved.\n@param onError - Callback that is called when an error occurs during streaming. You can use it to log errors.\n@param onStepFinish - Callback that is called when each step (LLM call) is finished, including intermediate steps.\n@param onFinish - Callback that is called when the LLM response and all request tool executions\n(for tools that have an `execute` function) are finished.\n\n@return\nA result object for accessing different stream types and additional information.\n */\nexport function streamText<\n  TOOLS extends ToolSet,\n  OUTPUT = never,\n  PARTIAL_OUTPUT = never,\n>({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  maxSteps = 1,\n  experimental_generateMessageId: generateMessageId = originalGenerateMessageId,\n  experimental_output: output,\n  experimental_continueSteps: continueSteps = false,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  experimental_toolCallStreaming = false,\n  toolCallStreaming = experimental_toolCallStreaming,\n  experimental_activeTools: activeTools,\n  experimental_repairToolCall: repairToolCall,\n  experimental_transform: transform,\n  onChunk,\n  onError,\n  onFinish,\n  onStepFinish,\n  _internal: {\n    now = originalNow,\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n  } = {},\n  ...settings\n}: CallSettings &\n  Prompt & {\n    /**\nThe language model to use.\n     */\n    model: LanguageModel;\n\n    /**\nThe tools that the model can call. The model needs to support calling tools.\n    */\n    tools?: TOOLS;\n\n    /**\nThe tool choice strategy. Default: 'auto'.\n     */\n    toolChoice?: ToolChoice<TOOLS>;\n\n    /**\nMaximum number of sequential LLM calls (steps), e.g. when you use tool calls. Must be at least 1.\n\nA maximum number is required to prevent infinite loops in the case of misconfigured tools.\n\nBy default, it's set to 1, which means that only a single LLM call is made.\n */\n    maxSteps?: number;\n\n    /**\nGenerate a unique ID for each message.\n     */\n    experimental_generateMessageId?: IDGenerator;\n\n    /**\nWhen enabled, the model will perform additional steps if the finish reason is \"length\" (experimental).\n\nBy default, it's set to false.\n     */\n    experimental_continueSteps?: boolean;\n\n    /**\nOptional telemetry configuration (experimental).\n     */\n    experimental_telemetry?: TelemetrySettings;\n\n    /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n    providerOptions?: ProviderOptions;\n\n    /**\n@deprecated Use `providerOptions` instead.\n */\n    experimental_providerMetadata?: ProviderMetadata;\n\n    /**\nLimits the tools that are available for the model to call without\nchanging the tool call and result types in the result.\n     */\n    experimental_activeTools?: Array<keyof TOOLS>;\n\n    /**\nOptional specification for parsing structured outputs from the LLM response.\n     */\n    experimental_output?: Output<OUTPUT, PARTIAL_OUTPUT>;\n\n    /**\nA function that attempts to repair a tool call that failed to parse.\n     */\n    experimental_repairToolCall?: ToolCallRepairFunction<TOOLS>;\n\n    /**\nEnable streaming of tool call deltas as they are generated. Disabled by default.\n     */\n    toolCallStreaming?: boolean;\n\n    /**\n@deprecated Use `toolCallStreaming` instead.\n     */\n    experimental_toolCallStreaming?: boolean;\n\n    /**\nOptional stream transformations.\nThey are applied in the order they are provided.\nThe stream transformations must maintain the stream structure for streamText to work correctly.\n     */\n    experimental_transform?:\n      | StreamTextTransform<TOOLS>\n      | Array<StreamTextTransform<TOOLS>>;\n\n    /**\nCallback that is called for each chunk of the stream.\nThe stream processing will pause until the callback promise is resolved.\n     */\n    onChunk?: StreamTextOnChunkCallback<TOOLS>;\n\n    /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n    onError?: StreamTextOnErrorCallback;\n\n    /**\nCallback that is called when the LLM response and all request tool executions\n(for tools that have an `execute` function) are finished.\n\nThe usage is the combined usage of all steps.\n     */\n    onFinish?: StreamTextOnFinishCallback<TOOLS>;\n\n    /**\nCallback that is called when each step (LLM call) is finished, including intermediate steps.\n    */\n    onStepFinish?: StreamTextOnStepFinishCallback<TOOLS>;\n\n    /**\nInternal. For test use only. May change without notice.\n     */\n    _internal?: {\n      now?: () => number;\n      generateId?: IDGenerator;\n      currentDate?: () => Date;\n    };\n  }): StreamTextResult<TOOLS, PARTIAL_OUTPUT> {\n  return new DefaultStreamTextResult<TOOLS, OUTPUT, PARTIAL_OUTPUT>({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    toolCallStreaming,\n    transforms: asArray(transform),\n    activeTools,\n    repairToolCall,\n    maxSteps,\n    output,\n    continueSteps,\n    providerOptions,\n    onChunk,\n    onError,\n    onFinish,\n    onStepFinish,\n    now,\n    currentDate,\n    generateId,\n    generateMessageId,\n  });\n}\n\ntype EnrichedStreamPart<TOOLS extends ToolSet, PARTIAL_OUTPUT> = {\n  part: TextStreamPart<TOOLS>;\n  partialOutput: PARTIAL_OUTPUT | undefined;\n};\n\nfunction createOutputTransformStream<\n  TOOLS extends ToolSet,\n  OUTPUT,\n  PARTIAL_OUTPUT,\n>(\n  output: Output<OUTPUT, PARTIAL_OUTPUT> | undefined,\n): TransformStream<\n  TextStreamPart<TOOLS>,\n  EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n> {\n  if (!output) {\n    return new TransformStream<\n      TextStreamPart<TOOLS>,\n      EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n    >({\n      transform(chunk, controller) {\n        controller.enqueue({ part: chunk, partialOutput: undefined });\n      },\n    });\n  }\n\n  let text = '';\n  let textChunk = '';\n  let lastPublishedJson = '';\n\n  function publishTextChunk({\n    controller,\n    partialOutput = undefined,\n  }: {\n    controller: TransformStreamDefaultController<\n      EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n    >;\n    partialOutput?: PARTIAL_OUTPUT;\n  }) {\n    controller.enqueue({\n      part: { type: 'text-delta', textDelta: textChunk },\n      partialOutput,\n    });\n    textChunk = '';\n  }\n\n  return new TransformStream<\n    TextStreamPart<TOOLS>,\n    EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n  >({\n    transform(chunk, controller) {\n      // ensure that we publish the last text chunk before the step finish:\n      if (chunk.type === 'step-finish') {\n        publishTextChunk({ controller });\n      }\n\n      if (chunk.type !== 'text-delta') {\n        controller.enqueue({ part: chunk, partialOutput: undefined });\n        return;\n      }\n\n      text += chunk.textDelta;\n      textChunk += chunk.textDelta;\n\n      // only publish if partial json can be parsed:\n      const result = output.parsePartial({ text });\n      if (result != null) {\n        // only send new json if it has changed:\n        const currentJson = JSON.stringify(result.partial);\n        if (currentJson !== lastPublishedJson) {\n          publishTextChunk({ controller, partialOutput: result.partial });\n          lastPublishedJson = currentJson;\n        }\n      }\n    },\n\n    flush(controller) {\n      // publish remaining text (there should be none if the content was correctly formatted):\n      if (textChunk.length > 0) {\n        publishTextChunk({ controller });\n      }\n    },\n  });\n}\n\nclass DefaultStreamTextResult<TOOLS extends ToolSet, OUTPUT, PARTIAL_OUTPUT>\n  implements StreamTextResult<TOOLS, PARTIAL_OUTPUT>\n{\n  private readonly warningsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['warnings']>\n  >();\n  private readonly usagePromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['usage']>\n  >();\n  private readonly finishReasonPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['finishReason']>\n  >();\n  private readonly providerMetadataPromise = new DelayedPromise<\n    Awaited<\n      StreamTextResult<TOOLS, PARTIAL_OUTPUT>['experimental_providerMetadata']\n    >\n  >();\n  private readonly textPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['text']>\n  >();\n  private readonly reasoningPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['reasoning']>\n  >();\n  private readonly reasoningDetailsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['reasoningDetails']>\n  >();\n  private readonly sourcesPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['sources']>\n  >();\n  private readonly filesPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['files']>\n  >();\n  private readonly toolCallsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['toolCalls']>\n  >();\n  private readonly toolResultsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['toolResults']>\n  >();\n  private readonly requestPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['request']>\n  >();\n  private readonly responsePromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['response']>\n  >();\n  private readonly stepsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['steps']>\n  >();\n\n  private readonly addStream: (\n    stream: ReadableStream<TextStreamPart<TOOLS>>,\n  ) => void;\n\n  private readonly closeStream: () => void;\n\n  private baseStream: ReadableStream<EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>>;\n\n  private output: Output<OUTPUT, PARTIAL_OUTPUT> | undefined;\n\n  constructor({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    toolCallStreaming,\n    transforms,\n    activeTools,\n    repairToolCall,\n    maxSteps,\n    output,\n    continueSteps,\n    providerOptions,\n    now,\n    currentDate,\n    generateId,\n    generateMessageId,\n    onChunk,\n    onError,\n    onFinish,\n    onStepFinish,\n  }: {\n    model: LanguageModel;\n    telemetry: TelemetrySettings | undefined;\n    headers: Record<string, string | undefined> | undefined;\n    settings: Omit<CallSettings, 'abortSignal' | 'headers'>;\n    maxRetries: number | undefined;\n    abortSignal: AbortSignal | undefined;\n    system: Prompt['system'];\n    prompt: Prompt['prompt'];\n    messages: Prompt['messages'];\n    tools: TOOLS | undefined;\n    toolChoice: ToolChoice<TOOLS> | undefined;\n    toolCallStreaming: boolean;\n    transforms: Array<StreamTextTransform<TOOLS>>;\n    activeTools: Array<keyof TOOLS> | undefined;\n    repairToolCall: ToolCallRepairFunction<TOOLS> | undefined;\n    maxSteps: number;\n    output: Output<OUTPUT, PARTIAL_OUTPUT> | undefined;\n    continueSteps: boolean;\n    providerOptions: ProviderOptions | undefined;\n    now: () => number;\n    currentDate: () => Date;\n    generateId: () => string;\n    generateMessageId: () => string;\n\n    // callbacks:\n    onChunk: undefined | StreamTextOnChunkCallback<TOOLS>;\n    onError: undefined | StreamTextOnErrorCallback;\n    onFinish: undefined | StreamTextOnFinishCallback<TOOLS>;\n    onStepFinish: undefined | StreamTextOnStepFinishCallback<TOOLS>;\n  }) {\n    if (maxSteps < 1) {\n      throw new InvalidArgumentError({\n        parameter: 'maxSteps',\n        value: maxSteps,\n        message: 'maxSteps must be at least 1',\n      });\n    }\n\n    this.output = output;\n\n    // event processor for telemetry, invoking callbacks, etc.\n    // The event processor reads the transformed stream to enable correct\n    // recording of the final transformed outputs.\n    let recordedStepText = '';\n    let recordedContinuationText = '';\n    let recordedFullText = '';\n\n    let stepReasoning: Array<ReasoningDetail> = [];\n    let stepFiles: Array<GeneratedFile> = [];\n    let activeReasoningText: undefined | (ReasoningDetail & { type: 'text' }) =\n      undefined;\n\n    let recordedStepSources: LanguageModelV1Source[] = [];\n    const recordedSources: LanguageModelV1Source[] = [];\n\n    const recordedResponse: LanguageModelResponseMetadata & {\n      messages: Array<ResponseMessage>;\n    } = {\n      id: generateId(),\n      timestamp: currentDate(),\n      modelId: model.modelId,\n      messages: [],\n    };\n    let recordedToolCalls: ToolCallUnion<TOOLS>[] = [];\n    let recordedToolResults: ToolResultUnion<TOOLS>[] = [];\n    let recordedFinishReason: FinishReason | undefined = undefined;\n    let recordedUsage: LanguageModelUsage | undefined = undefined;\n    let stepType: 'initial' | 'continue' | 'tool-result' = 'initial';\n    const recordedSteps: StepResult<TOOLS>[] = [];\n    let rootSpan!: Span;\n\n    const eventProcessor = new TransformStream<\n      EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>,\n      EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n    >({\n      async transform(chunk, controller) {\n        controller.enqueue(chunk); // forward the chunk to the next stream\n\n        const { part } = chunk;\n\n        if (\n          part.type === 'text-delta' ||\n          part.type === 'reasoning' ||\n          part.type === 'source' ||\n          part.type === 'tool-call' ||\n          part.type === 'tool-result' ||\n          part.type === 'tool-call-streaming-start' ||\n          part.type === 'tool-call-delta'\n        ) {\n          await onChunk?.({ chunk: part });\n        }\n\n        if (part.type === 'error') {\n          await onError?.({ error: part.error });\n        }\n\n        if (part.type === 'text-delta') {\n          recordedStepText += part.textDelta;\n          recordedContinuationText += part.textDelta;\n          recordedFullText += part.textDelta;\n        }\n\n        if (part.type === 'reasoning') {\n          if (activeReasoningText == null) {\n            activeReasoningText = { type: 'text', text: part.textDelta };\n            stepReasoning.push(activeReasoningText);\n          } else {\n            activeReasoningText.text += part.textDelta;\n          }\n        }\n\n        if (part.type === 'reasoning-signature') {\n          if (activeReasoningText == null) {\n            throw new AISDKError({\n              name: 'InvalidStreamPart',\n              message: 'reasoning-signature without reasoning',\n            });\n          }\n\n          activeReasoningText.signature = part.signature;\n          activeReasoningText = undefined; // signature concludes reasoning part\n        }\n\n        if (part.type === 'redacted-reasoning') {\n          stepReasoning.push({ type: 'redacted', data: part.data });\n        }\n\n        if (part.type === 'file') {\n          stepFiles.push(part);\n        }\n\n        if (part.type === 'source') {\n          recordedSources.push(part.source);\n          recordedStepSources.push(part.source);\n        }\n\n        if (part.type === 'tool-call') {\n          recordedToolCalls.push(part);\n        }\n\n        if (part.type === 'tool-result') {\n          recordedToolResults.push(part);\n        }\n\n        if (part.type === 'step-finish') {\n          const stepMessages = toResponseMessages({\n            text: recordedContinuationText,\n            files: stepFiles,\n            reasoning: stepReasoning,\n            tools: tools ?? ({} as TOOLS),\n            toolCalls: recordedToolCalls,\n            toolResults: recordedToolResults,\n            messageId: part.messageId,\n            generateMessageId,\n          });\n\n          // determine the next step type\n          const currentStep = recordedSteps.length;\n          let nextStepType: 'done' | 'continue' | 'tool-result' = 'done';\n          if (currentStep + 1 < maxSteps) {\n            if (\n              continueSteps &&\n              part.finishReason === 'length' &&\n              // only use continue when there are no tool calls:\n              recordedToolCalls.length === 0\n            ) {\n              nextStepType = 'continue';\n            } else if (\n              // there are tool calls:\n              recordedToolCalls.length > 0 &&\n              // all current tool calls have results:\n              recordedToolResults.length === recordedToolCalls.length\n            ) {\n              nextStepType = 'tool-result';\n            }\n          }\n\n          // Add step information (after response messages are updated):\n          const currentStepResult: StepResult<TOOLS> = {\n            stepType,\n            text: recordedStepText,\n            reasoning: asReasoningText(stepReasoning),\n            reasoningDetails: stepReasoning,\n            files: stepFiles,\n            sources: recordedStepSources,\n            toolCalls: recordedToolCalls,\n            toolResults: recordedToolResults,\n            finishReason: part.finishReason,\n            usage: part.usage,\n            warnings: part.warnings,\n            logprobs: part.logprobs,\n            request: part.request,\n            response: {\n              ...part.response,\n              messages: [...recordedResponse.messages, ...stepMessages],\n            },\n            providerMetadata: part.experimental_providerMetadata,\n            experimental_providerMetadata: part.experimental_providerMetadata,\n            isContinued: part.isContinued,\n          };\n\n          await onStepFinish?.(currentStepResult);\n\n          recordedSteps.push(currentStepResult);\n\n          recordedToolCalls = [];\n          recordedToolResults = [];\n          recordedStepText = '';\n          recordedStepSources = [];\n          stepReasoning = [];\n          stepFiles = [];\n          activeReasoningText = undefined;\n\n          if (nextStepType !== 'done') {\n            stepType = nextStepType;\n          }\n\n          if (nextStepType !== 'continue') {\n            recordedResponse.messages.push(...stepMessages);\n            recordedContinuationText = '';\n          }\n        }\n\n        if (part.type === 'finish') {\n          recordedResponse.id = part.response.id;\n          recordedResponse.timestamp = part.response.timestamp;\n          recordedResponse.modelId = part.response.modelId;\n          recordedResponse.headers = part.response.headers;\n          recordedUsage = part.usage;\n          recordedFinishReason = part.finishReason;\n        }\n      },\n\n      async flush(controller) {\n        try {\n          if (recordedSteps.length === 0) {\n            return; // no steps recorded (e.g. in error scenario)\n          }\n\n          // from last step (when there are errors there may be no last step)\n          const lastStep = recordedSteps[recordedSteps.length - 1];\n\n          self.warningsPromise.resolve(lastStep.warnings);\n          self.requestPromise.resolve(lastStep.request);\n          self.responsePromise.resolve(lastStep.response);\n          self.toolCallsPromise.resolve(lastStep.toolCalls);\n          self.toolResultsPromise.resolve(lastStep.toolResults);\n          self.providerMetadataPromise.resolve(\n            lastStep.experimental_providerMetadata,\n          );\n          self.reasoningPromise.resolve(lastStep.reasoning);\n          self.reasoningDetailsPromise.resolve(lastStep.reasoningDetails);\n\n          // derived:\n          const finishReason = recordedFinishReason ?? 'unknown';\n          const usage = recordedUsage ?? {\n            completionTokens: NaN,\n            promptTokens: NaN,\n            totalTokens: NaN,\n          };\n\n          // from finish:\n          self.finishReasonPromise.resolve(finishReason);\n          self.usagePromise.resolve(usage);\n\n          // aggregate results:\n          self.textPromise.resolve(recordedFullText);\n          self.sourcesPromise.resolve(recordedSources);\n          self.filesPromise.resolve(lastStep.files);\n          self.stepsPromise.resolve(recordedSteps);\n\n          // call onFinish callback:\n          await onFinish?.({\n            finishReason,\n            logprobs: undefined,\n            usage,\n            text: recordedFullText,\n            reasoning: lastStep.reasoning,\n            reasoningDetails: lastStep.reasoningDetails,\n            files: lastStep.files,\n            sources: lastStep.sources,\n            toolCalls: lastStep.toolCalls,\n            toolResults: lastStep.toolResults,\n            request: lastStep.request ?? {},\n            response: lastStep.response,\n            warnings: lastStep.warnings,\n            providerMetadata: lastStep.providerMetadata,\n            experimental_providerMetadata:\n              lastStep.experimental_providerMetadata,\n            steps: recordedSteps,\n          });\n\n          // Add response information to the root span:\n          rootSpan.setAttributes(\n            selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                'ai.response.finishReason': finishReason,\n                'ai.response.text': { output: () => recordedFullText },\n                'ai.response.toolCalls': {\n                  output: () =>\n                    lastStep.toolCalls?.length\n                      ? JSON.stringify(lastStep.toolCalls)\n                      : undefined,\n                },\n\n                'ai.usage.promptTokens': usage.promptTokens,\n                'ai.usage.completionTokens': usage.completionTokens,\n              },\n            }),\n          );\n        } catch (error) {\n          controller.error(error);\n        } finally {\n          rootSpan.end();\n        }\n      },\n    });\n\n    // initialize the stitchable stream and the transformed stream:\n    const stitchableStream = createStitchableStream<TextStreamPart<TOOLS>>();\n    this.addStream = stitchableStream.addStream;\n    this.closeStream = stitchableStream.close;\n\n    let stream = stitchableStream.stream;\n\n    // transform the stream before output parsing\n    // to enable replacement of stream segments:\n    for (const transform of transforms) {\n      stream = stream.pipeThrough(\n        transform({\n          tools: tools as TOOLS,\n          stopStream() {\n            stitchableStream.terminate();\n          },\n        }),\n      );\n    }\n\n    this.baseStream = stream\n      .pipeThrough(createOutputTransformStream(output))\n      .pipeThrough(eventProcessor);\n\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n    });\n\n    const tracer = getTracer(telemetry);\n\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...settings, maxRetries },\n    });\n\n    const initialPrompt = standardizePrompt({\n      prompt: {\n        system: output?.injectIntoSystemPrompt({ system, model }) ?? system,\n        prompt,\n        messages,\n      },\n      tools,\n    });\n\n    const self = this;\n\n    recordSpan({\n      name: 'ai.streamText',\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({ operationId: 'ai.streamText', telemetry }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          'ai.prompt': {\n            input: () => JSON.stringify({ system, prompt, messages }),\n          },\n          'ai.settings.maxSteps': maxSteps,\n        },\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async rootSpanArg => {\n        rootSpan = rootSpanArg;\n\n        async function streamStep({\n          currentStep,\n          responseMessages,\n          usage,\n          stepType,\n          previousStepText,\n          hasLeadingWhitespace,\n          messageId,\n        }: {\n          currentStep: number;\n          responseMessages: Array<ResponseMessage>;\n          usage: LanguageModelUsage;\n          stepType: 'initial' | 'continue' | 'tool-result';\n          previousStepText: string;\n          hasLeadingWhitespace: boolean;\n          messageId: string;\n        }) {\n          // after the 1st step, we need to switch to messages format:\n          const promptFormat =\n            responseMessages.length === 0 ? initialPrompt.type : 'messages';\n\n          const stepInputMessages = [\n            ...initialPrompt.messages,\n            ...responseMessages,\n          ];\n\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: {\n              type: promptFormat,\n              system: initialPrompt.system,\n              messages: stepInputMessages,\n            },\n            modelSupportsImageUrls: model.supportsImageUrls,\n            modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context\n          });\n\n          const mode = {\n            type: 'regular' as const,\n            ...prepareToolsAndToolChoice({ tools, toolChoice, activeTools }),\n          };\n\n          const {\n            result: { stream, warnings, rawResponse, request },\n            doStreamSpan,\n            startTimestampMs,\n          } = await retry(() =>\n            recordSpan({\n              name: 'ai.streamText.doStream',\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: 'ai.streamText.doStream',\n                    telemetry,\n                  }),\n                  ...baseTelemetryAttributes,\n                  'ai.prompt.format': {\n                    input: () => promptFormat,\n                  },\n                  'ai.prompt.messages': {\n                    input: () => stringifyForTelemetry(promptMessages),\n                  },\n                  'ai.prompt.tools': {\n                    // convert the language model level tools:\n                    input: () => mode.tools?.map(tool => JSON.stringify(tool)),\n                  },\n                  'ai.prompt.toolChoice': {\n                    input: () =>\n                      mode.toolChoice != null\n                        ? JSON.stringify(mode.toolChoice)\n                        : undefined,\n                  },\n\n                  // standardized gen-ai llm span attributes:\n                  'gen_ai.system': model.provider,\n                  'gen_ai.request.model': model.modelId,\n                  'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                  'gen_ai.request.max_tokens': settings.maxTokens,\n                  'gen_ai.request.presence_penalty': settings.presencePenalty,\n                  'gen_ai.request.stop_sequences': settings.stopSequences,\n                  'gen_ai.request.temperature': settings.temperature,\n                  'gen_ai.request.top_k': settings.topK,\n                  'gen_ai.request.top_p': settings.topP,\n                },\n              }),\n              tracer,\n              endWhenDone: false,\n              fn: async doStreamSpan => ({\n                startTimestampMs: now(), // get before the call\n                doStreamSpan,\n                result: await model.doStream({\n                  mode,\n                  ...prepareCallSettings(settings),\n                  inputFormat: promptFormat,\n                  responseFormat: output?.responseFormat({ model }),\n                  prompt: promptMessages,\n                  providerMetadata: providerOptions,\n                  abortSignal,\n                  headers,\n                }),\n              }),\n            }),\n          );\n\n          const transformedStream = runToolsTransformation({\n            tools,\n            generatorStream: stream,\n            toolCallStreaming,\n            tracer,\n            telemetry,\n            system,\n            messages: stepInputMessages,\n            repairToolCall,\n            abortSignal,\n          });\n\n          const stepRequest = request ?? {};\n          const stepToolCalls: ToolCallUnion<TOOLS>[] = [];\n          const stepToolResults: ToolResultUnion<TOOLS>[] = [];\n\n          const stepReasoning: Array<ReasoningDetail> = [];\n          const stepFiles: Array<GeneratedFile> = [];\n          let activeReasoningText:\n            | undefined\n            | (ReasoningDetail & { type: 'text' }) = undefined;\n\n          let stepFinishReason: FinishReason = 'unknown';\n          let stepUsage: LanguageModelUsage = {\n            promptTokens: 0,\n            completionTokens: 0,\n            totalTokens: 0,\n          };\n          let stepProviderMetadata: ProviderMetadata | undefined;\n          let stepFirstChunk = true;\n          let stepText = '';\n          let fullStepText = stepType === 'continue' ? previousStepText : '';\n          let stepLogProbs: LogProbs | undefined;\n          let stepResponse: { id: string; timestamp: Date; modelId: string } = {\n            id: generateId(),\n            timestamp: currentDate(),\n            modelId: model.modelId,\n          };\n\n          // chunk buffer when using continue:\n          let chunkBuffer = '';\n          let chunkTextPublished = false;\n          let inWhitespacePrefix = true;\n          let hasWhitespaceSuffix = false; // for next step. when true, step ended with whitespace\n\n          async function publishTextChunk({\n            controller,\n            chunk,\n          }: {\n            controller: TransformStreamDefaultController<TextStreamPart<TOOLS>>;\n            chunk: TextStreamPart<TOOLS> & { type: 'text-delta' };\n          }) {\n            controller.enqueue(chunk);\n\n            stepText += chunk.textDelta;\n            fullStepText += chunk.textDelta;\n            chunkTextPublished = true;\n            hasWhitespaceSuffix = chunk.textDelta.trimEnd() !== chunk.textDelta;\n          }\n\n          self.addStream(\n            transformedStream.pipeThrough(\n              new TransformStream<\n                SingleRequestTextStreamPart<TOOLS>,\n                TextStreamPart<TOOLS>\n              >({\n                async transform(chunk, controller): Promise<void> {\n                  if (stepFirstChunk) {\n                    // Telemetry for first chunk:\n                    const msToFirstChunk = now() - startTimestampMs;\n\n                    stepFirstChunk = false;\n\n                    doStreamSpan.addEvent('ai.stream.firstChunk', {\n                      'ai.response.msToFirstChunk': msToFirstChunk,\n                    });\n\n                    doStreamSpan.setAttributes({\n                      'ai.response.msToFirstChunk': msToFirstChunk,\n                    });\n\n                    // Step start:\n                    controller.enqueue({\n                      type: 'step-start',\n                      messageId,\n                      request: stepRequest,\n                      warnings: warnings ?? [],\n                    });\n                  }\n\n                  // Filter out empty text deltas\n                  if (\n                    chunk.type === 'text-delta' &&\n                    chunk.textDelta.length === 0\n                  ) {\n                    return;\n                  }\n\n                  const chunkType = chunk.type;\n                  switch (chunkType) {\n                    case 'text-delta': {\n                      if (continueSteps) {\n                        // when a new step starts, leading whitespace is to be discarded\n                        // when there is already preceding whitespace in the chunk buffer\n                        const trimmedChunkText =\n                          inWhitespacePrefix && hasLeadingWhitespace\n                            ? chunk.textDelta.trimStart()\n                            : chunk.textDelta;\n\n                        if (trimmedChunkText.length === 0) {\n                          break;\n                        }\n\n                        inWhitespacePrefix = false;\n                        chunkBuffer += trimmedChunkText;\n\n                        const split = splitOnLastWhitespace(chunkBuffer);\n\n                        // publish the text until the last whitespace:\n                        if (split != null) {\n                          chunkBuffer = split.suffix;\n\n                          await publishTextChunk({\n                            controller,\n                            chunk: {\n                              type: 'text-delta',\n                              textDelta: split.prefix + split.whitespace,\n                            },\n                          });\n                        }\n                      } else {\n                        await publishTextChunk({ controller, chunk });\n                      }\n                      break;\n                    }\n\n                    case 'reasoning': {\n                      controller.enqueue(chunk);\n\n                      if (activeReasoningText == null) {\n                        activeReasoningText = {\n                          type: 'text',\n                          text: chunk.textDelta,\n                        };\n                        stepReasoning.push(activeReasoningText);\n                      } else {\n                        activeReasoningText.text += chunk.textDelta;\n                      }\n\n                      break;\n                    }\n\n                    case 'reasoning-signature': {\n                      controller.enqueue(chunk);\n\n                      if (activeReasoningText == null) {\n                        throw new InvalidStreamPartError({\n                          chunk,\n                          message: 'reasoning-signature without reasoning',\n                        });\n                      }\n\n                      activeReasoningText.signature = chunk.signature;\n                      activeReasoningText = undefined; // signature concludes reasoning part\n                      break;\n                    }\n\n                    case 'redacted-reasoning': {\n                      controller.enqueue(chunk);\n                      stepReasoning.push({\n                        type: 'redacted',\n                        data: chunk.data,\n                      });\n\n                      break;\n                    }\n\n                    case 'tool-call': {\n                      controller.enqueue(chunk);\n                      // store tool calls for onFinish callback and toolCalls promise:\n                      stepToolCalls.push(chunk);\n                      break;\n                    }\n\n                    case 'tool-result': {\n                      controller.enqueue(chunk);\n                      // store tool results for onFinish callback and toolResults promise:\n                      stepToolResults.push(chunk);\n                      break;\n                    }\n\n                    case 'response-metadata': {\n                      stepResponse = {\n                        id: chunk.id ?? stepResponse.id,\n                        timestamp: chunk.timestamp ?? stepResponse.timestamp,\n                        modelId: chunk.modelId ?? stepResponse.modelId,\n                      };\n                      break;\n                    }\n\n                    case 'finish': {\n                      // Note: tool executions might not be finished yet when the finish event is emitted.\n                      // store usage and finish reason for promises and onFinish callback:\n                      stepUsage = chunk.usage;\n                      stepFinishReason = chunk.finishReason;\n                      stepProviderMetadata =\n                        chunk.experimental_providerMetadata;\n                      stepLogProbs = chunk.logprobs;\n\n                      // Telemetry for finish event timing\n                      // (since tool executions can take longer and distort calculations)\n                      const msToFinish = now() - startTimestampMs;\n                      doStreamSpan.addEvent('ai.stream.finish');\n                      doStreamSpan.setAttributes({\n                        'ai.response.msToFinish': msToFinish,\n                        'ai.response.avgCompletionTokensPerSecond':\n                          (1000 * stepUsage.completionTokens) / msToFinish,\n                      });\n\n                      break;\n                    }\n\n                    case 'file': {\n                      stepFiles.push(chunk);\n                      controller.enqueue(chunk);\n                      break;\n                    }\n\n                    // forward:\n                    case 'source':\n                    case 'tool-call-streaming-start':\n                    case 'tool-call-delta': {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n\n                    case 'error': {\n                      controller.enqueue(chunk);\n                      stepFinishReason = 'error';\n                      break;\n                    }\n\n                    default: {\n                      const exhaustiveCheck: never = chunkType;\n                      throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                    }\n                  }\n                },\n\n                // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                async flush(controller) {\n                  const stepToolCallsJson =\n                    stepToolCalls.length > 0\n                      ? JSON.stringify(stepToolCalls)\n                      : undefined;\n\n                  // determine the next step type\n                  let nextStepType: 'done' | 'continue' | 'tool-result' =\n                    'done';\n                  if (currentStep + 1 < maxSteps) {\n                    if (\n                      continueSteps &&\n                      stepFinishReason === 'length' &&\n                      // only use continue when there are no tool calls:\n                      stepToolCalls.length === 0\n                    ) {\n                      nextStepType = 'continue';\n                    } else if (\n                      // there are tool calls:\n                      stepToolCalls.length > 0 &&\n                      // all current tool calls have results:\n                      stepToolResults.length === stepToolCalls.length\n                    ) {\n                      nextStepType = 'tool-result';\n                    }\n                  }\n\n                  // when using continuation, publish buffer on final step or if there\n                  // was no whitespace in the step:\n                  if (\n                    continueSteps &&\n                    chunkBuffer.length > 0 &&\n                    (nextStepType !== 'continue' || // when the next step is a regular step, publish the buffer\n                      (stepType === 'continue' && !chunkTextPublished)) // when the next step is a continue step, publish the buffer if no text was published in the step\n                  ) {\n                    await publishTextChunk({\n                      controller,\n                      chunk: {\n                        type: 'text-delta',\n                        textDelta: chunkBuffer,\n                      },\n                    });\n                    chunkBuffer = '';\n                  }\n\n                  // record telemetry information first to ensure best effort timing\n                  try {\n                    doStreamSpan.setAttributes(\n                      selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                          'ai.response.finishReason': stepFinishReason,\n                          'ai.response.text': { output: () => stepText },\n                          'ai.response.toolCalls': {\n                            output: () => stepToolCallsJson,\n                          },\n                          'ai.response.id': stepResponse.id,\n                          'ai.response.model': stepResponse.modelId,\n                          'ai.response.timestamp':\n                            stepResponse.timestamp.toISOString(),\n\n                          'ai.usage.promptTokens': stepUsage.promptTokens,\n                          'ai.usage.completionTokens':\n                            stepUsage.completionTokens,\n\n                          // standardized gen-ai llm span attributes:\n                          'gen_ai.response.finish_reasons': [stepFinishReason],\n                          'gen_ai.response.id': stepResponse.id,\n                          'gen_ai.response.model': stepResponse.modelId,\n                          'gen_ai.usage.input_tokens': stepUsage.promptTokens,\n                          'gen_ai.usage.output_tokens':\n                            stepUsage.completionTokens,\n                        },\n                      }),\n                    );\n                  } catch (error) {\n                    // ignore error setting telemetry attributes\n                  } finally {\n                    // finish doStreamSpan before other operations for correct timing:\n                    doStreamSpan.end();\n                  }\n\n                  controller.enqueue({\n                    type: 'step-finish',\n                    finishReason: stepFinishReason,\n                    usage: stepUsage,\n                    providerMetadata: stepProviderMetadata,\n                    experimental_providerMetadata: stepProviderMetadata,\n                    logprobs: stepLogProbs,\n                    request: stepRequest,\n                    response: {\n                      ...stepResponse,\n                      headers: rawResponse?.headers,\n                    },\n                    warnings,\n                    isContinued: nextStepType === 'continue',\n                    messageId,\n                  });\n\n                  const combinedUsage = addLanguageModelUsage(usage, stepUsage);\n\n                  if (nextStepType === 'done') {\n                    controller.enqueue({\n                      type: 'finish',\n                      finishReason: stepFinishReason,\n                      usage: combinedUsage,\n                      providerMetadata: stepProviderMetadata,\n                      experimental_providerMetadata: stepProviderMetadata,\n                      logprobs: stepLogProbs,\n                      response: {\n                        ...stepResponse,\n                        headers: rawResponse?.headers,\n                      },\n                    });\n\n                    self.closeStream(); // close the stitchable stream\n                  } else {\n                    // append to messages for the next step:\n                    if (stepType === 'continue') {\n                      // continue step: update the last assistant message\n                      // continue is only possible when there are no tool calls,\n                      // so we can assume that there is a single last assistant message:\n                      const lastMessage = responseMessages[\n                        responseMessages.length - 1\n                      ] as CoreAssistantMessage;\n\n                      if (typeof lastMessage.content === 'string') {\n                        lastMessage.content += stepText;\n                      } else {\n                        lastMessage.content.push({\n                          text: stepText,\n                          type: 'text',\n                        });\n                      }\n                    } else {\n                      responseMessages.push(\n                        ...toResponseMessages({\n                          text: stepText,\n                          files: stepFiles,\n                          reasoning: stepReasoning,\n                          tools: tools ?? ({} as TOOLS),\n                          toolCalls: stepToolCalls,\n                          toolResults: stepToolResults,\n                          messageId,\n                          generateMessageId,\n                        }),\n                      );\n                    }\n\n                    await streamStep({\n                      currentStep: currentStep + 1,\n                      responseMessages,\n                      usage: combinedUsage,\n                      stepType: nextStepType,\n                      previousStepText: fullStepText,\n                      hasLeadingWhitespace: hasWhitespaceSuffix,\n                      messageId:\n                        // keep the same id when continuing a step:\n                        nextStepType === 'continue'\n                          ? messageId\n                          : generateMessageId(),\n                    });\n                  }\n                },\n              }),\n            ),\n          );\n        }\n\n        // add the initial stream to the stitchable stream\n        await streamStep({\n          currentStep: 0,\n          responseMessages: [],\n          usage: {\n            promptTokens: 0,\n            completionTokens: 0,\n            totalTokens: 0,\n          },\n          previousStepText: '',\n          stepType: 'initial',\n          hasLeadingWhitespace: false,\n          messageId: generateMessageId(),\n        });\n      },\n    }).catch(error => {\n      // add an error stream part and close the streams:\n      self.addStream(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue({ type: 'error', error });\n            controller.close();\n          },\n        }),\n      );\n      self.closeStream();\n    });\n  }\n\n  get warnings() {\n    return this.warningsPromise.value;\n  }\n\n  get usage() {\n    return this.usagePromise.value;\n  }\n\n  get finishReason() {\n    return this.finishReasonPromise.value;\n  }\n\n  get experimental_providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n\n  get providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n\n  get text() {\n    return this.textPromise.value;\n  }\n\n  get reasoning() {\n    return this.reasoningPromise.value;\n  }\n\n  get reasoningDetails() {\n    return this.reasoningDetailsPromise.value;\n  }\n\n  get sources() {\n    return this.sourcesPromise.value;\n  }\n\n  get files() {\n    return this.filesPromise.value;\n  }\n\n  get toolCalls() {\n    return this.toolCallsPromise.value;\n  }\n\n  get toolResults() {\n    return this.toolResultsPromise.value;\n  }\n\n  get request() {\n    return this.requestPromise.value;\n  }\n\n  get response() {\n    return this.responsePromise.value;\n  }\n\n  get steps() {\n    return this.stepsPromise.value;\n  }\n\n  /**\nSplit out a new stream from the original stream.\nThe original stream is replaced to allow for further splitting,\nsince we do not know how many times the stream will be split.\n\nNote: this leads to buffering the stream content on the server.\nHowever, the LLM results are expected to be small enough to not cause issues.\n   */\n  private teeStream() {\n    const [stream1, stream2] = this.baseStream.tee();\n    this.baseStream = stream2;\n    return stream1;\n  }\n\n  get textStream(): AsyncIterableStream<string> {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream<EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>, string>({\n          transform({ part }, controller) {\n            if (part.type === 'text-delta') {\n              controller.enqueue(part.textDelta);\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  get fullStream(): AsyncIterableStream<TextStreamPart<TOOLS>> {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream<\n          EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>,\n          TextStreamPart<TOOLS>\n        >({\n          transform({ part }, controller) {\n            controller.enqueue(part);\n          },\n        }),\n      ),\n    );\n  }\n\n  async consumeStream(options?: ConsumeStreamOptions): Promise<void> {\n    try {\n      await consumeStream({\n        stream: this.fullStream,\n        onError: options?.onError,\n      });\n    } catch (error) {\n      options?.onError?.(error);\n    }\n  }\n\n  get experimental_partialOutputStream(): AsyncIterableStream<PARTIAL_OUTPUT> {\n    if (this.output == null) {\n      throw new NoOutputSpecifiedError();\n    }\n\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream<\n          EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>,\n          PARTIAL_OUTPUT\n        >({\n          transform({ partialOutput }, controller) {\n            if (partialOutput != null) {\n              controller.enqueue(partialOutput);\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  private toDataStreamInternal({\n    getErrorMessage = () => 'An error occurred.', // mask error messages for safety by default\n    sendUsage = true,\n    sendReasoning = false,\n    sendSources = false,\n    experimental_sendFinish = true,\n  }: {\n    getErrorMessage: ((error: unknown) => string) | undefined;\n    sendUsage: boolean | undefined;\n    sendReasoning: boolean | undefined;\n    sendSources: boolean | undefined;\n    experimental_sendFinish: boolean | undefined;\n  }): ReadableStream<DataStreamString> {\n    return this.fullStream.pipeThrough(\n      new TransformStream<TextStreamPart<TOOLS>, DataStreamString>({\n        transform: async (chunk, controller) => {\n          const chunkType = chunk.type;\n          switch (chunkType) {\n            case 'text-delta': {\n              controller.enqueue(formatDataStreamPart('text', chunk.textDelta));\n              break;\n            }\n\n            case 'reasoning': {\n              if (sendReasoning) {\n                controller.enqueue(\n                  formatDataStreamPart('reasoning', chunk.textDelta),\n                );\n              }\n              break;\n            }\n\n            case 'redacted-reasoning': {\n              if (sendReasoning) {\n                controller.enqueue(\n                  formatDataStreamPart('redacted_reasoning', {\n                    data: chunk.data,\n                  }),\n                );\n              }\n              break;\n            }\n\n            case 'reasoning-signature': {\n              if (sendReasoning) {\n                controller.enqueue(\n                  formatDataStreamPart('reasoning_signature', {\n                    signature: chunk.signature,\n                  }),\n                );\n              }\n              break;\n            }\n\n            case 'file': {\n              controller.enqueue(\n                formatDataStreamPart('file', {\n                  mimeType: chunk.mimeType,\n                  data: chunk.base64,\n                }),\n              );\n              break;\n            }\n\n            case 'source': {\n              if (sendSources) {\n                controller.enqueue(\n                  formatDataStreamPart('source', chunk.source),\n                );\n              }\n              break;\n            }\n\n            case 'tool-call-streaming-start': {\n              controller.enqueue(\n                formatDataStreamPart('tool_call_streaming_start', {\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                }),\n              );\n              break;\n            }\n\n            case 'tool-call-delta': {\n              controller.enqueue(\n                formatDataStreamPart('tool_call_delta', {\n                  toolCallId: chunk.toolCallId,\n                  argsTextDelta: chunk.argsTextDelta,\n                }),\n              );\n              break;\n            }\n\n            case 'tool-call': {\n              controller.enqueue(\n                formatDataStreamPart('tool_call', {\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  args: chunk.args,\n                }),\n              );\n              break;\n            }\n\n            case 'tool-result': {\n              controller.enqueue(\n                formatDataStreamPart('tool_result', {\n                  toolCallId: chunk.toolCallId,\n                  result: chunk.result,\n                }),\n              );\n              break;\n            }\n\n            case 'error': {\n              controller.enqueue(\n                formatDataStreamPart('error', getErrorMessage(chunk.error)),\n              );\n              break;\n            }\n\n            case 'step-start': {\n              controller.enqueue(\n                formatDataStreamPart('start_step', {\n                  messageId: chunk.messageId,\n                }),\n              );\n              break;\n            }\n\n            case 'step-finish': {\n              controller.enqueue(\n                formatDataStreamPart('finish_step', {\n                  finishReason: chunk.finishReason,\n                  usage: sendUsage\n                    ? {\n                        promptTokens: chunk.usage.promptTokens,\n                        completionTokens: chunk.usage.completionTokens,\n                      }\n                    : undefined,\n                  isContinued: chunk.isContinued,\n                }),\n              );\n              break;\n            }\n\n            case 'finish': {\n              if (experimental_sendFinish) {\n                controller.enqueue(\n                  formatDataStreamPart('finish_message', {\n                    finishReason: chunk.finishReason,\n                    usage: sendUsage\n                      ? {\n                          promptTokens: chunk.usage.promptTokens,\n                          completionTokens: chunk.usage.completionTokens,\n                        }\n                      : undefined,\n                  }),\n                );\n              }\n              break;\n            }\n\n            default: {\n              const exhaustiveCheck: never = chunkType;\n              throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n            }\n          }\n        },\n      }),\n    );\n  }\n\n  pipeDataStreamToResponse(\n    response: ServerResponse,\n    {\n      status,\n      statusText,\n      headers,\n      data,\n      getErrorMessage,\n      sendUsage,\n      sendReasoning,\n      sendSources,\n      experimental_sendFinish,\n    }: ResponseInit &\n      DataStreamOptions & {\n        data?: StreamData;\n        getErrorMessage?: (error: unknown) => string;\n      } = {},\n  ) {\n    writeToServerResponse({\n      response,\n      status,\n      statusText,\n      headers: prepareOutgoingHttpHeaders(headers, {\n        contentType: 'text/plain; charset=utf-8',\n        dataStreamVersion: 'v1',\n      }),\n      stream: this.toDataStream({\n        data,\n        getErrorMessage,\n        sendUsage,\n        sendReasoning,\n        sendSources,\n        experimental_sendFinish,\n      }),\n    });\n  }\n\n  pipeTextStreamToResponse(response: ServerResponse, init?: ResponseInit) {\n    writeToServerResponse({\n      response,\n      status: init?.status,\n      statusText: init?.statusText,\n      headers: prepareOutgoingHttpHeaders(init?.headers, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n      stream: this.textStream.pipeThrough(new TextEncoderStream()),\n    });\n  }\n\n  // TODO breaking change 5.0: remove pipeThrough(new TextEncoderStream())\n  toDataStream(\n    options?: DataStreamOptions & {\n      data?: StreamData;\n      getErrorMessage?: (error: unknown) => string;\n    },\n  ) {\n    const stream = this.toDataStreamInternal({\n      getErrorMessage: options?.getErrorMessage,\n      sendUsage: options?.sendUsage,\n      sendReasoning: options?.sendReasoning,\n      sendSources: options?.sendSources,\n      experimental_sendFinish: options?.experimental_sendFinish,\n    }).pipeThrough(new TextEncoderStream());\n\n    return options?.data ? mergeStreams(options?.data.stream, stream) : stream;\n  }\n\n  mergeIntoDataStream(writer: DataStreamWriter, options?: DataStreamOptions) {\n    writer.merge(\n      this.toDataStreamInternal({\n        getErrorMessage: writer.onError,\n        sendUsage: options?.sendUsage,\n        sendReasoning: options?.sendReasoning,\n        sendSources: options?.sendSources,\n        experimental_sendFinish: options?.experimental_sendFinish,\n      }),\n    );\n  }\n\n  toDataStreamResponse({\n    headers,\n    status,\n    statusText,\n    data,\n    getErrorMessage,\n    sendUsage,\n    sendReasoning,\n    sendSources,\n    experimental_sendFinish,\n  }: ResponseInit &\n    DataStreamOptions & {\n      data?: StreamData;\n      getErrorMessage?: (error: unknown) => string;\n    } = {}): Response {\n    return new Response(\n      this.toDataStream({\n        data,\n        getErrorMessage,\n        sendUsage,\n        sendReasoning,\n        sendSources,\n        experimental_sendFinish,\n      }),\n      {\n        status,\n        statusText,\n        headers: prepareResponseHeaders(headers, {\n          contentType: 'text/plain; charset=utf-8',\n          dataStreamVersion: 'v1',\n        }),\n      },\n    );\n  }\n\n  toTextStreamResponse(init?: ResponseInit): Response {\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: init?.status ?? 200,\n      headers: prepareResponseHeaders(init?.headers, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n    });\n  }\n}\n", "export function asArray<T>(value: T | T[] | undefined): T[] {\n  return value === undefined ? [] : Array.isArray(value) ? value : [value];\n}\n", "/**\n * Consumes a ReadableStream until it's fully read.\n *\n * This function reads the stream chunk by chunk until the stream is exhausted.\n * It doesn't process or return the data from the stream; it simply ensures\n * that the entire stream is read.\n *\n * @param {ReadableStream} stream - The ReadableStream to be consumed.\n * @returns {Promise<void>} A promise that resolves when the stream is fully consumed.\n */\nexport async function consumeStream({\n  stream,\n  onError,\n}: {\n  stream: ReadableStream;\n  onError?: (error: unknown) => void;\n}): Promise<void> {\n  const reader = stream.getReader();\n  try {\n    while (true) {\n      const { done } = await reader.read();\n      if (done) break;\n    }\n  } catch (error) {\n    onError?.(error);\n  } finally {\n    reader.releaseLock();\n  }\n}\n", "/**\n * Merges two readable streams into a single readable stream, emitting values\n * from each stream as they become available.\n *\n * The first stream is prioritized over the second stream. If both streams have\n * values available, the first stream's value is emitted first.\n *\n * @template VALUE1 - The type of values emitted by the first stream.\n * @template VALUE2 - The type of values emitted by the second stream.\n * @param {ReadableStream<VALUE1>} stream1 - The first readable stream.\n * @param {ReadableStream<VALUE2>} stream2 - The second readable stream.\n * @returns {ReadableStream<VALUE1 | VALUE2>} A new readable stream that emits values from both input streams.\n */\nexport function mergeStreams<VALUE1, VALUE2>(\n  stream1: ReadableStream<VALUE1>,\n  stream2: ReadableStream<VALUE2>,\n): ReadableStream<VALUE1 | VALUE2> {\n  const reader1 = stream1.getReader();\n  const reader2 = stream2.getReader();\n\n  let lastRead1: Promise<ReadableStreamReadResult<VALUE1>> | undefined =\n    undefined;\n  let lastRead2: Promise<ReadableStreamReadResult<VALUE2>> | undefined =\n    undefined;\n\n  let stream1Done = false;\n  let stream2Done = false;\n\n  // only use when stream 2 is done:\n  async function readStream1(\n    controller: ReadableStreamDefaultController<VALUE1 | VALUE2>,\n  ) {\n    try {\n      if (lastRead1 == null) {\n        lastRead1 = reader1.read();\n      }\n\n      const result = await lastRead1;\n      lastRead1 = undefined;\n\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n\n  // only use when stream 1 is done:\n  async function readStream2(\n    controller: ReadableStreamDefaultController<VALUE1 | VALUE2>,\n  ) {\n    try {\n      if (lastRead2 == null) {\n        lastRead2 = reader2.read();\n      }\n\n      const result = await lastRead2;\n      lastRead2 = undefined;\n\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n\n  return new ReadableStream<VALUE1 | VALUE2>({\n    async pull(controller) {\n      try {\n        // stream 1 is done, we can only read from stream 2:\n        if (stream1Done) {\n          await readStream2(controller);\n          return;\n        }\n\n        // stream 2 is done, we can only read from stream 1:\n        if (stream2Done) {\n          await readStream1(controller);\n          return;\n        }\n\n        // pull the next value from the stream that was read last:\n        if (lastRead1 == null) {\n          lastRead1 = reader1.read();\n        }\n        if (lastRead2 == null) {\n          lastRead2 = reader2.read();\n        }\n\n        // Note on Promise.race (prioritizing stream 1 over stream 2):\n        // If the iterable contains one or more non-promise values and/or an already settled promise,\n        // then Promise.race() will settle to the first of these values found in the iterable.\n        const { result, reader } = await Promise.race([\n          lastRead1.then(result => ({ result, reader: reader1 })),\n          lastRead2.then(result => ({ result, reader: reader2 })),\n        ]);\n\n        if (!result.done) {\n          controller.enqueue(result.value);\n        }\n\n        if (reader === reader1) {\n          lastRead1 = undefined;\n          if (result.done) {\n            // stream 1 is done, we can only read from stream 2:\n            await readStream2(controller);\n            stream1Done = true;\n          }\n        } else {\n          lastRead2 = undefined;\n          // stream 2 is done, we can only read from stream 1:\n          if (result.done) {\n            stream2Done = true;\n            await readStream1(controller);\n          }\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    cancel() {\n      reader1.cancel();\n      reader2.cancel();\n    },\n  });\n}\n", "import { LanguageModelV1StreamPart } from '@ai-sdk/provider';\nimport { generateId } from '@ai-sdk/ui-utils';\nimport { Tracer } from '@opentelemetry/api';\nimport { ToolExecutionError } from '../../errors';\nimport { CoreMessage } from '../prompt/message';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  FinishReason,\n  LanguageModelUsage,\n  LogProbs,\n  ProviderMetadata,\n} from '../types';\nimport { Source } from '../types/language-model';\nimport { calculateLanguageModelUsage } from '../types/usage';\nimport { DefaultGeneratedFileWithType, GeneratedFile } from './generated-file';\nimport { parseToolCall } from './parse-tool-call';\nimport { ToolCallUnion } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair';\nimport { ToolResultUnion } from './tool-result';\nimport { ToolSet } from './tool-set';\n\nexport type SingleRequestTextStreamPart<TOOLS extends ToolSet> =\n  | {\n      type: 'text-delta';\n      textDelta: string;\n    }\n  | {\n      type: 'reasoning';\n      textDelta: string;\n    }\n  | {\n      type: 'reasoning-signature';\n      signature: string;\n    }\n  | {\n      type: 'redacted-reasoning';\n      data: string;\n    }\n  | ({\n      type: 'file';\n    } & GeneratedFile)\n  | {\n      type: 'source';\n      source: Source;\n    }\n  | ({\n      type: 'tool-call';\n    } & ToolCallUnion<TOOLS>)\n  | {\n      type: 'tool-call-streaming-start';\n      toolCallId: string;\n      toolName: string;\n    }\n  | {\n      type: 'tool-call-delta';\n      toolCallId: string;\n      toolName: string;\n      argsTextDelta: string;\n    }\n  | ({\n      type: 'tool-result';\n    } & ToolResultUnion<TOOLS>)\n  | {\n      type: 'response-metadata';\n      id?: string;\n      timestamp?: Date;\n      modelId?: string;\n    }\n  | {\n      type: 'finish';\n      finishReason: FinishReason;\n      logprobs?: LogProbs;\n      usage: LanguageModelUsage;\n      experimental_providerMetadata?: ProviderMetadata;\n    }\n  | {\n      type: 'error';\n      error: unknown;\n    };\n\nexport function runToolsTransformation<TOOLS extends ToolSet>({\n  tools,\n  generatorStream,\n  toolCallStreaming,\n  tracer,\n  telemetry,\n  system,\n  messages,\n  abortSignal,\n  repairToolCall,\n}: {\n  tools: TOOLS | undefined;\n  generatorStream: ReadableStream<LanguageModelV1StreamPart>;\n  toolCallStreaming: boolean;\n  tracer: Tracer;\n  telemetry: TelemetrySettings | undefined;\n  system: string | undefined;\n  messages: CoreMessage[];\n  abortSignal: AbortSignal | undefined;\n  repairToolCall: ToolCallRepairFunction<TOOLS> | undefined;\n}): ReadableStream<SingleRequestTextStreamPart<TOOLS>> {\n  // tool results stream\n  let toolResultsStreamController: ReadableStreamDefaultController<\n    SingleRequestTextStreamPart<TOOLS>\n  > | null = null;\n  const toolResultsStream = new ReadableStream<\n    SingleRequestTextStreamPart<TOOLS>\n  >({\n    start(controller) {\n      toolResultsStreamController = controller;\n    },\n  });\n\n  // keep track of active tool calls for tool call streaming:\n  const activeToolCalls: Record<string, boolean> = {};\n\n  // keep track of outstanding tool results for stream closing:\n  const outstandingToolResults = new Set<string>();\n\n  let canClose = false;\n  let finishChunk:\n    | (SingleRequestTextStreamPart<TOOLS> & { type: 'finish' })\n    | undefined = undefined;\n\n  function attemptClose() {\n    // close the tool results controller if no more outstanding tool calls\n    if (canClose && outstandingToolResults.size === 0) {\n      // we delay sending the finish chunk until all tool results (incl. delayed ones)\n      // are received to ensure that the frontend receives tool results before a message\n      // finish event arrives.\n      if (finishChunk != null) {\n        toolResultsStreamController!.enqueue(finishChunk);\n      }\n\n      toolResultsStreamController!.close();\n    }\n  }\n\n  // forward stream\n  const forwardStream = new TransformStream<\n    LanguageModelV1StreamPart,\n    SingleRequestTextStreamPart<TOOLS>\n  >({\n    async transform(\n      chunk: LanguageModelV1StreamPart,\n      controller: TransformStreamDefaultController<\n        SingleRequestTextStreamPart<TOOLS>\n      >,\n    ) {\n      const chunkType = chunk.type;\n\n      switch (chunkType) {\n        // forward:\n        case 'text-delta':\n        case 'reasoning':\n        case 'reasoning-signature':\n        case 'redacted-reasoning':\n        case 'source':\n        case 'response-metadata':\n        case 'error': {\n          controller.enqueue(chunk);\n          break;\n        }\n\n        case 'file': {\n          controller.enqueue(\n            new DefaultGeneratedFileWithType({\n              data: chunk.data,\n              mimeType: chunk.mimeType,\n            }),\n          );\n          break;\n        }\n\n        // forward with less information:\n        case 'tool-call-delta': {\n          if (toolCallStreaming) {\n            if (!activeToolCalls[chunk.toolCallId]) {\n              controller.enqueue({\n                type: 'tool-call-streaming-start',\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n              });\n\n              activeToolCalls[chunk.toolCallId] = true;\n            }\n\n            controller.enqueue({\n              type: 'tool-call-delta',\n              toolCallId: chunk.toolCallId,\n              toolName: chunk.toolName,\n              argsTextDelta: chunk.argsTextDelta,\n            });\n          }\n          break;\n        }\n\n        // process tool call:\n        case 'tool-call': {\n          try {\n            const toolCall = await parseToolCall({\n              toolCall: chunk,\n              tools,\n              repairToolCall,\n              system,\n              messages,\n            });\n\n            controller.enqueue(toolCall);\n\n            const tool = tools![toolCall.toolName];\n\n            if (tool.execute != null) {\n              const toolExecutionId = generateId(); // use our own id to guarantee uniqueness\n              outstandingToolResults.add(toolExecutionId);\n\n              // Note: we don't await the tool execution here (by leaving out 'await' on recordSpan),\n              // because we want to process the next chunk as soon as possible.\n              // This is important for the case where the tool execution takes a long time.\n              recordSpan({\n                name: 'ai.toolCall',\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: 'ai.toolCall',\n                      telemetry,\n                    }),\n                    'ai.toolCall.name': toolCall.toolName,\n                    'ai.toolCall.id': toolCall.toolCallId,\n                    'ai.toolCall.args': {\n                      output: () => JSON.stringify(toolCall.args),\n                    },\n                  },\n                }),\n                tracer,\n                fn: async span =>\n                  tool.execute!(toolCall.args, {\n                    toolCallId: toolCall.toolCallId,\n                    messages,\n                    abortSignal,\n                  }).then(\n                    (result: any) => {\n                      toolResultsStreamController!.enqueue({\n                        ...toolCall,\n                        type: 'tool-result',\n                        result,\n                      } as any);\n\n                      outstandingToolResults.delete(toolExecutionId);\n\n                      attemptClose();\n\n                      // record telemetry\n                      try {\n                        span.setAttributes(\n                          selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                              'ai.toolCall.result': {\n                                output: () => JSON.stringify(result),\n                              },\n                            },\n                          }),\n                        );\n                      } catch (ignored) {\n                        // JSON stringify might fail if the result is not serializable,\n                        // in which case we just ignore it. In the future we might want to\n                        // add an optional serialize method to the tool interface and warn\n                        // if the result is not serializable.\n                      }\n                    },\n                    (error: any) => {\n                      toolResultsStreamController!.enqueue({\n                        type: 'error',\n                        error: new ToolExecutionError({\n                          toolCallId: toolCall.toolCallId,\n                          toolName: toolCall.toolName,\n                          toolArgs: toolCall.args,\n                          cause: error,\n                        }),\n                      });\n\n                      outstandingToolResults.delete(toolExecutionId);\n                      attemptClose();\n                    },\n                  ),\n              });\n            }\n          } catch (error) {\n            toolResultsStreamController!.enqueue({\n              type: 'error',\n              error,\n            });\n          }\n\n          break;\n        }\n\n        case 'finish': {\n          finishChunk = {\n            type: 'finish',\n            finishReason: chunk.finishReason,\n            logprobs: chunk.logprobs,\n            usage: calculateLanguageModelUsage(chunk.usage),\n            experimental_providerMetadata: chunk.providerMetadata,\n          };\n          break;\n        }\n\n        default: {\n          const _exhaustiveCheck: never = chunkType;\n          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n\n    flush() {\n      canClose = true;\n      attemptClose();\n    },\n  });\n\n  // combine the generator stream and the tool results stream\n  return new ReadableStream<SingleRequestTextStreamPart<TOOLS>>({\n    async start(controller) {\n      // need to wait for both pipes so there are no dangling promises that\n      // can cause uncaught promise rejections when the stream is aborted\n      return Promise.all([\n        generatorStream.pipeThrough(forwardStream).pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              // the generator stream controller is automatically closed when it's consumed\n            },\n          }),\n        ),\n        toolResultsStream.pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              controller.close();\n            },\n          }),\n        ),\n      ]);\n    },\n  });\n}\n", "import { AISDKError } from '@ai-sdk/provider';\nimport { SpeechModelResponseMetadata } from '../core/types/speech-model-response-metadata';\n\n/**\nError that is thrown when no speech audio was generated.\n */\nexport class NoSpeechGeneratedError extends AISDKError {\n  readonly responses: Array<SpeechModelResponseMetadata>;\n\n  constructor(options: { responses: Array<SpeechModelResponseMetadata> }) {\n    super({\n      name: 'AI_NoSpeechGeneratedError',\n      message: 'No speech audio generated.',\n    });\n\n    this.responses = options.responses;\n  }\n}\n", "import {\n  GeneratedFile,\n  DefaultGeneratedFile,\n} from '../generate-text/generated-file';\n\n/**\n * A generated audio file.\n */\nexport interface GeneratedAudioFile extends GeneratedFile {\n  /**\n   * Audio format of the file (e.g., 'mp3', 'wav', etc.)\n   */\n  readonly format: string;\n}\n\nexport class DefaultGeneratedAudioFile\n  extends DefaultGeneratedFile\n  implements GeneratedAudioFile\n{\n  readonly format: string;\n\n  constructor({\n    data,\n    mimeType,\n  }: {\n    data: string | Uint8Array;\n    mimeType: string;\n  }) {\n    super({ data, mimeType });\n    let format = 'mp3';\n\n    // If format is not provided, try to determine it from the mimeType\n    if (mimeType) {\n      const mimeTypeParts = mimeType.split('/');\n\n      if (mimeTypeParts.length === 2) {\n        // Handle special cases for audio formats\n        if (mimeType !== 'audio/mpeg') {\n          format = mimeTypeParts[1];\n        }\n      }\n    }\n\n    if (!format) {\n      throw new Error(\n        'Audio format must be provided or determinable from mimeType',\n      );\n    }\n\n    this.format = format;\n  }\n}\n\nexport class DefaultGeneratedAudioFileWithType extends DefaultGeneratedAudioFile {\n  readonly type = 'audio';\n\n  constructor(options: {\n    data: string | Uint8Array;\n    mimeType: string;\n    format: string;\n  }) {\n    super(options);\n  }\n}\n", "import { JSONValue, SpeechModelV1 } from '@ai-sdk/provider';\nimport { NoSpeechGeneratedError } from '../../errors/no-speech-generated-error';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { ProviderOptions } from '../types/provider-metadata';\nimport { SpeechWarning } from '../types/speech-model';\nimport { SpeechModelResponseMetadata } from '../types/speech-model-response-metadata';\nimport { SpeechResult } from './generate-speech-result';\nimport {\n  audioMimeTypeSignatures,\n  detectMimeType,\n} from '../util/detect-mimetype';\nimport {\n  DefaultGeneratedAudioFile,\n  GeneratedAudioFile,\n} from './generated-audio-file';\n\n/**\nGenerates speech audio using a speech model.\n\n@param model - The speech model to use.\n@param text - The text to convert to speech.\n@param voice - The voice to use for speech generation.\n@param outputFormat - The output format to use for speech generation e.g. \"mp3\", \"wav\", etc.\n@param instructions - Instructions for the speech generation e.g. \"Speak in a slow and steady tone\".\n@param speed - The speed of the speech generation.\n@param providerOptions - Additional provider-specific options that are passed through to the provider\nas body parameters.\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the generated audio data.\n */\nexport async function generateSpeech({\n  model,\n  text,\n  voice,\n  outputFormat,\n  instructions,\n  speed,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n}: {\n  /**\nThe speech model to use.\n     */\n  model: SpeechModelV1;\n\n  /**\nThe text to convert to speech.\n   */\n  text: string;\n\n  /**\nThe voice to use for speech generation.\n   */\n  voice?: string;\n\n  /**\n   * The desired output format for the audio e.g. \"mp3\", \"wav\", etc.\n   */\n  outputFormat?: 'mp3' | 'wav' | (string & {});\n\n  /**\n    Instructions for the speech generation e.g. \"Speak in a slow and steady tone\".\n  */\n  instructions?: string;\n\n  /**\n  The speed of the speech generation.\n   */\n  speed?: number;\n\n  /**\nAdditional provider-specific options that are passed through to the provider\nas body parameters.\n\nThe outer record is keyed by the provider name, and the inner\nrecord is keyed by the provider-specific metadata key.\n```ts\n{\n  \"openai\": {}\n}\n```\n     */\n  providerOptions?: ProviderOptions;\n\n  /**\nMaximum number of retries per speech model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n}): Promise<SpeechResult> {\n  const { retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const result = await retry(() =>\n    model.doGenerate({\n      text,\n      voice,\n      outputFormat,\n      instructions,\n      speed,\n      abortSignal,\n      headers,\n      providerOptions,\n    }),\n  );\n\n  if (!result.audio || result.audio.length === 0) {\n    throw new NoSpeechGeneratedError({ responses: [result.response] });\n  }\n\n  return new DefaultSpeechResult({\n    audio: new DefaultGeneratedAudioFile({\n      data: result.audio,\n      mimeType:\n        detectMimeType({\n          data: result.audio,\n          signatures: audioMimeTypeSignatures,\n        }) ?? 'audio/mp3',\n    }),\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata,\n  });\n}\n\nclass DefaultSpeechResult implements SpeechResult {\n  readonly audio: GeneratedAudioFile;\n  readonly warnings: Array<SpeechWarning>;\n  readonly responses: Array<SpeechModelResponseMetadata>;\n  readonly providerMetadata: Record<string, Record<string, JSONValue>>;\n\n  constructor(options: {\n    audio: GeneratedAudioFile;\n    warnings: Array<SpeechWarning>;\n    responses: Array<SpeechModelResponseMetadata>;\n    providerMetadata: Record<string, Record<string, JSONValue>> | undefined;\n  }) {\n    this.audio = options.audio;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = options.providerMetadata ?? {};\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\nimport { TranscriptionModelResponseMetadata } from '../core/types/transcription-model-response-metadata';\n\n/**\nError that is thrown when no transcript was generated.\n */\nexport class NoTranscriptGeneratedError extends AISDKError {\n  readonly responses: Array<TranscriptionModelResponseMetadata>;\n\n  constructor(options: {\n    responses: Array<TranscriptionModelResponseMetadata>;\n  }) {\n    super({\n      name: 'AI_NoTranscriptGeneratedError',\n      message: 'No transcript generated.',\n    });\n\n    this.responses = options.responses;\n  }\n}\n", "import { JSONValue, TranscriptionModelV1 } from '@ai-sdk/provider';\nimport { NoTranscriptGeneratedError } from '../../errors/no-transcript-generated-error';\nimport { download } from '../../util/download';\nimport { DataContent } from '../prompt';\nimport { convertDataContentToUint8Array } from '../prompt/data-content';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { ProviderOptions } from '../types/provider-metadata';\nimport { TranscriptionWarning } from '../types/transcription-model';\nimport { TranscriptionModelResponseMetadata } from '../types/transcription-model-response-metadata';\nimport {\n  audioMimeTypeSignatures,\n  detectMimeType,\n} from '../util/detect-mimetype';\nimport { TranscriptionResult } from './transcribe-result';\n\n/**\nGenerates transcripts using a transcription model.\n\n@param model - The transcription model to use.\n@param audio - The audio data to transcribe as DataContent (string | Uint8Array | ArrayBuffer | Buffer) or a URL.\n@param providerOptions - Additional provider-specific options that are passed through to the provider\nas body parameters.\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the generated transcript.\n */\nexport async function transcribe({\n  model,\n  audio,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n}: {\n  /**\nThe transcription model to use.\n     */\n  model: TranscriptionModelV1;\n\n  /**\nThe audio data to transcribe.\n   */\n  audio: DataContent | URL;\n\n  /**\nAdditional provider-specific options that are passed through to the provider\nas body parameters.\n\nThe outer record is keyed by the provider name, and the inner\nrecord is keyed by the provider-specific metadata key.\n```ts\n{\n  \"openai\": {\n    \"temperature\": 0\n  }\n}\n```\n     */\n  providerOptions?: ProviderOptions;\n\n  /**\nMaximum number of retries per transcript model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n}): Promise<TranscriptionResult> {\n  const { retry } = prepareRetries({ maxRetries: maxRetriesArg });\n  const audioData =\n    audio instanceof URL\n      ? (await download({ url: audio })).data\n      : convertDataContentToUint8Array(audio);\n\n  const result = await retry(() =>\n    model.doGenerate({\n      audio: audioData,\n      abortSignal,\n      headers,\n      providerOptions,\n      mediaType:\n        detectMimeType({\n          data: audioData,\n          signatures: audioMimeTypeSignatures,\n        }) ?? 'audio/wav',\n    }),\n  );\n\n  if (!result.text) {\n    throw new NoTranscriptGeneratedError({ responses: [result.response] });\n  }\n\n  return new DefaultTranscriptionResult({\n    text: result.text,\n    segments: result.segments,\n    language: result.language,\n    durationInSeconds: result.durationInSeconds,\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata,\n  });\n}\n\nclass DefaultTranscriptionResult implements TranscriptionResult {\n  readonly text: string;\n  readonly segments: Array<{\n    text: string;\n    startSecond: number;\n    endSecond: number;\n  }>;\n  readonly language: string | undefined;\n  readonly durationInSeconds: number | undefined;\n  readonly warnings: Array<TranscriptionWarning>;\n  readonly responses: Array<TranscriptionModelResponseMetadata>;\n  readonly providerMetadata: Record<string, Record<string, JSONValue>>;\n\n  constructor(options: {\n    text: string;\n    segments: Array<{\n      text: string;\n      startSecond: number;\n      endSecond: number;\n    }>;\n    language: string | undefined;\n    durationInSeconds: number | undefined;\n    warnings: Array<TranscriptionWarning>;\n    responses: Array<TranscriptionModelResponseMetadata>;\n    providerMetadata: Record<string, Record<string, JSONValue>> | undefined;\n  }) {\n    this.text = options.text;\n    this.segments = options.segments;\n    this.language = options.language;\n    this.durationInSeconds = options.durationInSeconds;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = options.providerMetadata ?? {};\n  }\n}\n", "/**\n * Deeply merges two objects together.\n * - Properties from the second object override those in the first object with the same key\n * - For nested objects, the merge is performed recursively (deep merge)\n * - Arrays are replaced, not merged\n * - Primitive values are replaced\n * - If both inputs are undefined, returns undefined\n * - If one input is undefined, returns the other\n *\n * @param target The target object to merge into\n * @param source The source object to merge from\n * @returns A new object with the merged properties, or undefined if both inputs are undefined\n */\nexport function mergeObjects<T extends object, U extends object>(\n  target: T | undefined,\n  source: U | undefined,\n): (T & U) | T | U | undefined {\n  // If both inputs are undefined, return undefined\n  if (target === undefined && source === undefined) {\n    return undefined;\n  }\n\n  // If target is undefined, return source\n  if (target === undefined) {\n    return source;\n  }\n\n  // If source is undefined, return target\n  if (source === undefined) {\n    return target;\n  }\n\n  // Create a new object to avoid mutating the inputs\n  const result = { ...target } as T & U;\n\n  // Iterate through all keys in the source object\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      const sourceValue = source[key];\n\n      // Skip if the source value is undefined\n      if (sourceValue === undefined) continue;\n\n      // Get the target value if it exists\n      const targetValue =\n        key in target ? target[key as unknown as keyof T] : undefined;\n\n      // Check if both values are objects that can be deeply merged\n      const isSourceObject =\n        sourceValue !== null &&\n        typeof sourceValue === 'object' &&\n        !Array.isArray(sourceValue) &&\n        !(sourceValue instanceof Date) &&\n        !(sourceValue instanceof RegExp);\n\n      const isTargetObject =\n        targetValue !== null &&\n        targetValue !== undefined &&\n        typeof targetValue === 'object' &&\n        !Array.isArray(targetValue) &&\n        !(targetValue instanceof Date) &&\n        !(targetValue instanceof RegExp);\n\n      // If both values are mergeable objects, merge them recursively\n      if (isSourceObject && isTargetObject) {\n        result[key as keyof (T & U)] = mergeObjects(\n          targetValue as object,\n          sourceValue as object,\n        ) as any;\n      } else {\n        // For primitives, arrays, or when one value is not a mergeable object,\n        // simply override with the source value\n        result[key as keyof (T & U)] = sourceValue as any;\n      }\n    }\n  }\n\n  return result;\n}\n", "import {\n  LanguageModelV1CallOptions,\n  LanguageModelV1ProviderMetadata,\n} from '@ai-sdk/provider';\nimport type { LanguageModelV1Middleware } from './language-model-v1-middleware';\nimport { mergeObjects } from '../util/merge-objects';\n\n/**\n * Applies default settings for a language model.\n */\nexport function defaultSettingsMiddleware({\n  settings,\n}: {\n  settings: Partial<\n    LanguageModelV1CallOptions & {\n      providerMetadata?: LanguageModelV1ProviderMetadata;\n    }\n  >;\n}): LanguageModelV1Middleware {\n  return {\n    middlewareVersion: 'v1',\n    transformParams: async ({ params }) => {\n      return {\n        ...settings,\n        ...params,\n        providerMetadata: mergeObjects(\n          settings.providerMetadata,\n          params.providerMetadata,\n        ),\n\n        // special case for temperature 0\n        // TODO remove when temperature defaults to undefined\n        temperature:\n          params.temperature === 0 || params.temperature == null\n            ? (settings.temperature ?? 0)\n            : params.temperature,\n      };\n    },\n  };\n}\n", "/**\n * Returns the index of the start of the searchedText in the text, or null if it\n * is not found.\n */\nexport function getPotentialStartIndex(\n  text: string,\n  searchedText: string,\n): number | null {\n  // Return null immediately if searchedText is empty.\n  if (searchedText.length === 0) {\n    return null;\n  }\n\n  // Check if the searchedText exists as a direct substring of text.\n  const directIndex = text.indexOf(searchedText);\n  if (directIndex !== -1) {\n    return directIndex;\n  }\n\n  // Otherwise, look for the largest suffix of \"text\" that matches\n  // a prefix of \"searchedText\". We go from the end of text inward.\n  for (let i = text.length - 1; i >= 0; i--) {\n    const suffix = text.substring(i);\n    if (searchedText.startsWith(suffix)) {\n      return i;\n    }\n  }\n\n  return null;\n}\n", "import type { LanguageModelV1StreamPart } from '@ai-sdk/provider';\nimport { getPotentialStartIndex } from '../util/get-potential-start-index';\nimport type { LanguageModelV1Middleware } from './language-model-v1-middleware';\n\n/**\n * Extract an XML-tagged reasoning section from the generated text and exposes it\n * as a `reasoning` property on the result.\n *\n * @param tagName - The name of the XML tag to extract reasoning from.\n * @param separator - The separator to use between reasoning and text sections.\n * @param startWithReasoning - Whether to start with reasoning tokens.\n */\nexport function extractReasoningMiddleware({\n  tagName,\n  separator = '\\n',\n  startWithReasoning = false,\n}: {\n  tagName: string;\n  separator?: string;\n  startWithReasoning?: boolean;\n}): LanguageModelV1Middleware {\n  const openingTag = `<${tagName}>`;\n  const closingTag = `<\\/${tagName}>`;\n\n  return {\n    middlewareVersion: 'v1',\n    wrapGenerate: async ({ doGenerate }) => {\n      const { text: rawText, ...rest } = await doGenerate();\n\n      if (rawText == null) {\n        return { text: rawText, ...rest };\n      }\n\n      const text = startWithReasoning ? openingTag + rawText : rawText;\n\n      const regexp = new RegExp(`${openingTag}(.*?)${closingTag}`, 'gs');\n      const matches = Array.from(text.matchAll(regexp));\n\n      if (!matches.length) {\n        return { text, ...rest };\n      }\n\n      const reasoning = matches.map(match => match[1]).join(separator);\n\n      let textWithoutReasoning = text;\n      for (let i = matches.length - 1; i >= 0; i--) {\n        const match = matches[i];\n\n        const beforeMatch = textWithoutReasoning.slice(0, match.index);\n        const afterMatch = textWithoutReasoning.slice(\n          match.index! + match[0].length,\n        );\n\n        textWithoutReasoning =\n          beforeMatch +\n          (beforeMatch.length > 0 && afterMatch.length > 0 ? separator : '') +\n          afterMatch;\n      }\n\n      return { ...rest, text: textWithoutReasoning, reasoning };\n    },\n\n    wrapStream: async ({ doStream }) => {\n      const { stream, ...rest } = await doStream();\n\n      let isFirstReasoning = true;\n      let isFirstText = true;\n      let afterSwitch = false;\n      let isReasoning = startWithReasoning;\n      let buffer = '';\n\n      return {\n        stream: stream.pipeThrough(\n          new TransformStream<\n            LanguageModelV1StreamPart,\n            LanguageModelV1StreamPart\n          >({\n            transform: (chunk, controller) => {\n              if (chunk.type !== 'text-delta') {\n                controller.enqueue(chunk);\n                return;\n              }\n\n              buffer += chunk.textDelta;\n\n              function publish(text: string) {\n                if (text.length > 0) {\n                  const prefix =\n                    afterSwitch &&\n                    (isReasoning ? !isFirstReasoning : !isFirstText)\n                      ? separator\n                      : '';\n\n                  controller.enqueue({\n                    type: isReasoning ? 'reasoning' : 'text-delta',\n                    textDelta: prefix + text,\n                  });\n                  afterSwitch = false;\n\n                  if (isReasoning) {\n                    isFirstReasoning = false;\n                  } else {\n                    isFirstText = false;\n                  }\n                }\n              }\n\n              do {\n                const nextTag = isReasoning ? closingTag : openingTag;\n                const startIndex = getPotentialStartIndex(buffer, nextTag);\n\n                // no opening or closing tag found, publish the buffer\n                if (startIndex == null) {\n                  publish(buffer);\n                  buffer = '';\n                  break;\n                }\n\n                // publish text before the tag\n                publish(buffer.slice(0, startIndex));\n\n                const foundFullMatch =\n                  startIndex + nextTag.length <= buffer.length;\n\n                if (foundFullMatch) {\n                  buffer = buffer.slice(startIndex + nextTag.length);\n                  isReasoning = !isReasoning;\n                  afterSwitch = true;\n                } else {\n                  buffer = buffer.slice(startIndex);\n                  break;\n                }\n              } while (true);\n            },\n          }),\n        ),\n        ...rest,\n      };\n    },\n  };\n}\n", "import type { LanguageModelV1StreamPart } from '@ai-sdk/provider';\nimport type { LanguageModelV1Middleware } from './language-model-v1-middleware';\n\n/**\n * Simulates streaming chunks with the response from a generate call.\n */\nexport function simulateStreamingMiddleware(): LanguageModelV1Middleware {\n  return {\n    middlewareVersion: 'v1',\n    wrapStream: async ({ doGenerate }) => {\n      const result = await doGenerate();\n\n      const simulatedStream = new ReadableStream<LanguageModelV1StreamPart>({\n        start(controller) {\n          controller.enqueue({ type: 'response-metadata', ...result.response });\n\n          if (result.reasoning) {\n            if (typeof result.reasoning === 'string') {\n              controller.enqueue({\n                type: 'reasoning',\n                textDelta: result.reasoning,\n              });\n            } else {\n              for (const reasoning of result.reasoning) {\n                switch (reasoning.type) {\n                  case 'text': {\n                    controller.enqueue({\n                      type: 'reasoning',\n                      textDelta: reasoning.text,\n                    });\n                    if (reasoning.signature != null) {\n                      controller.enqueue({\n                        type: 'reasoning-signature',\n                        signature: reasoning.signature,\n                      });\n                    }\n                    break;\n                  }\n                  case 'redacted': {\n                    controller.enqueue({\n                      type: 'redacted-reasoning',\n                      data: reasoning.data,\n                    });\n                    break;\n                  }\n                }\n              }\n            }\n          }\n\n          if (result.text) {\n            controller.enqueue({\n              type: 'text-delta',\n              textDelta: result.text,\n            });\n          }\n\n          if (result.toolCalls) {\n            for (const toolCall of result.toolCalls) {\n              controller.enqueue({\n                type: 'tool-call-delta',\n                toolCallType: 'function',\n                toolCallId: toolCall.toolCallId,\n                toolName: toolCall.toolName,\n                argsTextDelta: toolCall.args,\n              });\n\n              controller.enqueue({\n                type: 'tool-call',\n                ...toolCall,\n              });\n            }\n          }\n\n          controller.enqueue({\n            type: 'finish',\n            finishReason: result.finishReason,\n            usage: result.usage,\n            logprobs: result.logprobs,\n            providerMetadata: result.providerMetadata,\n          });\n\n          controller.close();\n        },\n      });\n\n      return {\n        stream: simulatedStream,\n        rawCall: result.rawCall,\n        rawResponse: result.rawResponse,\n        warnings: result.warnings,\n      };\n    },\n  };\n}\n", "import { LanguageModelV1, LanguageModelV1CallOptions } from '@ai-sdk/provider';\nimport { LanguageModelV1Middleware } from './language-model-v1-middleware';\nimport { asArray } from '../../util/as-array';\n\n/**\n * Wraps a LanguageModelV1 instance with middleware functionality.\n * This function allows you to apply middleware to transform parameters,\n * wrap generate operations, and wrap stream operations of a language model.\n *\n * @param options - Configuration options for wrapping the language model.\n * @param options.model - The original LanguageModelV1 instance to be wrapped.\n * @param options.middleware - The middleware to be applied to the language model. When multiple middlewares are provided, the first middleware will transform the input first, and the last middleware will be wrapped directly around the model.\n * @param options.modelId - Optional custom model ID to override the original model's ID.\n * @param options.providerId - Optional custom provider ID to override the original model's provider.\n * @returns A new LanguageModelV1 instance with middleware applied.\n */\nexport const wrapLanguageModel = ({\n  model,\n  middleware: middlewareArg,\n  modelId,\n  providerId,\n}: {\n  model: LanguageModelV1;\n  middleware: LanguageModelV1Middleware | LanguageModelV1Middleware[];\n  modelId?: string;\n  providerId?: string;\n}): LanguageModelV1 => {\n  return asArray(middlewareArg)\n    .reverse()\n    .reduce((wrappedModel, middleware) => {\n      return doWrap({ model: wrappedModel, middleware, modelId, providerId });\n    }, model);\n};\n\nconst doWrap = ({\n  model,\n  middleware: { transformParams, wrapGenerate, wrapStream },\n  modelId,\n  providerId,\n}: {\n  model: LanguageModelV1;\n  middleware: LanguageModelV1Middleware;\n  modelId?: string;\n  providerId?: string;\n}): LanguageModelV1 => {\n  async function doTransform({\n    params,\n    type,\n  }: {\n    params: LanguageModelV1CallOptions;\n    type: 'generate' | 'stream';\n  }) {\n    return transformParams ? await transformParams({ params, type }) : params;\n  }\n\n  return {\n    specificationVersion: 'v1',\n\n    provider: providerId ?? model.provider,\n    modelId: modelId ?? model.modelId,\n\n    defaultObjectGenerationMode: model.defaultObjectGenerationMode,\n    supportsImageUrls: model.supportsImageUrls,\n    supportsUrl: model.supportsUrl?.bind(model),\n    supportsStructuredOutputs: model.supportsStructuredOutputs,\n\n    async doGenerate(\n      params: LanguageModelV1CallOptions,\n    ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n      const transformedParams = await doTransform({ params, type: 'generate' });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapGenerate\n        ? wrapGenerate({\n            doGenerate,\n            doStream,\n            params: transformedParams,\n            model,\n          })\n        : doGenerate();\n    },\n\n    async doStream(\n      params: LanguageModelV1CallOptions,\n    ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n      const transformedParams = await doTransform({ params, type: 'stream' });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapStream\n        ? wrapStream({ doGenerate, doStream, params: transformedParams, model })\n        : doStream();\n    },\n  };\n};\n\n/**\n * @deprecated Use `wrapLanguageModel` instead.\n */\n// TODO remove in v5\nexport const experimental_wrapLanguageModel = wrapLanguageModel;\n", "import { Message } from '@ai-sdk/ui-utils';\n\n/**\n * Appends a client message to the messages array.\n * If the last message in the array has the same id as the new message, it will be replaced.\n * Otherwise, the new message will be appended.\n */\nexport function appendClientMessage({\n  messages,\n  message,\n}: {\n  messages: Message[];\n  message: Message;\n}) {\n  return [\n    ...(messages.length > 0 && messages[messages.length - 1].id === message.id\n      ? messages.slice(0, -1)\n      : messages),\n    message,\n  ];\n}\n", "import {\n  extractMaxToolInvocationStep,\n  FileUIPart,\n  Message,\n  ReasoningUIPart,\n  StepStartUIPart,\n  TextUIPart,\n  ToolInvocation,\n  ToolInvocationUIPart,\n} from '@ai-sdk/ui-utils';\nimport { ResponseMessage } from '../generate-text/step-result';\nimport { convertDataContentToBase64String } from './data-content';\nimport { AISDKError } from '@ai-sdk/provider';\n\n/**\n * Appends the ResponseMessage[] from the response to a Message[] (for useChat).\n * The messages are converted to Messages before being appended.\n * Timestamps are generated for the new messages.\n *\n * @returns A new Message[] with the response messages appended.\n */\nexport function appendResponseMessages({\n  messages,\n  responseMessages,\n  _internal: { currentDate = () => new Date() } = {},\n}: {\n  messages: Message[];\n  responseMessages: ResponseMessage[];\n\n  /**\nInternal. For test use only. May change without notice.\n     */\n  _internal?: {\n    currentDate?: () => Date;\n  };\n}): Message[] {\n  const clonedMessages = structuredClone(messages);\n\n  for (const message of responseMessages) {\n    const role = message.role;\n\n    // check if the last message is an assistant message:\n    const lastMessage = clonedMessages[clonedMessages.length - 1];\n    const isLastMessageAssistant = lastMessage.role === 'assistant';\n\n    switch (role) {\n      case 'assistant': {\n        function getToolInvocations(step: number) {\n          return (\n            typeof message.content === 'string'\n              ? []\n              : message.content.filter(part => part.type === 'tool-call')\n          ).map(call => ({\n            state: 'call' as const,\n            step,\n            args: call.args,\n            toolCallId: call.toolCallId,\n            toolName: call.toolName,\n          }));\n        }\n\n        const parts: Array<\n          | TextUIPart\n          | ReasoningUIPart\n          | ToolInvocationUIPart\n          | FileUIPart\n          | StepStartUIPart\n        > = [{ type: 'step-start' as const }]; // always start with a step-start part\n        let textContent = '';\n        let reasoningTextContent = undefined;\n\n        if (typeof message.content === 'string') {\n          textContent = message.content;\n          parts.push({\n            type: 'text' as const,\n            text: message.content,\n          });\n        } else {\n          let reasoningPart: ReasoningUIPart | undefined = undefined;\n          for (const part of message.content) {\n            switch (part.type) {\n              case 'text': {\n                reasoningPart = undefined; // reset the reasoning part\n\n                textContent += part.text;\n                parts.push({\n                  type: 'text' as const,\n                  text: part.text,\n                });\n                break;\n              }\n              case 'reasoning': {\n                if (reasoningPart == null) {\n                  reasoningPart = {\n                    type: 'reasoning' as const,\n                    reasoning: '',\n                    details: [],\n                  };\n                  parts.push(reasoningPart);\n                }\n\n                reasoningTextContent = (reasoningTextContent ?? '') + part.text;\n                reasoningPart.reasoning += part.text;\n                reasoningPart.details.push({\n                  type: 'text' as const,\n                  text: part.text,\n                  signature: part.signature,\n                });\n                break;\n              }\n              case 'redacted-reasoning': {\n                if (reasoningPart == null) {\n                  reasoningPart = {\n                    type: 'reasoning' as const,\n                    reasoning: '',\n                    details: [],\n                  };\n                  parts.push(reasoningPart);\n                }\n\n                reasoningPart.details.push({\n                  type: 'redacted' as const,\n                  data: part.data,\n                });\n                break;\n              }\n              case 'tool-call':\n                break;\n              case 'file':\n                if (part.data instanceof URL) {\n                  throw new AISDKError({\n                    name: 'InvalidAssistantFileData',\n                    message: 'File data cannot be a URL',\n                  });\n                }\n                parts.push({\n                  type: 'file' as const,\n                  mimeType: part.mimeType,\n                  data: convertDataContentToBase64String(part.data),\n                });\n                break;\n            }\n          }\n        }\n\n        if (isLastMessageAssistant) {\n          const maxStep = extractMaxToolInvocationStep(\n            lastMessage.toolInvocations,\n          );\n\n          lastMessage.parts ??= [];\n\n          lastMessage.content = textContent;\n          lastMessage.reasoning = reasoningTextContent;\n          lastMessage.parts.push(...parts);\n\n          lastMessage.toolInvocations = [\n            ...(lastMessage.toolInvocations ?? []),\n            ...getToolInvocations(maxStep === undefined ? 0 : maxStep + 1),\n          ];\n\n          getToolInvocations(maxStep === undefined ? 0 : maxStep + 1)\n            .map(call => ({\n              type: 'tool-invocation' as const,\n              toolInvocation: call,\n            }))\n            .forEach(part => {\n              lastMessage.parts!.push(part);\n            });\n        } else {\n          // last message was a user message, add the assistant message:\n          clonedMessages.push({\n            role: 'assistant',\n            id: message.id,\n            createdAt: currentDate(), // generate a createdAt date for the message, will be overridden by the client\n            content: textContent,\n            reasoning: reasoningTextContent,\n            toolInvocations: getToolInvocations(0),\n            parts: [\n              ...parts,\n              ...getToolInvocations(0).map(call => ({\n                type: 'tool-invocation' as const,\n                toolInvocation: call,\n              })),\n            ],\n          });\n        }\n\n        break;\n      }\n\n      case 'tool': {\n        // for tool call results, add the result to previous message:\n        lastMessage.toolInvocations ??= []; // ensure the toolInvocations array exists\n\n        if (lastMessage.role !== 'assistant') {\n          throw new Error(\n            `Tool result must follow an assistant message: ${lastMessage.role}`,\n          );\n        }\n\n        lastMessage.parts ??= [];\n\n        for (const contentPart of message.content) {\n          // find the tool call in the previous message:\n          const toolCall = lastMessage.toolInvocations.find(\n            call => call.toolCallId === contentPart.toolCallId,\n          );\n          const toolCallPart: ToolInvocationUIPart | undefined =\n            lastMessage.parts.find(\n              (part): part is ToolInvocationUIPart =>\n                part.type === 'tool-invocation' &&\n                part.toolInvocation.toolCallId === contentPart.toolCallId,\n            );\n\n          if (!toolCall) {\n            throw new Error('Tool call not found in previous message');\n          }\n\n          // add the result to the tool call:\n          toolCall.state = 'result';\n          const toolResult = toolCall as ToolInvocation & { state: 'result' };\n          toolResult.result = contentPart.result;\n\n          if (toolCallPart) {\n            toolCallPart.toolInvocation = toolResult;\n          } else {\n            lastMessage.parts.push({\n              type: 'tool-invocation' as const,\n              toolInvocation: toolResult,\n            });\n          }\n        }\n\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported message role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return clonedMessages;\n}\n", "import { NoSuchModelError, ProviderV1 } from '@ai-sdk/provider';\nimport { EmbeddingModel, ImageModel, LanguageModel, Provider } from '../types';\n\n/**\n * Creates a custom provider with specified language models, text embedding models, and an optional fallback provider.\n *\n * @param {Object} options - The options for creating the custom provider.\n * @param {Record<string, LanguageModel>} [options.languageModels] - A record of language models, where keys are model IDs and values are LanguageModel instances.\n * @param {Record<string, EmbeddingModel<string>>} [options.textEmbeddingModels] - A record of text embedding models, where keys are model IDs and values are EmbeddingModel<string> instances.\n * @param {Record<string, ImageModel>} [options.imageModels] - A record of image models, where keys are model IDs and values are ImageModel instances.\n * @param {Provider} [options.fallbackProvider] - An optional fallback provider to use when a requested model is not found in the custom provider.\n * @returns {Provider} A Provider object with languageModel, textEmbeddingModel, and imageModel methods.\n *\n * @throws {NoSuchModelError} Throws when a requested model is not found and no fallback provider is available.\n */\nexport function customProvider<\n  LANGUAGE_MODELS extends Record<string, LanguageModel>,\n  EMBEDDING_MODELS extends Record<string, EmbeddingModel<string>>,\n  IMAGE_MODELS extends Record<string, ImageModel>,\n>({\n  languageModels,\n  textEmbeddingModels,\n  imageModels,\n  fallbackProvider,\n}: {\n  languageModels?: LANGUAGE_MODELS;\n  textEmbeddingModels?: EMBEDDING_MODELS;\n  imageModels?: IMAGE_MODELS;\n  fallbackProvider?: ProviderV1;\n}): Provider & {\n  languageModel(modelId: ExtractModelId<LANGUAGE_MODELS>): LanguageModel;\n  textEmbeddingModel(\n    modelId: ExtractModelId<EMBEDDING_MODELS>,\n  ): EmbeddingModel<string>;\n  imageModel(modelId: ExtractModelId<IMAGE_MODELS>): ImageModel;\n} {\n  return {\n    languageModel(modelId: ExtractModelId<LANGUAGE_MODELS>): LanguageModel {\n      if (languageModels != null && modelId in languageModels) {\n        return languageModels[modelId];\n      }\n\n      if (fallbackProvider) {\n        return fallbackProvider.languageModel(modelId);\n      }\n\n      throw new NoSuchModelError({ modelId, modelType: 'languageModel' });\n    },\n\n    textEmbeddingModel(\n      modelId: ExtractModelId<EMBEDDING_MODELS>,\n    ): EmbeddingModel<string> {\n      if (textEmbeddingModels != null && modelId in textEmbeddingModels) {\n        return textEmbeddingModels[modelId];\n      }\n\n      if (fallbackProvider) {\n        return fallbackProvider.textEmbeddingModel(modelId);\n      }\n\n      throw new NoSuchModelError({ modelId, modelType: 'textEmbeddingModel' });\n    },\n\n    imageModel(modelId: ExtractModelId<IMAGE_MODELS>): ImageModel {\n      if (imageModels != null && modelId in imageModels) {\n        return imageModels[modelId];\n      }\n\n      if (fallbackProvider?.imageModel) {\n        return fallbackProvider.imageModel(modelId);\n      }\n\n      throw new NoSuchModelError({ modelId, modelType: 'imageModel' });\n    },\n  };\n}\n\n/**\n * @deprecated Use `customProvider` instead.\n */\nexport const experimental_customProvider = customProvider;\n\ntype ExtractModelId<MODELS extends Record<string, unknown>> = Extract<\n  keyof MODELS,\n  string\n>;\n", "import { AISDKError, NoSuchModelError } from '@ai-sdk/provider';\n\nconst name = 'AI_NoSuchProviderError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchProviderError extends NoSuchModelError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly providerId: string;\n  readonly availableProviders: string[];\n\n  constructor({\n    modelId,\n    modelType,\n    providerId,\n    availableProviders,\n    message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})`,\n  }: {\n    modelId: string;\n    modelType: 'languageModel' | 'textEmbeddingModel';\n    providerId: string;\n    availableProviders: string[];\n    message?: string;\n  }) {\n    super({ errorName: name, modelId, modelType, message });\n\n    this.providerId = providerId;\n    this.availableProviders = availableProviders;\n  }\n\n  static isInstance(error: unknown): error is NoSuchProviderError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { NoSuchModelError, ProviderV1 } from '@ai-sdk/provider';\nimport { EmbeddingModel, ImageModel, LanguageModel } from '../types';\nimport { NoSuchProviderError } from './no-such-provider-error';\n\ntype ExtractLiteralUnion<T> = T extends string\n  ? string extends T\n    ? never\n    : T\n  : never;\n\nexport interface ProviderRegistryProvider<\n  PROVIDERS extends Record<string, ProviderV1> = Record<string, ProviderV1>,\n  SEPARATOR extends string = ':',\n> {\n  languageModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string\n      ? `${KEY & string}${SEPARATOR}${ExtractLiteralUnion<Parameters<NonNullable<PROVIDERS[KEY]['languageModel']>>[0]>}`\n      : never,\n  ): LanguageModel;\n  languageModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string ? `${KEY & string}${SEPARATOR}${string}` : never,\n  ): LanguageModel;\n\n  textEmbeddingModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string\n      ? `${KEY & string}${SEPARATOR}${ExtractLiteralUnion<Parameters<NonNullable<PROVIDERS[KEY]['textEmbeddingModel']>>[0]>}`\n      : never,\n  ): EmbeddingModel<string>;\n  textEmbeddingModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string ? `${KEY & string}${SEPARATOR}${string}` : never,\n  ): EmbeddingModel<string>;\n\n  imageModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string\n      ? `${KEY & string}${SEPARATOR}${ExtractLiteralUnion<Parameters<NonNullable<PROVIDERS[KEY]['imageModel']>>[0]>}`\n      : never,\n  ): ImageModel;\n  imageModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string ? `${KEY & string}${SEPARATOR}${string}` : never,\n  ): ImageModel;\n}\n\n/**\n * Creates a registry for the given providers.\n */\nexport function createProviderRegistry<\n  PROVIDERS extends Record<string, ProviderV1>,\n  SEPARATOR extends string = ':',\n>(\n  providers: PROVIDERS,\n  {\n    separator = ':' as SEPARATOR,\n  }: {\n    separator?: SEPARATOR;\n  } = {},\n): ProviderRegistryProvider<PROVIDERS, SEPARATOR> {\n  const registry = new DefaultProviderRegistry<PROVIDERS, SEPARATOR>({\n    separator,\n  });\n\n  for (const [id, provider] of Object.entries(providers)) {\n    registry.registerProvider({ id, provider } as {\n      id: keyof PROVIDERS;\n      provider: PROVIDERS[keyof PROVIDERS];\n    });\n  }\n\n  return registry;\n}\n\n/**\n * @deprecated Use `createProviderRegistry` instead.\n */\nexport const experimental_createProviderRegistry = createProviderRegistry;\n\nclass DefaultProviderRegistry<\n  PROVIDERS extends Record<string, ProviderV1>,\n  SEPARATOR extends string,\n> implements ProviderRegistryProvider<PROVIDERS, SEPARATOR>\n{\n  private providers: PROVIDERS = {} as PROVIDERS;\n  private separator: SEPARATOR;\n\n  constructor({ separator }: { separator: SEPARATOR }) {\n    this.separator = separator;\n  }\n\n  registerProvider<K extends keyof PROVIDERS>({\n    id,\n    provider,\n  }: {\n    id: K;\n    provider: PROVIDERS[K];\n  }): void {\n    this.providers[id] = provider;\n  }\n\n  private getProvider(id: string): ProviderV1 {\n    const provider = this.providers[id as keyof PROVIDERS];\n\n    if (provider == null) {\n      throw new NoSuchProviderError({\n        modelId: id,\n        modelType: 'languageModel',\n        providerId: id,\n        availableProviders: Object.keys(this.providers),\n      });\n    }\n\n    return provider;\n  }\n\n  private splitId(\n    id: string,\n    modelType: 'languageModel' | 'textEmbeddingModel' | 'imageModel',\n  ): [string, string] {\n    const index = id.indexOf(this.separator);\n\n    if (index === -1) {\n      throw new NoSuchModelError({\n        modelId: id,\n        modelType,\n        message:\n          `Invalid ${modelType} id for registry: ${id} ` +\n          `(must be in the format \"providerId${this.separator}modelId\")`,\n      });\n    }\n\n    return [id.slice(0, index), id.slice(index + this.separator.length)];\n  }\n\n  languageModel<KEY extends keyof PROVIDERS>(\n    id: `${KEY & string}${SEPARATOR}${string}`,\n  ): LanguageModel {\n    const [providerId, modelId] = this.splitId(id, 'languageModel');\n    const model = this.getProvider(providerId).languageModel?.(modelId);\n\n    if (model == null) {\n      throw new NoSuchModelError({ modelId: id, modelType: 'languageModel' });\n    }\n\n    return model;\n  }\n\n  textEmbeddingModel<KEY extends keyof PROVIDERS>(\n    id: `${KEY & string}${SEPARATOR}${string}`,\n  ): EmbeddingModel<string> {\n    const [providerId, modelId] = this.splitId(id, 'textEmbeddingModel');\n    const provider = this.getProvider(providerId);\n\n    const model = provider.textEmbeddingModel?.(modelId);\n\n    if (model == null) {\n      throw new NoSuchModelError({\n        modelId: id,\n        modelType: 'textEmbeddingModel',\n      });\n    }\n\n    return model;\n  }\n\n  imageModel<KEY extends keyof PROVIDERS>(\n    id: `${KEY & string}${SEPARATOR}${string}`,\n  ): ImageModel {\n    const [providerId, modelId] = this.splitId(id, 'imageModel');\n    const provider = this.getProvider(providerId);\n\n    const model = provider.imageModel?.(modelId);\n\n    if (model == null) {\n      throw new NoSuchModelError({ modelId: id, modelType: 'imageModel' });\n    }\n\n    return model;\n  }\n}\n", "import { JSONSchema7 } from '@ai-sdk/provider';\nimport { jsonSchema } from '@ai-sdk/ui-utils';\nimport { z, ZodType } from 'zod';\nimport { MCPClientError } from '../../../errors';\nimport { inferParameters, tool, Tool, ToolExecutionOptions } from '../tool';\nimport {\n  JSONRPCError,\n  JSONRPCNotification,\n  JSONRPCRequest,\n  JSONRPCResponse,\n} from './json-rpc-message';\nimport {\n  createMcpTransport,\n  isCustomMcpTransport,\n  MCPTransport,\n  MCPTransportConfig,\n} from './mcp-transport';\nimport {\n  CallToolResult,\n  CallToolResultSchema,\n  Configuration as ClientConfiguration,\n  InitializeResultSchema,\n  LATEST_PROTOCOL_VERSION,\n  ListToolsResult,\n  ListToolsResultSchema,\n  McpToolSet,\n  Notification,\n  PaginatedRequest,\n  Request,\n  RequestOptions,\n  ServerCapabilities,\n  SUPPORTED_PROTOCOL_VERSIONS,\n  ToolSchemas,\n} from './types';\n\nconst CLIENT_VERSION = '1.0.0';\n\ninterface MCPClientConfig {\n  /** Transport configuration for connecting to the MCP server */\n  transport: MCPTransportConfig | MCPTransport;\n  /** Optional callback for uncaught errors */\n  onUncaughtError?: (error: unknown) => void;\n  /** Optional client name, defaults to 'ai-sdk-mcp-client' */\n  name?: string;\n}\n\nexport async function createMCPClient(\n  config: MCPClientConfig,\n): Promise<MCPClient> {\n  const client = new MCPClient(config);\n  await client.init();\n  return client;\n}\n\n/**\n * A lightweight MCP Client implementation\n *\n * The primary purpose of this client is tool conversion between MCP<>AI SDK\n * but can later be extended to support other MCP features\n *\n * Tool parameters are automatically inferred from the server's JSON schema\n * if not explicitly provided in the tools configuration\n *\n * This client is meant to be used to communicate with a single server. To communicate and fetch tools across multiple servers, it's recommended to create a new client instance per server.\n *\n * Not supported:\n * - Client options (e.g. sampling, roots) as they are not needed for tool conversion\n * - Accepting notifications\n * - Session management (when passing a sessionId to an instance of the Streamable HTTP transport)\n * - Resumable SSE streams\n */\nclass MCPClient {\n  private transport: MCPTransport;\n  private onUncaughtError?: (error: unknown) => void;\n  private clientInfo: ClientConfiguration;\n  private requestMessageId = 0;\n  private responseHandlers: Map<\n    number,\n    (response: JSONRPCResponse | Error) => void\n  > = new Map();\n  private serverCapabilities: ServerCapabilities = {};\n  private isClosed = true;\n\n  constructor({\n    transport: transportConfig,\n    name = 'ai-sdk-mcp-client',\n    onUncaughtError,\n  }: MCPClientConfig) {\n    this.onUncaughtError = onUncaughtError;\n\n    if (isCustomMcpTransport(transportConfig)) {\n      this.transport = transportConfig;\n    } else {\n      this.transport = createMcpTransport(transportConfig);\n    }\n\n    this.transport.onclose = () => this.onClose();\n    this.transport.onerror = (error: Error) => this.onError(error);\n    this.transport.onmessage = message => {\n      if ('method' in message) {\n        // This lightweight client implementation does not support\n        // receiving notifications or requests from server.\n        // If we get an unsupported message, we can safely ignore it and pass to the onError handler:\n        this.onError(\n          new MCPClientError({\n            message: 'Unsupported message type',\n          }),\n        );\n        return;\n      }\n\n      this.onResponse(message);\n    };\n\n    this.clientInfo = {\n      name,\n      version: CLIENT_VERSION,\n    };\n  }\n\n  async init(): Promise<this> {\n    try {\n      await this.transport.start();\n      this.isClosed = false;\n\n      const result = await this.request({\n        request: {\n          method: 'initialize',\n          params: {\n            protocolVersion: LATEST_PROTOCOL_VERSION,\n            capabilities: {},\n            clientInfo: this.clientInfo,\n          },\n        },\n        resultSchema: InitializeResultSchema,\n      });\n\n      if (result === undefined) {\n        throw new MCPClientError({\n          message: 'Server sent invalid initialize result',\n        });\n      }\n\n      if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {\n        throw new MCPClientError({\n          message: `Server's protocol version is not supported: ${result.protocolVersion}`,\n        });\n      }\n\n      this.serverCapabilities = result.capabilities;\n\n      // Complete initialization handshake:\n      await this.notification({\n        method: 'notifications/initialized',\n      });\n\n      return this;\n    } catch (error) {\n      await this.close();\n      throw error;\n    }\n  }\n\n  async close(): Promise<void> {\n    if (this.isClosed) return;\n    await this.transport?.close();\n    this.onClose();\n  }\n\n  private assertCapability(method: string): void {\n    switch (method) {\n      case 'initialize':\n        break;\n      case 'tools/list':\n      case 'tools/call':\n        if (!this.serverCapabilities.tools) {\n          throw new MCPClientError({\n            message: `Server does not support tools`,\n          });\n        }\n        break;\n      default:\n        throw new MCPClientError({\n          message: `Unsupported method: ${method}`,\n        });\n    }\n  }\n\n  private async request<T extends ZodType<object>>({\n    request,\n    resultSchema,\n    options,\n  }: {\n    request: Request;\n    resultSchema: T;\n    options?: RequestOptions;\n  }): Promise<z.infer<T>> {\n    return new Promise((resolve, reject) => {\n      if (this.isClosed) {\n        return reject(\n          new MCPClientError({\n            message: 'Attempted to send a request from a closed client',\n          }),\n        );\n      }\n\n      this.assertCapability(request.method);\n\n      const signal = options?.signal;\n      signal?.throwIfAborted();\n\n      const messageId = this.requestMessageId++;\n      const jsonrpcRequest: JSONRPCRequest = {\n        ...request,\n        jsonrpc: '2.0',\n        id: messageId,\n      };\n\n      const cleanup = () => {\n        this.responseHandlers.delete(messageId);\n      };\n\n      this.responseHandlers.set(messageId, response => {\n        if (signal?.aborted) {\n          return reject(\n            new MCPClientError({\n              message: 'Request was aborted',\n              cause: signal.reason,\n            }),\n          );\n        }\n\n        if (response instanceof Error) {\n          return reject(response);\n        }\n\n        try {\n          const result = resultSchema.parse(response.result);\n          resolve(result);\n        } catch (error) {\n          const parseError = new MCPClientError({\n            message: 'Failed to parse server response',\n            cause: error,\n          });\n          reject(parseError);\n        }\n      });\n\n      this.transport.send(jsonrpcRequest).catch(error => {\n        cleanup();\n        reject(error);\n      });\n    });\n  }\n\n  private async listTools({\n    params,\n    options,\n  }: {\n    params?: PaginatedRequest['params'];\n    options?: RequestOptions;\n  } = {}): Promise<ListToolsResult> {\n    try {\n      return this.request({\n        request: { method: 'tools/list', params },\n        resultSchema: ListToolsResultSchema,\n        options,\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private async callTool({\n    name,\n    args,\n    options,\n  }: {\n    name: string;\n    args: Record<string, unknown>;\n    options?: ToolExecutionOptions;\n  }): Promise<CallToolResult> {\n    try {\n      return this.request({\n        request: { method: 'tools/call', params: { name, arguments: args } },\n        resultSchema: CallToolResultSchema,\n        options: {\n          signal: options?.abortSignal,\n        },\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private async notification(notification: Notification): Promise<void> {\n    const jsonrpcNotification: JSONRPCNotification = {\n      ...notification,\n      jsonrpc: '2.0',\n    };\n    await this.transport.send(jsonrpcNotification);\n  }\n\n  /**\n   * Returns a set of AI SDK tools from the MCP server\n   * @returns A record of tool names to their implementations\n   */\n  async tools<TOOL_SCHEMAS extends ToolSchemas = 'automatic'>({\n    schemas = 'automatic',\n  }: {\n    schemas?: TOOL_SCHEMAS;\n  } = {}): Promise<McpToolSet<TOOL_SCHEMAS>> {\n    const tools: Record<string, Tool> = {};\n\n    try {\n      const listToolsResult = await this.listTools();\n\n      for (const { name, description, inputSchema } of listToolsResult.tools) {\n        if (schemas !== 'automatic' && !(name in schemas)) {\n          continue;\n        }\n\n        const parameters =\n          schemas === 'automatic'\n            ? jsonSchema({\n                ...inputSchema,\n                properties: inputSchema.properties ?? {},\n                additionalProperties: false,\n              } as JSONSchema7)\n            : schemas[name].parameters;\n\n        const self = this;\n        const toolWithExecute = tool({\n          description,\n          parameters,\n          execute: async (\n            args: inferParameters<typeof parameters>,\n            options: ToolExecutionOptions,\n          ): Promise<CallToolResult> => {\n            options?.abortSignal?.throwIfAborted();\n\n            return self.callTool({\n              name,\n              args,\n              options,\n            });\n          },\n        });\n\n        tools[name] = toolWithExecute;\n      }\n\n      return tools as McpToolSet<TOOL_SCHEMAS>;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private onClose(): void {\n    if (this.isClosed) return;\n\n    this.isClosed = true;\n    const error = new MCPClientError({\n      message: 'Connection closed',\n    });\n\n    for (const handler of this.responseHandlers.values()) {\n      handler(error);\n    }\n\n    this.responseHandlers.clear();\n  }\n\n  private onError(error: unknown): void {\n    if (this.onUncaughtError) {\n      this.onUncaughtError(error);\n    }\n  }\n\n  private onResponse(response: JSONRPCResponse | JSONRPCError): void {\n    const messageId = Number(response.id);\n    const handler = this.responseHandlers.get(messageId);\n\n    if (handler === undefined) {\n      throw new MCPClientError({\n        message: `Protocol error: Received a response for an unknown message ID: ${JSON.stringify(\n          response,\n        )}`,\n      });\n    }\n\n    this.responseHandlers.delete(messageId);\n\n    handler(\n      'result' in response\n        ? response\n        : new MCPClientError({\n            message: response.error.message,\n            cause: response.error,\n          }),\n    );\n  }\n}\n", "import { Schema } from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { ToolResultContent } from '../prompt/tool-result-content';\nimport { CoreMessage } from '../prompt/message';\n\nexport type ToolParameters = z.ZodTypeAny | Schema<any>;\n\nexport type inferParameters<PARAMETERS extends ToolParameters> =\n  PARAMETERS extends Schema<any>\n    ? PARAMETERS['_type']\n    : PARAMETERS extends z.ZodTypeAny\n      ? z.infer<PARAMETERS>\n      : never;\n\nexport interface ToolExecutionOptions {\n  /**\n   * The ID of the tool call. You can use it e.g. when sending tool-call related information with stream data.\n   */\n  toolCallId: string;\n\n  /**\n   * Messages that were sent to the language model to initiate the response that contained the tool call.\n   * The messages **do not** include the system prompt nor the assistant response that contained the tool call.\n   */\n  messages: CoreMessage[];\n\n  /**\n   * An optional abort signal that indicates that the overall operation should be aborted.\n   */\n  abortSignal?: AbortSignal;\n}\n\n/**\nA tool contains the description and the schema of the input that the tool expects.\nThis enables the language model to generate the input.\n\nThe tool can also contain an optional execute function for the actual execution function of the tool.\n */\nexport type Tool<PARAMETERS extends ToolParameters = any, RESULT = any> = {\n  /**\nThe schema of the input that the tool expects. The language model will use this to generate the input.\nIt is also used to validate the output of the language model.\nUse descriptions to make the input understandable for the language model.\n   */\n  parameters: PARAMETERS;\n\n  /**\nAn optional description of what the tool does.\nWill be used by the language model to decide whether to use the tool.\nNot used for provider-defined tools.\n   */\n  description?: string;\n\n  /**\nOptional conversion function that maps the tool result to multi-part tool content for LLMs.\n   */\n  experimental_toToolResultContent?: (result: RESULT) => ToolResultContent;\n\n  /**\nAn async function that is called with the arguments from the tool call and produces a result.\nIf not provided, the tool will not be executed automatically.\n\n@args is the input of the tool call.\n@options.abortSignal is a signal that can be used to abort the tool call.\n   */\n  execute?: (\n    args: inferParameters<PARAMETERS>,\n    options: ToolExecutionOptions,\n  ) => PromiseLike<RESULT>;\n} & (\n  | {\n      /**\nFunction tool.\n       */\n      type?: undefined | 'function';\n    }\n  | {\n      /**\nProvider-defined tool.\n       */\n      type: 'provider-defined';\n\n      /**\nThe ID of the tool. Should follow the format `<provider-name>.<tool-name>`.\n       */\n      id: `${string}.${string}`;\n\n      /**\nThe arguments for configuring the tool. Must match the expected arguments defined by the provider for this tool.\n       */\n      args: Record<string, unknown>;\n    }\n);\n\n/**\n * @deprecated Use `Tool` instead.\n */\n// TODO remove in v5\nexport type CoreTool<\n  PARAMETERS extends ToolParameters = any,\n  RESULT = any,\n> = Tool<PARAMETERS, RESULT>;\n\n/**\nHelper function for inferring the execute args of a tool.\n */\n// Note: special type inference is needed for the execute function args to make sure they are inferred correctly.\nexport function tool<PARAMETERS extends ToolParameters, RESULT>(\n  tool: Tool<PARAMETERS, RESULT> & {\n    execute: (\n      args: inferParameters<PARAMETERS>,\n      options: ToolExecutionOptions,\n    ) => PromiseLike<RESULT>;\n  },\n): Tool<PARAMETERS, RESULT> & {\n  execute: (\n    args: inferParameters<PARAMETERS>,\n    options: ToolExecutionOptions,\n  ) => PromiseLike<RESULT>;\n};\nexport function tool<PARAMETERS extends ToolParameters, RESULT>(\n  tool: Tool<PARAMETERS, RESULT> & {\n    execute?: undefined;\n  },\n): Tool<PARAMETERS, RESULT> & {\n  execute: undefined;\n};\nexport function tool<PARAMETERS extends ToolParameters, RESULT = any>(\n  tool: Tool<PARAMETERS, RESULT>,\n): Tool<PARAMETERS, RESULT> {\n  return tool;\n}\n", "import { createEventSourceParserStream } from '@ai-sdk/provider-utils';\nimport { MCPClientError } from '../../../errors';\nimport { JSONRPCMessage, JSONRPCMessageSchema } from './json-rpc-message';\nimport { MCPTransport } from './mcp-transport';\n\nexport class SseMCPTransport implements MCPTransport {\n  private endpoint?: URL;\n  private abortController?: AbortController;\n  private url: URL;\n  private connected = false;\n  private sseConnection?: {\n    close: () => void;\n  };\n  private headers?: Record<string, string>;\n\n  onclose?: () => void;\n  onerror?: (error: unknown) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n\n  constructor({\n    url,\n    headers,\n  }: {\n    url: string;\n    headers?: Record<string, string>;\n  }) {\n    this.url = new URL(url);\n    this.headers = headers;\n  }\n\n  async start(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      if (this.connected) {\n        return resolve();\n      }\n\n      this.abortController = new AbortController();\n\n      const establishConnection = async () => {\n        try {\n          const headers = new Headers(this.headers);\n          headers.set('Accept', 'text/event-stream');\n          const response = await fetch(this.url.href, {\n            headers,\n            signal: this.abortController?.signal,\n          });\n\n          if (!response.ok || !response.body) {\n            const error = new MCPClientError({\n              message: `MCP SSE Transport Error: ${response.status} ${response.statusText}`,\n            });\n            this.onerror?.(error);\n            return reject(error);\n          }\n\n          const stream = response.body\n            .pipeThrough(new TextDecoderStream())\n            .pipeThrough(createEventSourceParserStream());\n\n          const reader = stream.getReader();\n\n          const processEvents = async () => {\n            try {\n              while (true) {\n                const { done, value } = await reader.read();\n\n                if (done) {\n                  if (this.connected) {\n                    this.connected = false;\n                    throw new MCPClientError({\n                      message:\n                        'MCP SSE Transport Error: Connection closed unexpectedly',\n                    });\n                  }\n                  return;\n                }\n\n                const { event, data } = value;\n\n                if (event === 'endpoint') {\n                  this.endpoint = new URL(data, this.url);\n\n                  if (this.endpoint.origin !== this.url.origin) {\n                    throw new MCPClientError({\n                      message: `MCP SSE Transport Error: Endpoint origin does not match connection origin: ${this.endpoint.origin}`,\n                    });\n                  }\n\n                  this.connected = true;\n                  resolve();\n                } else if (event === 'message') {\n                  try {\n                    const message = JSONRPCMessageSchema.parse(\n                      JSON.parse(data),\n                    );\n                    this.onmessage?.(message);\n                  } catch (error) {\n                    const e = new MCPClientError({\n                      message:\n                        'MCP SSE Transport Error: Failed to parse message',\n                      cause: error,\n                    });\n                    this.onerror?.(e);\n                    // We do not throw here so we continue processing events after reporting the error\n                  }\n                }\n              }\n            } catch (error) {\n              if (error instanceof Error && error.name === 'AbortError') {\n                return;\n              }\n\n              this.onerror?.(error);\n              reject(error);\n            }\n          };\n\n          this.sseConnection = {\n            close: () => reader.cancel(),\n          };\n\n          processEvents();\n        } catch (error) {\n          if (error instanceof Error && error.name === 'AbortError') {\n            return;\n          }\n\n          this.onerror?.(error);\n          reject(error);\n        }\n      };\n\n      establishConnection();\n    });\n  }\n\n  async close(): Promise<void> {\n    this.connected = false;\n    this.sseConnection?.close();\n    this.abortController?.abort();\n    this.onclose?.();\n  }\n\n  async send(message: JSONRPCMessage): Promise<void> {\n    if (!this.endpoint || !this.connected) {\n      throw new MCPClientError({\n        message: 'MCP SSE Transport Error: Not connected',\n      });\n    }\n\n    try {\n      const headers = new Headers(this.headers);\n      headers.set('Content-Type', 'application/json');\n      const init = {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(message),\n        signal: this.abortController?.signal,\n      };\n\n      const response = await fetch(this.endpoint, init);\n\n      if (!response.ok) {\n        const text = await response.text().catch(() => null);\n        const error = new MCPClientError({\n          message: `MCP SSE Transport Error: POSTing to endpoint (HTTP ${response.status}): ${text}`,\n        });\n        this.onerror?.(error);\n        return;\n      }\n    } catch (error) {\n      this.onerror?.(error);\n      return;\n    }\n  }\n}\n\nexport function deserializeMessage(line: string): JSONRPCMessage {\n  return JSONRPCMessageSchema.parse(JSON.parse(line));\n}\n", "import { z } from 'zod';\nimport { BaseParamsSchema, RequestSchema, ResultSchema } from './types';\n\nconst JSONRPC_VERSION = '2.0';\n\nconst JSONRPCRequestSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: z.union([z.string(), z.number().int()]),\n  })\n  .merge(RequestSchema)\n  .strict();\n\nexport type JSONRPCRequest = z.infer<typeof JSONRPCRequestSchema>;\n\nconst JSONRPCResponseSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: z.union([z.string(), z.number().int()]),\n    result: ResultSchema,\n  })\n  .strict();\n\nexport type JSONRPCResponse = z.infer<typeof JSONRPCResponseSchema>;\n\nconst JSONRPCErrorSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: z.union([z.string(), z.number().int()]),\n    error: z.object({\n      code: z.number().int(),\n      message: z.string(),\n      data: z.optional(z.unknown()),\n    }),\n  })\n  .strict();\n\nexport type JSONRPCError = z.infer<typeof JSONRPCErrorSchema>;\n\nconst JSONRPCNotificationSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n  })\n  .merge(\n    z.object({\n      method: z.string(),\n      params: z.optional(BaseParamsSchema),\n    }),\n  )\n  .strict();\n\nexport type JSONRPCNotification = z.infer<typeof JSONRPCNotificationSchema>;\n\nexport const JSONRPCMessageSchema = z.union([\n  JSONRPCRequestSchema,\n  JSONRPCNotificationSchema,\n  JSONRPCResponseSchema,\n  JSONRPCErrorSchema,\n]);\n\nexport type JSONRPCMessage = z.infer<typeof JSONRPCMessageSchema>;\n", "import { z } from 'zod';\nimport {\n  inferParameters,\n  Tool,\n  ToolExecutionOptions,\n  ToolParameters,\n} from '../tool';\n\nexport const LATEST_PROTOCOL_VERSION = '2024-11-05';\nexport const SUPPORTED_PROTOCOL_VERSIONS = [\n  LATEST_PROTOCOL_VERSION,\n  '2024-10-07',\n];\n\nexport type ToolSchemas =\n  | Record<string, { parameters: ToolParameters }>\n  | 'automatic'\n  | undefined;\n\nexport type McpToolSet<TOOL_SCHEMAS extends ToolSchemas = 'automatic'> =\n  TOOL_SCHEMAS extends Record<string, { parameters: ToolParameters }>\n    ? {\n        [K in keyof TOOL_SCHEMAS]: Tool<\n          TOOL_SCHEMAS[K]['parameters'],\n          CallToolResult\n        > & {\n          execute: (\n            args: inferParameters<TOOL_SCHEMAS[K]['parameters']>,\n            options: ToolExecutionOptions,\n          ) => PromiseLike<CallToolResult>;\n        };\n      }\n    : {\n        [k: string]: Tool<z.ZodUnknown, CallToolResult> & {\n          execute: (\n            args: unknown,\n            options: ToolExecutionOptions,\n          ) => PromiseLike<CallToolResult>;\n        };\n      };\n\nconst ClientOrServerImplementationSchema = z\n  .object({\n    name: z.string(),\n    version: z.string(),\n  })\n  .passthrough();\nexport type Configuration = z.infer<typeof ClientOrServerImplementationSchema>;\n\nexport const BaseParamsSchema = z\n  .object({\n    _meta: z.optional(z.object({}).passthrough()),\n  })\n  .passthrough();\ntype BaseParams = z.infer<typeof BaseParamsSchema>;\nexport const ResultSchema = BaseParamsSchema;\n\nexport const RequestSchema = z.object({\n  method: z.string(),\n  params: z.optional(BaseParamsSchema),\n});\nexport type Request = z.infer<typeof RequestSchema>;\nexport type RequestOptions = {\n  signal?: AbortSignal;\n  timeout?: number;\n  maxTotalTimeout?: number;\n};\n\nexport type Notification = z.infer<typeof RequestSchema>;\n\nconst ServerCapabilitiesSchema = z\n  .object({\n    experimental: z.optional(z.object({}).passthrough()),\n    logging: z.optional(z.object({}).passthrough()),\n    prompts: z.optional(\n      z\n        .object({\n          listChanged: z.optional(z.boolean()),\n        })\n        .passthrough(),\n    ),\n    resources: z.optional(\n      z\n        .object({\n          subscribe: z.optional(z.boolean()),\n          listChanged: z.optional(z.boolean()),\n        })\n        .passthrough(),\n    ),\n    tools: z.optional(\n      z\n        .object({\n          listChanged: z.optional(z.boolean()),\n        })\n        .passthrough(),\n    ),\n  })\n  .passthrough();\nexport type ServerCapabilities = z.infer<typeof ServerCapabilitiesSchema>;\n\nexport const InitializeResultSchema = ResultSchema.extend({\n  protocolVersion: z.string(),\n  capabilities: ServerCapabilitiesSchema,\n  serverInfo: ClientOrServerImplementationSchema,\n  instructions: z.optional(z.string()),\n});\nexport type InitializeResult = z.infer<typeof InitializeResultSchema>;\n\nexport type PaginatedRequest = Request & {\n  params?: BaseParams & {\n    cursor?: string;\n  };\n};\n\nconst PaginatedResultSchema = ResultSchema.extend({\n  nextCursor: z.optional(z.string()),\n});\n\nconst ToolSchema = z\n  .object({\n    name: z.string(),\n    description: z.optional(z.string()),\n    inputSchema: z\n      .object({\n        type: z.literal('object'),\n        properties: z.optional(z.object({}).passthrough()),\n      })\n      .passthrough(),\n  })\n  .passthrough();\nexport type MCPTool = z.infer<typeof ToolSchema>;\nexport const ListToolsResultSchema = PaginatedResultSchema.extend({\n  tools: z.array(ToolSchema),\n});\nexport type ListToolsResult = z.infer<typeof ListToolsResultSchema>;\n\nconst TextContentSchema = z\n  .object({\n    type: z.literal('text'),\n    text: z.string(),\n  })\n  .passthrough();\nconst ImageContentSchema = z\n  .object({\n    type: z.literal('image'),\n    data: z.string().base64(),\n    mimeType: z.string(),\n  })\n  .passthrough();\nconst ResourceContentsSchema = z\n  .object({\n    /**\n     * The URI of this resource.\n     */\n    uri: z.string(),\n    /**\n     * The MIME type of this resource, if known.\n     */\n    mimeType: z.optional(z.string()),\n  })\n  .passthrough();\nconst TextResourceContentsSchema = ResourceContentsSchema.extend({\n  text: z.string(),\n});\nconst BlobResourceContentsSchema = ResourceContentsSchema.extend({\n  blob: z.string().base64(),\n});\nconst EmbeddedResourceSchema = z\n  .object({\n    type: z.literal('resource'),\n    resource: z.union([TextResourceContentsSchema, BlobResourceContentsSchema]),\n  })\n  .passthrough();\n\nexport const CallToolResultSchema = ResultSchema.extend({\n  content: z.array(\n    z.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema]),\n  ),\n  isError: z.boolean().default(false).optional(),\n}).or(\n  ResultSchema.extend({\n    toolResult: z.unknown(),\n  }),\n);\nexport type CallToolResult = z.infer<typeof CallToolResultSchema>;\n", "import { MCPClientError } from '../../../errors';\nimport { JSONRPCMessage } from './json-rpc-message';\nimport { SseMCPTransport } from './mcp-sse-transport';\n\n/**\n * Transport interface for MCP (Model Context Protocol) communication.\n * Maps to the `Transport` interface in the MCP spec.\n */\nexport interface MCPTransport {\n  /**\n   * Initialize and start the transport\n   */\n  start(): Promise<void>;\n\n  /**\n   * Send a JSON-RPC message through the transport\n   * @param message The JSON-RPC message to send\n   */\n  send(message: JSONRPCMessage): Promise<void>;\n\n  /**\n   * Clean up and close the transport\n   */\n  close(): Promise<void>;\n\n  /**\n   * Event handler for transport closure\n   */\n  onclose?: () => void;\n\n  /**\n   * Event handler for transport errors\n   */\n  onerror?: (error: Error) => void;\n\n  /**\n   * Event handler for received messages\n   */\n  onmessage?: (message: JSONRPCMessage) => void;\n}\n\nexport type MCPTransportConfig = {\n  type: 'sse';\n\n  /**\n   * The URL of the MCP server.\n   */\n  url: string;\n\n  /**\n   * Additional HTTP headers to be sent with requests.\n   */\n  headers?: Record<string, string>;\n};\n\nexport function createMcpTransport(config: MCPTransportConfig): MCPTransport {\n  if (config.type !== 'sse') {\n    throw new MCPClientError({\n      message:\n        'Unsupported or invalid transport configuration. If you are using a custom transport, make sure it implements the MCPTransport interface.',\n    });\n  }\n\n  return new SseMCPTransport(config);\n}\n\nexport function isCustomMcpTransport(\n  transport: MCPTransportConfig | MCPTransport,\n): transport is MCPTransport {\n  return (\n    'start' in transport &&\n    typeof transport.start === 'function' &&\n    'send' in transport &&\n    typeof transport.send === 'function' &&\n    'close' in transport &&\n    typeof transport.close === 'function'\n  );\n}\n", "import { InvalidArgumentError } from '../../errors/invalid-argument-error';\n\n/**\n * Calculates the cosine similarity between two vectors. This is a useful metric for\n * comparing the similarity of two vectors such as embeddings.\n *\n * @param vector1 - The first vector.\n * @param vector2 - The second vector.\n * @param options - Optional configuration.\n * @param options.throwErrorForEmptyVectors - If true, throws an error for empty vectors. Default: false.\n *\n * @returns The cosine similarity between vector1 and vector2.\n * @returns 0 if either vector is the zero vector.\n *\n * @throws {InvalidArgumentError} If throwErrorForEmptyVectors is true and vectors are empty.\n * @throws {InvalidArgumentError} If the vectors do not have the same length.\n */\nexport function cosineSimilarity(\n  vector1: number[],\n  vector2: number[],\n  // TODO remove throw option in 5.0\n  options?: {\n    /**\n     * @deprecated will be removed in 5.0\n     */\n    throwErrorForEmptyVectors?: boolean;\n  },\n): number {\n  if (vector1.length !== vector2.length) {\n    throw new InvalidArgumentError({\n      parameter: 'vector1,vector2',\n      value: { vector1Length: vector1.length, vector2Length: vector2.length },\n      message: `Vectors must have the same length`,\n    });\n  }\n\n  const n = vector1.length;\n\n  if (n === 0) {\n    if (options?.throwErrorForEmptyVectors) {\n      throw new InvalidArgumentError({\n        parameter: 'vector1',\n        value: vector1,\n        message: 'Vectors cannot be empty',\n      });\n    }\n\n    return 0; // Return 0 for empty vectors if no error is thrown\n  }\n\n  let magnitudeSquared1 = 0;\n  let magnitudeSquared2 = 0;\n  let dotProduct = 0;\n\n  for (let i = 0; i < n; i++) {\n    const value1 = vector1[i];\n    const value2 = vector2[i];\n\n    magnitudeSquared1 += value1 * value1;\n    magnitudeSquared2 += value2 * value2;\n    dotProduct += value1 * value2;\n  }\n\n  return magnitudeSquared1 === 0 || magnitudeSquared2 === 0\n    ? 0\n    : dotProduct /\n        (Math.sqrt(magnitudeSquared1) * Math.sqrt(magnitudeSquared2));\n}\n", "import { delay as delayFunction } from '@ai-sdk/provider-utils';\n\n/**\n * Creates a ReadableStream that emits the provided values with an optional delay between each value.\n *\n * @param options - The configuration options\n * @param options.chunks - Array of values to be emitted by the stream\n * @param options.initialDelayInMs - Optional initial delay in milliseconds before emitting the first value (default: 0). Can be set to `null` to skip the initial delay. The difference between `initialDelayInMs: null` and `initialDelayInMs: 0` is that `initialDelayInMs: null` will emit the values without any delay, while `initialDelayInMs: 0` will emit the values with a delay of 0 milliseconds.\n * @param options.chunkDelayInMs - Optional delay in milliseconds between emitting each value (default: 0). Can be set to `null` to skip the delay. The difference between `chunkDelayInMs: null` and `chunkDelayInMs: 0` is that `chunkDelayInMs: null` will emit the values without any delay, while `chunkDelayInMs: 0` will emit the values with a delay of 0 milliseconds.\n * @returns A ReadableStream that emits the provided values\n */\nexport function simulateReadableStream<T>({\n  chunks,\n  initialDelayInMs = 0,\n  chunkDelayInMs = 0,\n  _internal,\n}: {\n  chunks: T[];\n  initialDelayInMs?: number | null;\n  chunkDelayInMs?: number | null;\n  _internal?: {\n    delay?: (ms: number | null) => Promise<void>;\n  };\n}): ReadableStream<T> {\n  const delay = _internal?.delay ?? delayFunction;\n\n  let index = 0;\n\n  return new ReadableStream({\n    async pull(controller) {\n      if (index < chunks.length) {\n        await delay(index === 0 ? initialDelayInMs : chunkDelayInMs);\n        controller.enqueue(chunks[index++]);\n      } else {\n        controller.close();\n      }\n    },\n  });\n}\n", "import {\n  AssistantMessage,\n  DataMessage,\n  formatAssistantStreamPart,\n} from '@ai-sdk/ui-utils';\n\n/**\nYou can pass the thread and the latest message into the `AssistantResponse`. This establishes the context for the response.\n */\ntype AssistantResponseSettings = {\n  /**\nThe thread ID that the response is associated with.\n   */\n  threadId: string;\n\n  /**\nThe ID of the latest message that the response is associated with.\n */\n  messageId: string;\n};\n\n/**\nThe process parameter is a callback in which you can run the assistant on threads, and send messages and data messages to the client.\n */\ntype AssistantResponseCallback = (options: {\n  /**\nForwards an assistant message (non-streaming) to the client.\n   */\n  sendMessage: (message: AssistantMessage) => void;\n\n  /**\nSend a data message to the client. You can use this to provide information for rendering custom UIs while the assistant is processing the thread.\n */\n  sendDataMessage: (message: DataMessage) => void;\n\n  /**\nForwards the assistant response stream to the client. Returns the `Run` object after it completes, or when it requires an action.\n   */\n  forwardStream: (stream: any) => Promise<any | undefined>;\n}) => Promise<void>;\n\n/**\nThe `AssistantResponse` allows you to send a stream of assistant update to `useAssistant`.\nIt is designed to facilitate streaming assistant responses to the `useAssistant` hook.\nIt receives an assistant thread and a current message, and can send messages and data messages to the client.\n */\nexport function AssistantResponse(\n  { threadId, messageId }: AssistantResponseSettings,\n  process: AssistantResponseCallback,\n): Response {\n  const stream = new ReadableStream({\n    async start(controller) {\n      const textEncoder = new TextEncoder();\n\n      const sendMessage = (message: AssistantMessage) => {\n        controller.enqueue(\n          textEncoder.encode(\n            formatAssistantStreamPart('assistant_message', message),\n          ),\n        );\n      };\n\n      const sendDataMessage = (message: DataMessage) => {\n        controller.enqueue(\n          textEncoder.encode(\n            formatAssistantStreamPart('data_message', message),\n          ),\n        );\n      };\n\n      const sendError = (errorMessage: string) => {\n        controller.enqueue(\n          textEncoder.encode(formatAssistantStreamPart('error', errorMessage)),\n        );\n      };\n\n      const forwardStream = async (stream: any) => {\n        let result: any | undefined = undefined;\n\n        for await (const value of stream) {\n          switch (value.event) {\n            case 'thread.message.created': {\n              controller.enqueue(\n                textEncoder.encode(\n                  formatAssistantStreamPart('assistant_message', {\n                    id: value.data.id,\n                    role: 'assistant',\n                    content: [{ type: 'text', text: { value: '' } }],\n                  }),\n                ),\n              );\n              break;\n            }\n\n            case 'thread.message.delta': {\n              const content = value.data.delta.content?.[0];\n\n              if (content?.type === 'text' && content.text?.value != null) {\n                controller.enqueue(\n                  textEncoder.encode(\n                    formatAssistantStreamPart('text', content.text.value),\n                  ),\n                );\n              }\n\n              break;\n            }\n\n            case 'thread.run.completed':\n            case 'thread.run.requires_action': {\n              result = value.data;\n              break;\n            }\n          }\n        }\n\n        return result;\n      };\n\n      // send the threadId and messageId as the first message:\n      controller.enqueue(\n        textEncoder.encode(\n          formatAssistantStreamPart('assistant_control_data', {\n            threadId,\n            messageId,\n          }),\n        ),\n      );\n\n      try {\n        await process({\n          sendMessage,\n          sendDataMessage,\n          forwardStream,\n        });\n      } catch (error) {\n        sendError((error as any).message ?? `${error}`);\n      } finally {\n        controller.close();\n      }\n    },\n    pull(controller) {},\n    cancel() {},\n  });\n\n  return new Response(stream, {\n    status: 200,\n    headers: {\n      'Content-Type': 'text/plain; charset=utf-8',\n    },\n  });\n}\n", "import { formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { DataStreamWriter } from '../core/data-stream/data-stream-writer';\nimport { mergeStreams } from '../core/util/merge-streams';\nimport { prepareResponseHeaders } from '../core/util/prepare-response-headers';\nimport {\n  createCallbacksTransformer,\n  StreamCallbacks,\n} from './stream-callbacks';\nimport { StreamData } from './stream-data';\n\ntype LangChainImageDetail = 'auto' | 'low' | 'high';\n\ntype LangChainMessageContentText = {\n  type: 'text';\n  text: string;\n};\n\ntype LangChainMessageContentImageUrl = {\n  type: 'image_url';\n  image_url:\n    | string\n    | {\n        url: string;\n        detail?: LangChainImageDetail;\n      };\n};\n\ntype LangChainMessageContentComplex =\n  | LangChainMessageContentText\n  | LangChainMessageContentImageUrl\n  | (Record<string, any> & {\n      type?: 'text' | 'image_url' | string;\n    })\n  | (Record<string, any> & {\n      type?: never;\n    });\n\ntype LangChainMessageContent = string | LangChainMessageContentComplex[];\n\ntype LangChainAIMessageChunk = {\n  content: LangChainMessageContent;\n};\n\n// LC stream event v2\ntype LangChainStreamEvent = {\n  event: string;\n  data: any;\n};\n\nfunction toDataStreamInternal(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  callbacks?: StreamCallbacks,\n) {\n  return stream\n    .pipeThrough(\n      new TransformStream<\n        LangChainStreamEvent | LangChainAIMessageChunk | string\n      >({\n        transform: async (value, controller) => {\n          // text stream:\n          if (typeof value === 'string') {\n            controller.enqueue(value);\n            return;\n          }\n\n          // LC stream events v2:\n          if ('event' in value) {\n            // chunk is AIMessage Chunk for on_chat_model_stream event:\n            if (value.event === 'on_chat_model_stream') {\n              forwardAIMessageChunk(\n                value.data?.chunk as LangChainAIMessageChunk,\n                controller,\n              );\n            }\n            return;\n          }\n\n          // AI Message chunk stream:\n          forwardAIMessageChunk(value, controller);\n        },\n      }),\n    )\n    .pipeThrough(createCallbacksTransformer(callbacks))\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(\n      new TransformStream({\n        transform: async (chunk, controller) => {\n          controller.enqueue(formatDataStreamPart('text', chunk));\n        },\n      }),\n    );\n}\n\n/**\nConverts LangChain output streams to an AI SDK Data Stream.\n\nThe following streams are supported:\n- `LangChainAIMessageChunk` streams (LangChain `model.stream` output)\n- `string` streams (LangChain `StringOutputParser` output)\n */\nexport function toDataStream(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  callbacks?: StreamCallbacks,\n) {\n  return toDataStreamInternal(stream, callbacks).pipeThrough(\n    new TextEncoderStream(),\n  );\n}\n\nexport function toDataStreamResponse(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  options?: {\n    init?: ResponseInit;\n    data?: StreamData;\n    callbacks?: StreamCallbacks;\n  },\n) {\n  const dataStream = toDataStreamInternal(\n    stream,\n    options?.callbacks,\n  ).pipeThrough(new TextEncoderStream());\n  const data = options?.data;\n  const init = options?.init;\n\n  const responseStream = data\n    ? mergeStreams(data.stream, dataStream)\n    : dataStream;\n\n  return new Response(responseStream, {\n    status: init?.status ?? 200,\n    statusText: init?.statusText,\n    headers: prepareResponseHeaders(init?.headers, {\n      contentType: 'text/plain; charset=utf-8',\n      dataStreamVersion: 'v1',\n    }),\n  });\n}\n\nexport function mergeIntoDataStream(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  options: { dataStream: DataStreamWriter; callbacks?: StreamCallbacks },\n) {\n  options.dataStream.merge(toDataStreamInternal(stream, options.callbacks));\n}\n\nfunction forwardAIMessageChunk(\n  chunk: LangChainAIMessageChunk,\n  controller: TransformStreamDefaultController<any>,\n) {\n  if (typeof chunk.content === 'string') {\n    controller.enqueue(chunk.content);\n  } else {\n    const content: LangChainMessageContentComplex[] = chunk.content;\n    for (const item of content) {\n      if (item.type === 'text') {\n        controller.enqueue(item.text);\n      }\n    }\n  }\n}\n", "/**\n * Configuration options and helper callback methods for stream lifecycle events.\n */\nexport interface StreamCallbacks {\n  /** `onStart`: Called once when the stream is initialized. */\n  onStart?: () => Promise<void> | void;\n\n  /**\n   * `onCompletion`: Called for each tokenized message.\n   *\n   * @deprecated Use `onFinal` instead.\n   */\n  onCompletion?: (completion: string) => Promise<void> | void;\n\n  /** `onFinal`: Called once when the stream is closed with the final completion message. */\n  onFinal?: (completion: string) => Promise<void> | void;\n\n  /** `onToken`: Called for each tokenized message. */\n  onToken?: (token: string) => Promise<void> | void;\n\n  /** `onText`: Called for each text chunk. */\n  onText?: (text: string) => Promise<void> | void;\n}\n\n/**\n * Creates a transform stream that encodes input messages and invokes optional callback functions.\n * The transform stream uses the provided callbacks to execute custom logic at different stages of the stream's lifecycle.\n * - `onStart`: Called once when the stream is initialized.\n * - `onToken`: Called for each tokenized message.\n * - `onCompletion`: Called every time a completion message is received. This can occur multiple times when using e.g. OpenAI functions\n * - `onFinal`: Called once when the stream is closed with the final completion message.\n *\n * This function is useful when you want to process a stream of messages and perform specific actions during the stream's lifecycle.\n *\n * @param {StreamCallbacks} [callbacks] - An object containing the callback functions.\n * @return {TransformStream<string, Uint8Array>} A transform stream that encodes input messages as Uint8Array and allows the execution of custom logic through callbacks.\n *\n * @example\n * const callbacks = {\n *   onStart: async () => console.log('Stream started'),\n *   onToken: async (token) => console.log(`Token: ${token}`),\n *   onCompletion: async (completion) => console.log(`Completion: ${completion}`)\n *   onFinal: async () => data.close()\n * };\n * const transformer = createCallbacksTransformer(callbacks);\n */\nexport function createCallbacksTransformer(\n  callbacks: StreamCallbacks | undefined = {},\n): TransformStream<string, Uint8Array> {\n  const textEncoder = new TextEncoder();\n  let aggregatedResponse = '';\n\n  return new TransformStream({\n    async start(): Promise<void> {\n      if (callbacks.onStart) await callbacks.onStart();\n    },\n\n    async transform(message, controller): Promise<void> {\n      controller.enqueue(textEncoder.encode(message));\n\n      aggregatedResponse += message;\n\n      if (callbacks.onToken) await callbacks.onToken(message);\n      if (callbacks.onText && typeof message === 'string') {\n        await callbacks.onText(message);\n      }\n    },\n\n    async flush(): Promise<void> {\n      if (callbacks.onCompletion) {\n        await callbacks.onCompletion(aggregatedResponse);\n      }\n      if (callbacks.onFinal) {\n        await callbacks.onFinal(aggregatedResponse);\n      }\n    },\n  });\n}\n", "import { convertAsyncIteratorToReadableStream } from '@ai-sdk/provider-utils';\nimport { formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { DataStreamWriter } from '../core/data-stream/data-stream-writer';\nimport { mergeStreams } from '../core/util/merge-streams';\nimport { prepareResponseHeaders } from '../core/util/prepare-response-headers';\nimport {\n  createCallbacksTransformer,\n  StreamCallbacks,\n} from './stream-callbacks';\nimport { StreamData } from './stream-data';\n\ntype EngineResponse = {\n  delta: string;\n};\n\nfunction toDataStreamInternal(\n  stream: AsyncIterable<EngineResponse>,\n  callbacks?: StreamCallbacks,\n) {\n  const trimStart = trimStartOfStream();\n\n  return convertAsyncIteratorToReadableStream(stream[Symbol.asyncIterator]())\n    .pipeThrough(\n      new TransformStream({\n        async transform(message, controller): Promise<void> {\n          controller.enqueue(trimStart(message.delta));\n        },\n      }),\n    )\n    .pipeThrough(createCallbacksTransformer(callbacks))\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(\n      new TransformStream({\n        transform: async (chunk, controller) => {\n          controller.enqueue(formatDataStreamPart('text', chunk));\n        },\n      }),\n    );\n}\n\nexport function toDataStream(\n  stream: AsyncIterable<EngineResponse>,\n  callbacks?: StreamCallbacks,\n) {\n  return toDataStreamInternal(stream, callbacks).pipeThrough(\n    new TextEncoderStream(),\n  );\n}\n\nexport function toDataStreamResponse(\n  stream: AsyncIterable<EngineResponse>,\n  options: {\n    init?: ResponseInit;\n    data?: StreamData;\n    callbacks?: StreamCallbacks;\n  } = {},\n) {\n  const { init, data, callbacks } = options;\n  const dataStream = toDataStreamInternal(stream, callbacks).pipeThrough(\n    new TextEncoderStream(),\n  );\n  const responseStream = data\n    ? mergeStreams(data.stream, dataStream)\n    : dataStream;\n\n  return new Response(responseStream, {\n    status: init?.status ?? 200,\n    statusText: init?.statusText,\n    headers: prepareResponseHeaders(init?.headers, {\n      contentType: 'text/plain; charset=utf-8',\n      dataStreamVersion: 'v1',\n    }),\n  });\n}\n\nexport function mergeIntoDataStream(\n  stream: AsyncIterable<EngineResponse>,\n  options: {\n    dataStream: DataStreamWriter;\n    callbacks?: StreamCallbacks;\n  },\n) {\n  options.dataStream.merge(toDataStreamInternal(stream, options.callbacks));\n}\n\nfunction trimStartOfStream(): (text: string) => string {\n  let isStreamStart = true;\n\n  return (text: string): string => {\n    if (isStreamStart) {\n      text = text.trimStart();\n      if (text) isStreamStart = false;\n    }\n    return text;\n  };\n}\n", "import { JSONValue, formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { HANGING_STREAM_WARNING_TIME_MS } from '../util/constants';\n\n/**\n * A stream wrapper to send custom JSON-encoded data back to the client.\n *\n * @deprecated Please use `createDataStream`, `createDataStreamResponse`, and `pipeDataStreamToResponse` instead.\n */\nexport class StreamData {\n  private encoder = new TextEncoder();\n\n  private controller: ReadableStreamController<Uint8Array> | null = null;\n  public stream: ReadableStream<Uint8Array>;\n\n  private isClosed: boolean = false;\n  private warningTimeout: NodeJS.Timeout | null = null;\n\n  constructor() {\n    const self = this;\n\n    this.stream = new ReadableStream({\n      start: async controller => {\n        self.controller = controller;\n\n        // Set a timeout to show a warning if the stream is not closed within 3 seconds\n        if (process.env.NODE_ENV === 'development') {\n          self.warningTimeout = setTimeout(() => {\n            console.warn(\n              'The data stream is hanging. Did you forget to close it with `data.close()`?',\n            );\n          }, HANGING_STREAM_WARNING_TIME_MS);\n        }\n      },\n      pull: controller => {\n        // No-op: we don't need to do anything special on pull\n      },\n      cancel: reason => {\n        this.isClosed = true;\n      },\n    });\n  }\n\n  async close(): Promise<void> {\n    if (this.isClosed) {\n      throw new Error('Data Stream has already been closed.');\n    }\n\n    if (!this.controller) {\n      throw new Error('Stream controller is not initialized.');\n    }\n\n    this.controller.close();\n    this.isClosed = true;\n\n    // Clear the warning timeout if the stream is closed\n    if (this.warningTimeout) {\n      clearTimeout(this.warningTimeout);\n    }\n  }\n\n  append(value: JSONValue): void {\n    if (this.isClosed) {\n      throw new Error('Data Stream has already been closed.');\n    }\n\n    if (!this.controller) {\n      throw new Error('Stream controller is not initialized.');\n    }\n\n    this.controller.enqueue(\n      this.encoder.encode(formatDataStreamPart('data', [value])),\n    );\n  }\n\n  appendMessageAnnotation(value: JSONValue): void {\n    if (this.isClosed) {\n      throw new Error('Data Stream has already been closed.');\n    }\n\n    if (!this.controller) {\n      throw new Error('Stream controller is not initialized.');\n    }\n\n    this.controller.enqueue(\n      this.encoder.encode(formatDataStreamPart('message_annotations', [value])),\n    );\n  }\n}\n", "/**\n * Warning time for notifying developers that a stream is hanging in dev mode\n * using a console.warn.\n */\nexport const HANGING_STREAM_WARNING_TIME_MS = 15 * 1000;\n", "/* @ts-self-types=\"./index.d.ts\" */\nimport { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step | 0\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size | 0, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n", "export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n", "import {\n  SSEClientTransport,\n  type SSEClientTransportOptions,\n} from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport type { OAuthClientProvider } from \"@modelcontextprotocol/sdk/client/auth.js\";\n\nexport class SSEEdgeClientTransport extends SSEClientTransport {\n  private authProvider: OAuthClientProvider | undefined;\n  /**\n   * Creates a new EdgeSSEClientTransport, which overrides fetch to be compatible with the CF workers environment\n   */\n  constructor(url: URL, options: SSEClientTransportOptions) {\n    const fetchOverride: typeof fetch = async (\n      fetchUrl: RequestInfo | URL,\n      fetchInit: RequestInit = {}\n    ) => {\n      // add auth headers\n      const headers = await this.authHeaders();\n      const workerOptions = {\n        ...fetchInit,\n        headers: {\n          ...options.requestInit?.headers,\n          ...fetchInit?.headers,\n          ...headers,\n        },\n      };\n\n      // Remove unsupported properties\n      // biome-ignore lint/performance/noDelete: workaround for workers environment\n      delete workerOptions.mode;\n\n      // Call the original fetch with fixed options\n      return (\n        (options.eventSourceInit?.fetch?.(\n          fetchUrl as URL | string,\n          // @ts-expect-error Expects FetchLikeInit from EventSource but is compatible with RequestInit\n          workerOptions\n        ) as Promise<Response>) || fetch(fetchUrl, workerOptions)\n      );\n    };\n\n    super(url, {\n      ...options,\n      eventSourceInit: {\n        ...options.eventSourceInit,\n        fetch: fetchOverride,\n      },\n    });\n    this.authProvider = options.authProvider;\n  }\n\n  async authHeaders() {\n    if (this.authProvider) {\n      const tokens = await this.authProvider.tokens();\n      if (tokens) {\n        return {\n          Authorization: `Bearer ${tokens.access_token}`,\n        };\n      }\n    }\n  }\n}\n", "import { SSEEdgeClientTransport } from \"./sse-edge\";\n\nimport {\n  ToolListChangedNotificationSchema,\n  type ClientCapabilities,\n  type Resource,\n  type Tool,\n  type Prompt,\n  ResourceListChangedNotificationSchema,\n  PromptListChangedNotificationSchema,\n  type ListToolsResult,\n  type ListResourcesResult,\n  type ListPromptsResult,\n  type ServerCapabilities,\n  type ResourceTemplate,\n  type ListResourceTemplatesResult,\n  type Notification,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport type { SSEClientTransportOptions } from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport type { AgentsOAuthProvider } from \"./do-oauth-client-provider\";\n\nexport class MCPClientConnection {\n  client: Client;\n  connectionState:\n    | \"authenticating\"\n    | \"connecting\"\n    | \"ready\"\n    | \"discovering\"\n    | \"failed\" = \"connecting\";\n  instructions?: string;\n  tools: Tool[] = [];\n  prompts: Prompt[] = [];\n  resources: Resource[] = [];\n  resourceTemplates: ResourceTemplate[] = [];\n  serverCapabilities: ServerCapabilities | undefined;\n\n  constructor(\n    public url: URL,\n    info: ConstructorParameters<typeof Client>[0],\n    public options: {\n      transport: SSEClientTransportOptions & {\n        authProvider?: AgentsOAuthProvider;\n      };\n      client: ConstructorParameters<typeof Client>[1];\n    } = { transport: {}, client: {} }\n  ) {\n    this.client = new Client(info, options.client);\n  }\n\n  /**\n   * Initialize a client connection\n   *\n   * @param code Optional OAuth code to initialize the connection with if auth hasn't been initialized\n   * @returns\n   */\n  async init(code?: string) {\n    try {\n      const transport = new SSEEdgeClientTransport(\n        this.url,\n        this.options.transport\n      );\n\n      if (code) {\n        await transport.finishAuth(code);\n      }\n\n      await this.client.connect(transport);\n      // biome-ignore lint/suspicious/noExplicitAny: allow for the error check here\n    } catch (e: any) {\n      if (e.toString().includes(\"Unauthorized\")) {\n        // unauthorized, we should wait for the user to authenticate\n        this.connectionState = \"authenticating\";\n        return;\n      }\n      this.connectionState = \"failed\";\n      throw e;\n    }\n\n    this.connectionState = \"discovering\";\n\n    this.serverCapabilities = await this.client.getServerCapabilities();\n    if (!this.serverCapabilities) {\n      throw new Error(\"The MCP Server failed to return server capabilities\");\n    }\n\n    const [instructions, tools, resources, prompts, resourceTemplates] =\n      await Promise.all([\n        this.client.getInstructions(),\n        this.registerTools(),\n        this.registerResources(),\n        this.registerPrompts(),\n        this.registerResourceTemplates(),\n      ]);\n\n    this.instructions = instructions;\n    this.tools = tools;\n    this.resources = resources;\n    this.prompts = prompts;\n    this.resourceTemplates = resourceTemplates;\n\n    this.connectionState = \"ready\";\n  }\n\n  /**\n   * Notification handler registration\n   */\n  async registerTools(): Promise<Tool[]> {\n    if (!this.serverCapabilities || !this.serverCapabilities.tools) {\n      return [];\n    }\n\n    if (this.serverCapabilities.tools.listChanged) {\n      this.client.setNotificationHandler(\n        ToolListChangedNotificationSchema,\n        async (_notification) => {\n          this.tools = await this.fetchTools();\n        }\n      );\n    }\n\n    return this.fetchTools();\n  }\n\n  async registerResources(): Promise<Resource[]> {\n    if (!this.serverCapabilities || !this.serverCapabilities.resources) {\n      return [];\n    }\n\n    if (this.serverCapabilities.resources.listChanged) {\n      this.client.setNotificationHandler(\n        ResourceListChangedNotificationSchema,\n        async (_notification) => {\n          this.resources = await this.fetchResources();\n        }\n      );\n    }\n\n    return this.fetchResources();\n  }\n\n  async registerPrompts(): Promise<Prompt[]> {\n    if (!this.serverCapabilities || !this.serverCapabilities.prompts) {\n      return [];\n    }\n\n    if (this.serverCapabilities.prompts.listChanged) {\n      this.client.setNotificationHandler(\n        PromptListChangedNotificationSchema,\n        async (_notification) => {\n          this.prompts = await this.fetchPrompts();\n        }\n      );\n    }\n\n    return this.fetchPrompts();\n  }\n\n  async registerResourceTemplates(): Promise<ResourceTemplate[]> {\n    if (!this.serverCapabilities || !this.serverCapabilities.resources) {\n      return [];\n    }\n\n    return this.fetchResourceTemplates();\n  }\n\n  async fetchTools() {\n    let toolsAgg: Tool[] = [];\n    let toolsResult: ListToolsResult = { tools: [] };\n    do {\n      toolsResult = await this.client\n        .listTools({\n          cursor: toolsResult.nextCursor,\n        })\n        .catch(capabilityErrorHandler({ tools: [] }, \"tools/list\"));\n      toolsAgg = toolsAgg.concat(toolsResult.tools);\n    } while (toolsResult.nextCursor);\n    return toolsAgg;\n  }\n\n  async fetchResources() {\n    let resourcesAgg: Resource[] = [];\n    let resourcesResult: ListResourcesResult = { resources: [] };\n    do {\n      resourcesResult = await this.client\n        .listResources({\n          cursor: resourcesResult.nextCursor,\n        })\n        .catch(capabilityErrorHandler({ resources: [] }, \"resources/list\"));\n      resourcesAgg = resourcesAgg.concat(resourcesResult.resources);\n    } while (resourcesResult.nextCursor);\n    return resourcesAgg;\n  }\n\n  async fetchPrompts() {\n    let promptsAgg: Prompt[] = [];\n    let promptsResult: ListPromptsResult = { prompts: [] };\n    do {\n      promptsResult = await this.client\n        .listPrompts({\n          cursor: promptsResult.nextCursor,\n        })\n        .catch(capabilityErrorHandler({ prompts: [] }, \"prompts/list\"));\n      promptsAgg = promptsAgg.concat(promptsResult.prompts);\n    } while (promptsResult.nextCursor);\n    return promptsAgg;\n  }\n\n  async fetchResourceTemplates() {\n    let templatesAgg: ResourceTemplate[] = [];\n    let templatesResult: ListResourceTemplatesResult = {\n      resourceTemplates: [],\n    };\n    do {\n      templatesResult = await this.client\n        .listResourceTemplates({\n          cursor: templatesResult.nextCursor,\n        })\n        .catch(\n          capabilityErrorHandler(\n            { resourceTemplates: [] },\n            \"resources/templates/list\"\n          )\n        );\n      templatesAgg = templatesAgg.concat(templatesResult.resourceTemplates);\n    } while (templatesResult.nextCursor);\n    return templatesAgg;\n  }\n}\n\nfunction capabilityErrorHandler<T>(empty: T, method: string) {\n  return (e: { code: number }) => {\n    // server is badly behaved and returning invalid capabilities. This commonly occurs for resource templates\n    if (e.code === -32601) {\n      console.error(\n        `The server advertised support for the capability ${method.split(\"/\")[0]}, but returned \"Method not found\" for '${method}'.`\n      );\n      return empty;\n    }\n    throw e;\n  };\n}\n", "import { MCPClientConnection } from \"./client-connection\";\n\nimport type { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport type { SSEClientTransportOptions } from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport type { RequestOptions } from \"@modelcontextprotocol/sdk/shared/protocol.js\";\nimport type {\n  CallToolRequest,\n  CallToolResultSchema,\n  CompatibilityCallToolResultSchema,\n  GetPromptRequest,\n  Prompt,\n  ReadResourceRequest,\n  Resource,\n  ResourceTemplate,\n  Tool,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport { jsonSchema, type ToolSet } from \"ai\";\nimport { nanoid } from \"nanoid\";\nimport type { AgentsOAuthProvider } from \"./do-oauth-client-provider\";\n\n/**\n * Utility class that aggregates multiple MCP clients into one\n */\nexport class MCPClientManager {\n  public mcpConnections: Record<string, MCPClientConnection> = {};\n  private _callbackUrls: string[] = [];\n\n  /**\n   * @param _name Name of the MCP client\n   * @param _version Version of the MCP Client\n   * @param auth Auth paramters if being used to create a DurableObjectOAuthClientProvider\n   */\n  constructor(\n    private _name: string,\n    private _version: string\n  ) {}\n\n  /**\n   * Connect to and register an MCP server\n   *\n   * @param transportConfig Transport config\n   * @param clientConfig Client config\n   * @param capabilities Client capabilities (i.e. if the client supports roots/sampling)\n   */\n  async connect(\n    url: string,\n    options: {\n      // Allows you to reconnect to a server (in the case of an auth reconnect)\n      reconnect?: {\n        // server id\n        id: string;\n        oauthClientId?: string;\n        oauthCode?: string;\n      };\n      // we're overriding authProvider here because we want to be able to access the auth URL\n      transport?: SSEClientTransportOptions & {\n        authProvider?: AgentsOAuthProvider;\n      };\n      client?: ConstructorParameters<typeof Client>[1];\n    } = {}\n  ): Promise<{\n    id: string;\n    authUrl?: string;\n    clientId?: string;\n  }> {\n    const id = options.reconnect?.id ?? nanoid(8);\n\n    if (!options.transport?.authProvider) {\n      console.warn(\n        \"No authProvider provided in the transport options. This client will only support unauthenticated remote MCP Servers\"\n      );\n    } else {\n      options.transport.authProvider.serverId = id;\n      // reconnect with auth\n      if (options.reconnect?.oauthClientId) {\n        options.transport.authProvider.clientId =\n          options.reconnect?.oauthClientId;\n      }\n    }\n\n    this.mcpConnections[id] = new MCPClientConnection(\n      new URL(url),\n      {\n        name: this._name,\n        version: this._version,\n      },\n      {\n        transport: options.transport ?? {},\n        client: options.client ?? {},\n      }\n    );\n\n    await this.mcpConnections[id].init(options.reconnect?.oauthCode);\n\n    const authUrl = options.transport?.authProvider?.authUrl;\n    if (authUrl && options.transport?.authProvider?.redirectUrl) {\n      this._callbackUrls.push(\n        options.transport.authProvider.redirectUrl.toString()\n      );\n      return {\n        id,\n        authUrl,\n        clientId: options.transport?.authProvider?.clientId,\n      };\n    }\n\n    return {\n      id,\n    };\n  }\n\n  isCallbackRequest(req: Request): boolean {\n    return (\n      req.method === \"GET\" &&\n      !!this._callbackUrls.find((url) => {\n        return req.url.startsWith(url);\n      })\n    );\n  }\n\n  async handleCallbackRequest(req: Request) {\n    const url = new URL(req.url);\n    const urlMatch = this._callbackUrls.find((url) => {\n      return req.url.startsWith(url);\n    });\n    if (!urlMatch) {\n      throw new Error(\n        `No callback URI match found for the request url: ${req.url}. Was the request matched with \\`isCallbackRequest()\\`?`\n      );\n    }\n    const code = url.searchParams.get(\"code\");\n    const clientId = url.searchParams.get(\"state\");\n    const urlParams = urlMatch.split(\"/\");\n    const serverId = urlParams[urlParams.length - 1];\n    if (!code) {\n      throw new Error(\"Unauthorized: no code provided\");\n    }\n    if (!clientId) {\n      throw new Error(\"Unauthorized: no state provided\");\n    }\n\n    if (this.mcpConnections[serverId] === undefined) {\n      throw new Error(`Could not find serverId: ${serverId}`);\n    }\n\n    if (this.mcpConnections[serverId].connectionState !== \"authenticating\") {\n      throw new Error(\n        \"Failed to authenticate: the client isn't in the `authenticating` state\"\n      );\n    }\n\n    const conn = this.mcpConnections[serverId];\n    if (!conn.options.transport.authProvider) {\n      throw new Error(\n        \"Trying to finalize authentication for a server connection without an authProvider\"\n      );\n    }\n\n    conn.options.transport.authProvider.clientId = clientId;\n    conn.options.transport.authProvider.serverId = serverId;\n\n    // reconnect to server with authorization\n    const serverUrl = conn.url.toString();\n    await this.connect(serverUrl, {\n      reconnect: {\n        id: serverId,\n        oauthClientId: clientId,\n        oauthCode: code,\n      },\n      ...conn.options,\n    });\n\n    if (this.mcpConnections[serverId].connectionState === \"authenticating\") {\n      throw new Error(\"Failed to authenticate: client failed to initialize\");\n    }\n\n    return { serverId };\n  }\n\n  /**\n   * @returns namespaced list of tools\n   */\n  listTools(): NamespacedData[\"tools\"] {\n    return getNamespacedData(this.mcpConnections, \"tools\");\n  }\n\n  /**\n   * @returns a set of tools that you can use with the AI SDK\n   */\n  unstable_getAITools(): ToolSet {\n    return Object.fromEntries(\n      getNamespacedData(this.mcpConnections, \"tools\").map((tool) => {\n        return [\n          `${tool.serverId}_${tool.name}`,\n          {\n            parameters: jsonSchema(tool.inputSchema),\n            description: tool.description,\n            execute: async (args) => {\n              const result = await this.callTool({\n                name: tool.name,\n                arguments: args,\n                serverId: tool.serverId,\n              });\n              if (result.isError) {\n                // @ts-expect-error TODO we should fix this\n                throw new Error(result.content[0].text);\n              }\n              return result;\n            },\n          },\n        ];\n      })\n    );\n  }\n\n  /**\n   * Closes all connections to MCP servers\n   */\n  async closeAllConnections() {\n    return Promise.all(\n      Object.values(this.mcpConnections).map(async (connection) => {\n        await connection.client.close();\n      })\n    );\n  }\n\n  /**\n   * Closes a connection to an MCP server\n   * @param id The id of the connection to close\n   */\n  async closeConnection(id: string) {\n    if (!this.mcpConnections[id]) {\n      throw new Error(`Connection with id \"${id}\" does not exist.`);\n    }\n    await this.mcpConnections[id].client.close();\n    delete this.mcpConnections[id];\n  }\n\n  /**\n   * @returns namespaced list of prompts\n   */\n  listPrompts(): NamespacedData[\"prompts\"] {\n    return getNamespacedData(this.mcpConnections, \"prompts\");\n  }\n\n  /**\n   * @returns namespaced list of tools\n   */\n  listResources(): NamespacedData[\"resources\"] {\n    return getNamespacedData(this.mcpConnections, \"resources\");\n  }\n\n  /**\n   * @returns namespaced list of resource templates\n   */\n  listResourceTemplates(): NamespacedData[\"resourceTemplates\"] {\n    return getNamespacedData(this.mcpConnections, \"resourceTemplates\");\n  }\n\n  /**\n   * Namespaced version of callTool\n   */\n  callTool(\n    params: CallToolRequest[\"params\"] & { serverId: string },\n    resultSchema?:\n      | typeof CallToolResultSchema\n      | typeof CompatibilityCallToolResultSchema,\n    options?: RequestOptions\n  ) {\n    const unqualifiedName = params.name.replace(`${params.serverId}.`, \"\");\n    return this.mcpConnections[params.serverId].client.callTool(\n      {\n        ...params,\n        name: unqualifiedName,\n      },\n      resultSchema,\n      options\n    );\n  }\n\n  /**\n   * Namespaced version of readResource\n   */\n  readResource(\n    params: ReadResourceRequest[\"params\"] & { serverId: string },\n    options: RequestOptions\n  ) {\n    return this.mcpConnections[params.serverId].client.readResource(\n      params,\n      options\n    );\n  }\n\n  /**\n   * Namespaced version of getPrompt\n   */\n  getPrompt(\n    params: GetPromptRequest[\"params\"] & { serverId: string },\n    options: RequestOptions\n  ) {\n    return this.mcpConnections[params.serverId].client.getPrompt(\n      params,\n      options\n    );\n  }\n}\n\ntype NamespacedData = {\n  tools: (Tool & { serverId: string })[];\n  prompts: (Prompt & { serverId: string })[];\n  resources: (Resource & { serverId: string })[];\n  resourceTemplates: (ResourceTemplate & { serverId: string })[];\n};\n\nexport function getNamespacedData<T extends keyof NamespacedData>(\n  mcpClients: Record<string, MCPClientConnection>,\n  type: T\n): NamespacedData[T] {\n  const sets = Object.entries(mcpClients).map(([name, conn]) => {\n    return { name, data: conn[type] };\n  });\n\n  const namespacedData = sets.flatMap(({ name: serverId, data }) => {\n    return data.map((item) => {\n      return {\n        ...item,\n        // we add a serverId so we can easily pull it out and send the tool call to the right server\n        serverId,\n      };\n    });\n  });\n\n  return namespacedData as NamespacedData[T]; // Type assertion needed due to TS limitations with conditional return types\n}\n", "import type { OAuthClientProvider } from \"@modelcontextprotocol/sdk/client/auth.js\";\nimport type {\n  OAuthTokens,\n  OAuthClientMetadata,\n  OAuthClientInformation,\n  OAuthClientInformationFull,\n} from \"@modelcontextprotocol/sdk/shared/auth.js\";\n\n// A slight extension to the standard OAuthClientProvider interface because `redirectToAuthorization` doesn't give us the interface we need\n// This allows us to track authentication for a specific server and associated dynamic client registration\nexport interface AgentsOAuthProvider extends OAuthClientProvider {\n  authUrl: string | undefined;\n  clientId: string | undefined;\n  serverId: string | undefined;\n}\n\nexport class DurableObjectOAuthClientProvider implements AgentsOAuthProvider {\n  private _authUrl_: string | undefined;\n  private _serverId_: string | undefined;\n  private _clientId_: string | undefined;\n\n  constructor(\n    public storage: DurableObjectStorage,\n    public clientName: string,\n    public baseRedirectUrl: string\n  ) {}\n\n  get clientMetadata(): OAuthClientMetadata {\n    return {\n      redirect_uris: [this.redirectUrl],\n      token_endpoint_auth_method: \"none\",\n      grant_types: [\"authorization_code\", \"refresh_token\"],\n      response_types: [\"code\"],\n      client_name: this.clientName,\n      client_uri: \"example.com\",\n    };\n  }\n\n  get redirectUrl() {\n    return `${this.baseRedirectUrl}/${this.serverId}`;\n  }\n\n  get clientId() {\n    if (!this._clientId_) {\n      throw new Error(\"Trying to access clientId before it was set\");\n    }\n    return this._clientId_;\n  }\n\n  set clientId(clientId_: string) {\n    this._clientId_ = clientId_;\n  }\n\n  get serverId() {\n    if (!this._serverId_) {\n      throw new Error(\"Trying to access serverId before it was set\");\n    }\n    return this._serverId_;\n  }\n\n  set serverId(serverId_: string) {\n    this._serverId_ = serverId_;\n  }\n\n  keyPrefix(clientId: string) {\n    return `/${this.clientName}/${this.serverId}/${clientId}`;\n  }\n\n  clientInfoKey(clientId: string) {\n    return `${this.keyPrefix(clientId)}/client_info/`;\n  }\n\n  async clientInformation(): Promise<OAuthClientInformation | undefined> {\n    if (!this._clientId_) {\n      return undefined;\n    }\n    return (\n      (await this.storage.get<OAuthClientInformation>(\n        this.clientInfoKey(this.clientId)\n      )) ?? undefined\n    );\n  }\n\n  async saveClientInformation(\n    clientInformation: OAuthClientInformationFull\n  ): Promise<void> {\n    await this.storage.put(\n      this.clientInfoKey(clientInformation.client_id),\n      clientInformation\n    );\n    this.clientId = clientInformation.client_id;\n  }\n\n  tokenKey(clientId: string) {\n    return `${this.keyPrefix(clientId)}/token`;\n  }\n\n  async tokens(): Promise<OAuthTokens | undefined> {\n    if (!this._clientId_) {\n      return undefined;\n    }\n    return (\n      (await this.storage.get<OAuthTokens>(this.tokenKey(this.clientId))) ??\n      undefined\n    );\n  }\n\n  async saveTokens(tokens: OAuthTokens): Promise<void> {\n    await this.storage.put(this.tokenKey(this.clientId), tokens);\n  }\n\n  get authUrl() {\n    return this._authUrl_;\n  }\n\n  /**\n   * Because this operates on the server side (but we need browser auth), we send this url back to the user\n   * and require user interact to initiate the redirect flow\n   */\n  async redirectToAuthorization(authUrl: URL): Promise<void> {\n    // We want to track the client ID in state here because the typescript SSE client sometimes does\n    // a dynamic client registration AFTER generating this redirect URL.\n    const client_id = authUrl.searchParams.get(\"client_id\");\n    if (client_id) {\n      authUrl.searchParams.append(\"state\", client_id);\n    }\n    this._authUrl_ = authUrl.toString();\n  }\n\n  codeVerifierKey(clientId: string) {\n    return `${this.keyPrefix(clientId)}/code_verifier`;\n  }\n\n  async saveCodeVerifier(verifier: string): Promise<void> {\n    await this.storage.put(this.codeVerifierKey(this.clientId), verifier);\n  }\n\n  async codeVerifier(): Promise<string> {\n    const codeVerifier = await this.storage.get<string>(\n      this.codeVerifierKey(this.clientId)\n    );\n    if (!codeVerifier) {\n      throw new Error(\"No code verifier found\");\n    }\n    return codeVerifier;\n  }\n}\n", "import { PartySocket } from \"./chunk-YAFTF3NH.mjs\";\nimport { ReconnectingWebSocket } from \"./chunk-ZCZZNAX5.mjs\";\nexport {\n  PartySocket,\n  ReconnectingWebSocket as WebSocket,\n  PartySocket as default\n};\n//# sourceMappingURL=index.mjs.map\n", "// TODO: lose this eslint-disable\n\n/*!\n * Reconnecting WebSocket\n * by Pedro Ladaria <pedro.ladaria@gmail.com>\n * https://github.com/pladaria/reconnecting-websocket\n * License MIT\n */\n\nimport type { TypedEventTarget } from \"./type-helper\";\n\nif (!globalThis.EventTarget || !globalThis.Event) {\n  console.error(`\n  PartySocket requires a global 'EventTarget' class to be available!\n  You can polyfill this global by adding this to your code before any partysocket imports: \n  \n  \\`\\`\\`\n  import 'partysocket/event-target-polyfill';\n  \\`\\`\\`\n  Please file an issue at https://github.com/partykit/partykit if you're still having trouble.\n`);\n}\n\nexport class ErrorEvent extends Event {\n  public message: string;\n  public error: Error;\n  // biome-ignore lint/suspicious/noExplicitAny: vibes\n  constructor(error: Error, target: any) {\n    super(\"error\", target);\n    this.message = error.message;\n    this.error = error;\n  }\n}\n\nexport class CloseEvent extends Event {\n  public code: number;\n  public reason: string;\n  public wasClean = true;\n  // biome-ignore lint/style/useDefaultParameterLast: legacy\n  // biome-ignore lint/suspicious/noExplicitAny: legacy\n  constructor(code = 1000, reason = \"\", target: any) {\n    super(\"close\", target);\n    this.code = code;\n    this.reason = reason;\n  }\n}\nexport interface WebSocketEventMap {\n  close: CloseEvent;\n  error: ErrorEvent;\n  message: MessageEvent;\n  open: Event;\n}\n\nconst Events = {\n  Event,\n  ErrorEvent,\n  CloseEvent\n};\n\nfunction assert(condition: unknown, msg?: string): asserts condition {\n  if (!condition) {\n    throw new Error(msg);\n  }\n}\n\nfunction cloneEventBrowser(e: Event) {\n  // biome-ignore lint/suspicious/noExplicitAny: legacy\n  return new (e as any).constructor(e.type, e) as Event;\n}\n\nfunction cloneEventNode(e: Event) {\n  if (\"data\" in e) {\n    const evt = new MessageEvent(e.type, e);\n    return evt;\n  }\n\n  if (\"code\" in e || \"reason\" in e) {\n    const evt = new CloseEvent(\n      // @ts-expect-error we need to fix event/listener types\n      (e.code || 1999) as number,\n      // @ts-expect-error we need to fix event/listener types\n      (e.reason || \"unknown reason\") as string,\n      e\n    );\n    return evt;\n  }\n\n  if (\"error\" in e) {\n    const evt = new ErrorEvent(e.error as Error, e);\n    return evt;\n  }\n\n  const evt = new Event(e.type, e);\n  return evt;\n}\n\nconst isNode =\n  typeof process !== \"undefined\" &&\n  typeof process.versions?.node !== \"undefined\" &&\n  typeof document === \"undefined\";\n\nconst cloneEvent = isNode ? cloneEventNode : cloneEventBrowser;\n\nexport type Options = {\n  // biome-ignore lint/suspicious/noExplicitAny: legacy\n  WebSocket?: any;\n  maxReconnectionDelay?: number;\n  minReconnectionDelay?: number;\n  reconnectionDelayGrowFactor?: number;\n  minUptime?: number;\n  connectionTimeout?: number;\n  maxRetries?: number;\n  maxEnqueuedMessages?: number;\n  startClosed?: boolean;\n  debug?: boolean;\n  // biome-ignore lint/suspicious/noExplicitAny: legacy\n  debugLogger?: (...args: any[]) => void;\n};\n\nconst DEFAULT = {\n  maxReconnectionDelay: 10000,\n  minReconnectionDelay: 1000 + Math.random() * 4000,\n  minUptime: 5000,\n  reconnectionDelayGrowFactor: 1.3,\n  connectionTimeout: 4000,\n  maxRetries: Number.POSITIVE_INFINITY,\n  maxEnqueuedMessages: Number.POSITIVE_INFINITY,\n  startClosed: false,\n  debug: false\n};\n\nlet didWarnAboutMissingWebSocket = false;\n\nexport type UrlProvider = string | (() => string) | (() => Promise<string>);\nexport type ProtocolsProvider =\n  | null\n  | string\n  | string[]\n  | (() => string | string[] | null)\n  | (() => Promise<string | string[] | null>);\n\nexport type Message = string | ArrayBuffer | Blob | ArrayBufferView;\n\nexport default class ReconnectingWebSocket extends (EventTarget as TypedEventTarget<WebSocketEventMap>) {\n  private _ws: WebSocket | undefined;\n  private _retryCount = -1;\n  private _uptimeTimeout: ReturnType<typeof setTimeout> | undefined;\n  private _connectTimeout: ReturnType<typeof setTimeout> | undefined;\n  private _shouldReconnect = true;\n  private _connectLock = false;\n  private _binaryType: BinaryType = \"blob\";\n  private _closeCalled = false;\n  private _messageQueue: Message[] = [];\n\n  private _debugLogger = console.log.bind(console);\n\n  protected _url: UrlProvider;\n  protected _protocols?: ProtocolsProvider;\n  protected _options: Options;\n\n  constructor(\n    url: UrlProvider,\n    protocols?: ProtocolsProvider,\n    options: Options = {}\n  ) {\n    super();\n    this._url = url;\n    this._protocols = protocols;\n    this._options = options;\n    if (this._options.startClosed) {\n      this._shouldReconnect = false;\n    }\n    if (this._options.debugLogger) {\n      this._debugLogger = this._options.debugLogger;\n    }\n    this._connect();\n  }\n\n  static get CONNECTING() {\n    return 0;\n  }\n  static get OPEN() {\n    return 1;\n  }\n  static get CLOSING() {\n    return 2;\n  }\n  static get CLOSED() {\n    return 3;\n  }\n\n  get CONNECTING() {\n    return ReconnectingWebSocket.CONNECTING;\n  }\n  get OPEN() {\n    return ReconnectingWebSocket.OPEN;\n  }\n  get CLOSING() {\n    return ReconnectingWebSocket.CLOSING;\n  }\n  get CLOSED() {\n    return ReconnectingWebSocket.CLOSED;\n  }\n\n  get binaryType() {\n    return this._ws ? this._ws.binaryType : this._binaryType;\n  }\n\n  set binaryType(value: BinaryType) {\n    this._binaryType = value;\n    if (this._ws) {\n      this._ws.binaryType = value;\n    }\n  }\n\n  /**\n   * Returns the number or connection retries\n   */\n  get retryCount(): number {\n    return Math.max(this._retryCount, 0);\n  }\n\n  /**\n   * The number of bytes of data that have been queued using calls to send() but not yet\n   * transmitted to the network. This value resets to zero once all queued data has been sent.\n   * This value does not reset to zero when the connection is closed; if you keep calling send(),\n   * this will continue to climb. Read only\n   */\n  get bufferedAmount(): number {\n    const bytes = this._messageQueue.reduce((acc, message) => {\n      if (typeof message === \"string\") {\n        acc += message.length; // not byte size\n      } else if (message instanceof Blob) {\n        acc += message.size;\n      } else {\n        acc += message.byteLength;\n      }\n      return acc;\n    }, 0);\n    return bytes + (this._ws ? this._ws.bufferedAmount : 0);\n  }\n\n  /**\n   * The extensions selected by the server. This is currently only the empty string or a list of\n   * extensions as negotiated by the connection\n   */\n  get extensions(): string {\n    return this._ws ? this._ws.extensions : \"\";\n  }\n\n  /**\n   * A string indicating the name of the sub-protocol the server selected;\n   * this will be one of the strings specified in the protocols parameter when creating the\n   * WebSocket object\n   */\n  get protocol(): string {\n    return this._ws ? this._ws.protocol : \"\";\n  }\n\n  /**\n   * The current state of the connection; this is one of the Ready state constants\n   */\n  get readyState(): number {\n    if (this._ws) {\n      return this._ws.readyState;\n    }\n    return this._options.startClosed\n      ? ReconnectingWebSocket.CLOSED\n      : ReconnectingWebSocket.CONNECTING;\n  }\n\n  /**\n   * The URL as resolved by the constructor\n   */\n  get url(): string {\n    return this._ws ? this._ws.url : \"\";\n  }\n\n  /**\n   * Whether the websocket object is now in reconnectable state\n   */\n  get shouldReconnect(): boolean {\n    return this._shouldReconnect;\n  }\n\n  /**\n   * An event listener to be called when the WebSocket connection's readyState changes to CLOSED\n   */\n  public onclose: ((event: CloseEvent) => void) | null = null;\n\n  /**\n   * An event listener to be called when an error occurs\n   */\n  public onerror: ((event: ErrorEvent) => void) | null = null;\n\n  /**\n   * An event listener to be called when a message is received from the server\n   */\n  public onmessage: ((event: MessageEvent) => void) | null = null;\n\n  /**\n   * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\n   * this indicates that the connection is ready to send and receive data\n   */\n  public onopen: ((event: Event) => void) | null = null;\n\n  /**\n   * Closes the WebSocket connection or connection attempt, if any. If the connection is already\n   * CLOSED, this method does nothing\n   */\n  public close(code = 1000, reason?: string) {\n    this._closeCalled = true;\n    this._shouldReconnect = false;\n    this._clearTimeouts();\n    if (!this._ws) {\n      this._debug(\"close enqueued: no ws instance\");\n      return;\n    }\n    if (this._ws.readyState === this.CLOSED) {\n      this._debug(\"close: already closed\");\n      return;\n    }\n    this._ws.close(code, reason);\n  }\n\n  /**\n   * Closes the WebSocket connection or connection attempt and connects again.\n   * Resets retry counter;\n   */\n  public reconnect(code?: number, reason?: string) {\n    this._shouldReconnect = true;\n    this._closeCalled = false;\n    this._retryCount = -1;\n    if (!this._ws || this._ws.readyState === this.CLOSED) {\n      this._connect();\n    } else {\n      this._disconnect(code, reason);\n      this._connect();\n    }\n  }\n\n  /**\n   * Enqueue specified data to be transmitted to the server over the WebSocket connection\n   */\n  public send(data: Message) {\n    if (this._ws && this._ws.readyState === this.OPEN) {\n      this._debug(\"send\", data);\n      this._ws.send(data);\n    } else {\n      const { maxEnqueuedMessages = DEFAULT.maxEnqueuedMessages } =\n        this._options;\n      if (this._messageQueue.length < maxEnqueuedMessages) {\n        this._debug(\"enqueue\", data);\n        this._messageQueue.push(data);\n      }\n    }\n  }\n\n  private _debug(...args: unknown[]) {\n    if (this._options.debug) {\n      this._debugLogger(\"RWS>\", ...args);\n    }\n  }\n\n  private _getNextDelay() {\n    const {\n      reconnectionDelayGrowFactor = DEFAULT.reconnectionDelayGrowFactor,\n      minReconnectionDelay = DEFAULT.minReconnectionDelay,\n      maxReconnectionDelay = DEFAULT.maxReconnectionDelay\n    } = this._options;\n    let delay = 0;\n    if (this._retryCount > 0) {\n      delay =\n        minReconnectionDelay *\n        reconnectionDelayGrowFactor ** (this._retryCount - 1);\n      if (delay > maxReconnectionDelay) {\n        delay = maxReconnectionDelay;\n      }\n    }\n    this._debug(\"next delay\", delay);\n    return delay;\n  }\n\n  private _wait(): Promise<void> {\n    return new Promise((resolve) => {\n      setTimeout(resolve, this._getNextDelay());\n    });\n  }\n\n  private _getNextProtocols(\n    protocolsProvider: ProtocolsProvider | null\n  ): Promise<string | string[] | null> {\n    if (!protocolsProvider) return Promise.resolve(null);\n\n    if (\n      typeof protocolsProvider === \"string\" ||\n      Array.isArray(protocolsProvider)\n    ) {\n      return Promise.resolve(protocolsProvider);\n    }\n\n    if (typeof protocolsProvider === \"function\") {\n      const protocols = protocolsProvider();\n      if (!protocols) return Promise.resolve(null);\n\n      if (typeof protocols === \"string\" || Array.isArray(protocols)) {\n        return Promise.resolve(protocols);\n      }\n\n      // @ts-expect-error redundant check\n      if (protocols.then) {\n        return protocols;\n      }\n    }\n\n    throw Error(\"Invalid protocols\");\n  }\n\n  private _getNextUrl(urlProvider: UrlProvider): Promise<string> {\n    if (typeof urlProvider === \"string\") {\n      return Promise.resolve(urlProvider);\n    }\n    if (typeof urlProvider === \"function\") {\n      const url = urlProvider();\n      if (typeof url === \"string\") {\n        return Promise.resolve(url);\n      }\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      if (url.then) {\n        return url;\n      }\n\n      // return url;\n    }\n    throw Error(\"Invalid URL\");\n  }\n\n  private _connect() {\n    if (this._connectLock || !this._shouldReconnect) {\n      return;\n    }\n    this._connectLock = true;\n\n    const {\n      maxRetries = DEFAULT.maxRetries,\n      connectionTimeout = DEFAULT.connectionTimeout\n    } = this._options;\n\n    if (this._retryCount >= maxRetries) {\n      this._debug(\"max retries reached\", this._retryCount, \">=\", maxRetries);\n      return;\n    }\n\n    this._retryCount++;\n\n    this._debug(\"connect\", this._retryCount);\n    this._removeListeners();\n\n    this._wait()\n      .then(() =>\n        Promise.all([\n          this._getNextUrl(this._url),\n          this._getNextProtocols(this._protocols || null)\n        ])\n      )\n      .then(([url, protocols]) => {\n        // close could be called before creating the ws\n        if (this._closeCalled) {\n          this._connectLock = false;\n          return;\n        }\n        if (\n          !this._options.WebSocket &&\n          typeof WebSocket === \"undefined\" &&\n          !didWarnAboutMissingWebSocket\n        ) {\n          console.error(`‼️ No WebSocket implementation available. You should define options.WebSocket. \n\nFor example, if you're using node.js, run \\`npm install ws\\`, and then in your code:\n\nimport PartySocket from 'partysocket';\nimport WS from 'ws';\n\nconst partysocket = new PartySocket({\n  host: \"127.0.0.1:1999\",\n  room: \"test-room\",\n  WebSocket: WS\n});\n\n`);\n          didWarnAboutMissingWebSocket = true;\n        }\n        const WS: typeof WebSocket = this._options.WebSocket || WebSocket;\n        this._debug(\"connect\", { url, protocols });\n        this._ws = protocols ? new WS(url, protocols) : new WS(url);\n\n        this._ws.binaryType = this._binaryType;\n        this._connectLock = false;\n        this._addListeners();\n\n        this._connectTimeout = setTimeout(\n          () => this._handleTimeout(),\n          connectionTimeout\n        );\n      })\n      // via https://github.com/pladaria/reconnecting-websocket/pull/166\n      .catch((err) => {\n        this._connectLock = false;\n        this._handleError(new Events.ErrorEvent(Error(err.message), this));\n      });\n  }\n\n  private _handleTimeout() {\n    this._debug(\"timeout event\");\n    this._handleError(new Events.ErrorEvent(Error(\"TIMEOUT\"), this));\n  }\n\n  private _disconnect(code = 1000, reason?: string) {\n    this._clearTimeouts();\n    if (!this._ws) {\n      return;\n    }\n    this._removeListeners();\n    try {\n      if (\n        this._ws.readyState === this.OPEN ||\n        this._ws.readyState === this.CONNECTING\n      ) {\n        this._ws.close(code, reason);\n      }\n      this._handleClose(new Events.CloseEvent(code, reason, this));\n    } catch (error) {\n      // ignore\n    }\n  }\n\n  private _acceptOpen() {\n    this._debug(\"accept open\");\n    this._retryCount = 0;\n  }\n\n  private _handleOpen = (event: Event) => {\n    this._debug(\"open event\");\n    const { minUptime = DEFAULT.minUptime } = this._options;\n\n    clearTimeout(this._connectTimeout);\n    this._uptimeTimeout = setTimeout(() => this._acceptOpen(), minUptime);\n\n    assert(this._ws, \"WebSocket is not defined\");\n\n    this._ws.binaryType = this._binaryType;\n\n    // send enqueued messages (messages sent before websocket open event)\n    this._messageQueue.forEach((message) => this._ws?.send(message));\n    this._messageQueue = [];\n\n    if (this.onopen) {\n      this.onopen(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n\n  private _handleMessage = (event: MessageEvent) => {\n    this._debug(\"message event\");\n\n    if (this.onmessage) {\n      this.onmessage(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n\n  private _handleError = (event: ErrorEvent) => {\n    this._debug(\"error event\", event.message);\n    this._disconnect(\n      undefined,\n      event.message === \"TIMEOUT\" ? \"timeout\" : undefined\n    );\n\n    if (this.onerror) {\n      this.onerror(event);\n    }\n    this._debug(\"exec error listeners\");\n    this.dispatchEvent(cloneEvent(event));\n\n    this._connect();\n  };\n\n  private _handleClose = (event: CloseEvent) => {\n    this._debug(\"close event\");\n    this._clearTimeouts();\n\n    if (this._shouldReconnect) {\n      this._connect();\n    }\n\n    if (this.onclose) {\n      this.onclose(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n\n  private _removeListeners() {\n    if (!this._ws) {\n      return;\n    }\n    this._debug(\"removeListeners\");\n    this._ws.removeEventListener(\"open\", this._handleOpen);\n    this._ws.removeEventListener(\"close\", this._handleClose);\n    this._ws.removeEventListener(\"message\", this._handleMessage);\n    // @ts-expect-error we need to fix event/listerner types\n    this._ws.removeEventListener(\"error\", this._handleError);\n  }\n\n  private _addListeners() {\n    if (!this._ws) {\n      return;\n    }\n    this._debug(\"addListeners\");\n    this._ws.addEventListener(\"open\", this._handleOpen);\n    this._ws.addEventListener(\"close\", this._handleClose);\n    this._ws.addEventListener(\"message\", this._handleMessage);\n    // @ts-expect-error we need to fix event/listener types\n    this._ws.addEventListener(\"error\", this._handleError);\n  }\n\n  private _clearTimeouts() {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._uptimeTimeout);\n  }\n}\n", "import {\n  PartySocket,\n  type PartySocketOptions,\n  type PartyFetchOptions,\n} from \"partysocket\";\nimport type { RPCRequest, RPCResponse } from \"./\";\nimport type {\n  SerializableReturnValue,\n  SerializableValue,\n} from \"./serializable\";\n\n/**\n * Options for creating an AgentClient\n */\nexport type AgentClientOptions<State = unknown> = Omit<\n  PartySocketOptions,\n  \"party\" | \"room\"\n> & {\n  /** Name of the agent to connect to */\n  agent: string;\n  /** Name of the specific Agent instance */\n  name?: string;\n  /** Called when the Agent's state is updated */\n  onStateUpdate?: (state: State, source: \"server\" | \"client\") => void;\n};\n\n/**\n * Options for streaming RPC calls\n */\nexport type StreamOptions = {\n  /** Called when a chunk of data is received */\n  onChunk?: (chunk: unknown) => void;\n  /** Called when the stream ends */\n  onDone?: (finalChunk: unknown) => void;\n  /** Called when an error occurs */\n  onError?: (error: string) => void;\n};\n\n/**\n * Options for the agentFetch function\n */\nexport type AgentClientFetchOptions = Omit<\n  PartyFetchOptions,\n  \"party\" | \"room\"\n> & {\n  /** Name of the agent to connect to */\n  agent: string;\n  /** Name of the specific Agent instance */\n  name?: string;\n};\n\n/**\n * Convert a camelCase string to a kebab-case string\n * @param str The string to convert\n * @returns The kebab-case string\n */\nexport function camelCaseToKebabCase(str: string): string {\n  // If string is all uppercase, convert to lowercase\n  if (str === str.toUpperCase() && str !== str.toLowerCase()) {\n    return str.toLowerCase().replace(/_/g, \"-\");\n  }\n\n  // Otherwise handle camelCase to kebab-case\n  let kebabified = str.replace(\n    /[A-Z]/g,\n    (letter) => `-${letter.toLowerCase()}`\n  );\n  kebabified = kebabified.startsWith(\"-\") ? kebabified.slice(1) : kebabified;\n  // Convert any remaining underscores to hyphens and remove trailing -'s\n  return kebabified.replace(/_/g, \"-\").replace(/-$/, \"\");\n}\n\n/**\n * WebSocket client for connecting to an Agent\n */\nexport class AgentClient<State = unknown> extends PartySocket {\n  /**\n   * @deprecated Use agentFetch instead\n   */\n  static fetch(_opts: PartyFetchOptions): Promise<Response> {\n    throw new Error(\n      \"AgentClient.fetch is not implemented, use agentFetch instead\"\n    );\n  }\n  agent: string;\n  name: string;\n  private options: AgentClientOptions<State>;\n  private _pendingCalls = new Map<\n    string,\n    {\n      resolve: (value: unknown) => void;\n      reject: (error: Error) => void;\n      stream?: StreamOptions;\n      type?: unknown;\n    }\n  >();\n\n  constructor(options: AgentClientOptions<State>) {\n    const agentNamespace = camelCaseToKebabCase(options.agent);\n    super({\n      prefix: \"agents\",\n      party: agentNamespace,\n      room: options.name || \"default\",\n      ...options,\n    });\n    this.agent = agentNamespace;\n    this.name = options.name || \"default\";\n    this.options = options;\n\n    this.addEventListener(\"message\", (event) => {\n      if (typeof event.data === \"string\") {\n        let parsedMessage: Record<string, unknown>;\n        try {\n          parsedMessage = JSON.parse(event.data);\n        } catch (error) {\n          // silently ignore invalid messages for now\n          // TODO: log errors with log levels\n          return;\n        }\n        if (parsedMessage.type === \"cf_agent_state\") {\n          this.options.onStateUpdate?.(parsedMessage.state as State, \"server\");\n          return;\n        }\n        if (parsedMessage.type === \"rpc\") {\n          const response = parsedMessage as RPCResponse;\n          const pending = this._pendingCalls.get(response.id);\n          if (!pending) return;\n\n          if (!response.success) {\n            pending.reject(new Error(response.error));\n            this._pendingCalls.delete(response.id);\n            pending.stream?.onError?.(response.error);\n            return;\n          }\n\n          // Handle streaming responses\n          if (\"done\" in response) {\n            if (response.done) {\n              pending.resolve(response.result);\n              this._pendingCalls.delete(response.id);\n              pending.stream?.onDone?.(response.result);\n            } else {\n              pending.stream?.onChunk?.(response.result);\n            }\n          } else {\n            // Non-streaming response\n            pending.resolve(response.result);\n            this._pendingCalls.delete(response.id);\n          }\n        }\n      }\n    });\n  }\n\n  setState(state: State) {\n    this.send(JSON.stringify({ type: \"cf_agent_state\", state }));\n    this.options.onStateUpdate?.(state, \"client\");\n  }\n\n  /**\n   * Call a method on the Agent\n   * @param method Name of the method to call\n   * @param args Arguments to pass to the method\n   * @param streamOptions Options for handling streaming responses\n   * @returns Promise that resolves with the method's return value\n   */\n  call<T extends SerializableReturnValue>(\n    method: string,\n    args?: SerializableValue[],\n    streamOptions?: StreamOptions\n  ): Promise<T>;\n  call<T = unknown>(\n    method: string,\n    args?: unknown[],\n    streamOptions?: StreamOptions\n  ): Promise<T>;\n  async call<T>(\n    method: string,\n    args: unknown[] = [],\n    streamOptions?: StreamOptions\n  ): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      const id = Math.random().toString(36).slice(2);\n      this._pendingCalls.set(id, {\n        resolve: (value: unknown) => resolve(value as T),\n        reject,\n        stream: streamOptions,\n        type: null as T,\n      });\n\n      const request: RPCRequest = {\n        type: \"rpc\",\n        id,\n        method,\n        args,\n      };\n\n      this.send(JSON.stringify(request));\n    });\n  }\n}\n\n/**\n * Make an HTTP request to an Agent\n * @param opts Connection options\n * @param init Request initialization options\n * @returns Promise resolving to a Response\n */\nexport function agentFetch(opts: AgentClientFetchOptions, init?: RequestInit) {\n  const agentNamespace = camelCaseToKebabCase(opts.agent);\n\n  return PartySocket.fetch(\n    {\n      prefix: \"agents\",\n      party: agentNamespace,\n      room: opts.name || \"default\",\n      ...opts,\n    },\n    init\n  );\n}\n", "// rethink error handling, how to pass it on to the client\n// rethink oBC/oBR\n// push for durable.setState (in addition to connection.setState)\n\nimport { DurableObject } from \"cloudflare:workers\";\nimport { nanoid } from \"nanoid\";\n\nimport {\n  createLazyConnection,\n  HibernatingConnectionManager,\n  InMemoryConnectionManager\n} from \"./connection\";\n\nimport type { ConnectionManager } from \"./connection\";\nimport type {\n  Connection,\n  ConnectionContext,\n  ConnectionSetStateFn,\n  ConnectionState\n} from \"./types\";\n\nexport * from \"./types\";\n\nexport type WSMessage = ArrayBuffer | ArrayBufferView | string;\n\n// Let's cache the server namespace map\n// so we don't call it on every request\nconst serverMapCache = new WeakMap<\n  Record<string, unknown>,\n  Record<string, DurableObjectNamespace>\n>();\n\n/**\n * For a given server namespace, create a server with a name.\n */\nexport async function getServerByName<Env, T extends Server<Env>>(\n  serverNamespace: DurableObjectNamespace<T>,\n  name: string,\n  options?: {\n    jurisdiction?: DurableObjectJurisdiction;\n    locationHint?: DurableObjectLocationHint;\n  }\n): Promise<DurableObjectStub<T>> {\n  if (options?.jurisdiction) {\n    serverNamespace = serverNamespace.jurisdiction(options.jurisdiction);\n  }\n\n  const id = serverNamespace.idFromName(name);\n  const stub = serverNamespace.get(id, options);\n\n  // TODO: fix this to use RPC\n\n  const req = new Request(\n    \"http://dummy-example.cloudflare.com/cdn-cgi/partyserver/set-name/\"\n  );\n\n  req.headers.set(\"x-partykit-room\", name);\n\n  // unfortunately we have to await this\n  await stub.fetch(req).catch((e) => {\n    console.error(\"Could not set server name:\", e);\n  });\n\n  return stub;\n}\n\nfunction camelCaseToKebabCase(str: string): string {\n  // If string is all uppercase, convert to lowercase\n  if (str === str.toUpperCase() && str !== str.toLowerCase()) {\n    return str.toLowerCase().replace(/_/g, \"-\");\n  }\n\n  // Otherwise handle camelCase to kebab-case\n  let kebabified = str.replace(\n    /[A-Z]/g,\n    (letter) => `-${letter.toLowerCase()}`\n  );\n  kebabified = kebabified.startsWith(\"-\") ? kebabified.slice(1) : kebabified;\n  // Convert any remaining underscores to hyphens and remove trailing -'s\n  return kebabified.replace(/_/g, \"-\").replace(/-$/, \"\");\n}\nexport interface PartyServerOptions<Env> {\n  prefix?: string;\n  jurisdiction?: DurableObjectJurisdiction;\n  locationHint?: DurableObjectLocationHint;\n  onBeforeConnect?: (\n    req: Request,\n    lobby: {\n      party: keyof Env;\n      name: string;\n    }\n  ) => Response | Request | void | Promise<Response | Request | void>;\n  onBeforeRequest?: (\n    req: Request,\n    lobby: {\n      party: keyof Env;\n      name: string;\n    }\n  ) =>\n    | Response\n    | Request\n    | void\n    | Promise<Response | Request | undefined | void>;\n}\n/**\n * A utility function for PartyKit style routing.\n */\nexport async function routePartykitRequest<\n  Env = unknown,\n  T extends Server<Env> = Server<Env>\n>(\n  req: Request,\n  env: Record<string, unknown>,\n  options?: PartyServerOptions<typeof env>\n): Promise<Response | null> {\n  if (!serverMapCache.has(env)) {\n    serverMapCache.set(\n      env,\n      Object.entries(env).reduce((acc, [k, v]) => {\n        if (\n          v &&\n          typeof v === \"object\" &&\n          \"idFromName\" in v &&\n          typeof v.idFromName === \"function\"\n        ) {\n          Object.assign(acc, { [camelCaseToKebabCase(k)]: v });\n          return acc;\n        }\n        return acc;\n      }, {})\n    );\n  }\n  const map = serverMapCache.get(env) as unknown as Record<\n    string,\n    DurableObjectNamespace<T>\n  >;\n\n  const prefix = options?.prefix || \"parties\";\n  const prefixParts = prefix.split(\"/\");\n\n  const url = new URL(req.url);\n  const parts = url.pathname.split(\"/\").filter(Boolean); // Remove empty strings\n\n  // Check if the URL starts with the prefix\n  const prefixMatches = prefixParts.every(\n    (part, index) => parts[index] === part\n  );\n  if (!prefixMatches || parts.length < prefixParts.length + 2) {\n    return null;\n  }\n\n  const namespace = parts[prefixParts.length];\n  const name = parts[prefixParts.length + 1];\n\n  if (name && namespace) {\n    if (!map[namespace]) {\n      if (namespace === \"main\") {\n        console.warn(\n          \"You appear to be migrating a PartyKit project to PartyServer.\"\n        );\n        console.warn(`PartyServer doesn't have a \"main\" party by default. Try adding this to your PartySocket client:\\n \nparty: \"${camelCaseToKebabCase(Object.keys(map)[0])}\"`);\n      } else {\n        console.error(`The url ${req.url} does not match any server namespace. \nDid you forget to add a durable object binding to the class in your wrangler.toml?`);\n      }\n    }\n\n    let doNamespace = map[namespace];\n    if (options?.jurisdiction) {\n      doNamespace = doNamespace.jurisdiction(options.jurisdiction);\n    }\n\n    const id = doNamespace.idFromName(name);\n    const stub = doNamespace.get(id, options);\n\n    // const stub = await getServerByName(map[namespace], name, options); // TODO: fix this\n    // make a new request with additional headers\n\n    req = new Request(req);\n    req.headers.set(\"x-partykit-room\", name);\n    req.headers.set(\"x-partykit-namespace\", namespace);\n    if (options?.jurisdiction) {\n      req.headers.set(\"x-partykit-jurisdiction\", options.jurisdiction);\n    }\n\n    if (req.headers.get(\"Upgrade\")?.toLowerCase() === \"websocket\") {\n      if (options?.onBeforeConnect) {\n        const reqOrRes = await options.onBeforeConnect(req, {\n          party: namespace,\n          name\n        });\n        if (reqOrRes instanceof Request) {\n          req = reqOrRes;\n        } else if (reqOrRes instanceof Response) {\n          return reqOrRes;\n        }\n      }\n    } else {\n      if (options?.onBeforeRequest) {\n        const reqOrRes = await options.onBeforeRequest(req, {\n          party: namespace,\n          name\n        });\n        if (reqOrRes instanceof Request) {\n          req = reqOrRes;\n        } else if (reqOrRes instanceof Response) {\n          return reqOrRes;\n        }\n      }\n    }\n\n    return stub.fetch(req);\n  } else {\n    return null;\n  }\n}\n\nexport class Server<Env = unknown> extends DurableObject<Env> {\n  static options = {\n    hibernate: false\n  };\n\n  #status: \"zero\" | \"starting\" | \"started\" = \"zero\";\n\n  #ParentClass: typeof Server = Object.getPrototypeOf(this).constructor;\n\n  #connectionManager: ConnectionManager = this.#ParentClass.options.hibernate\n    ? new HibernatingConnectionManager(this.ctx)\n    : new InMemoryConnectionManager();\n\n  // biome-ignore lint/complexity/noUselessConstructor: <explanation>\n  constructor(ctx: DurableObjectState, env: Env) {\n    super(ctx, env);\n\n    // this.ctx\n    //   .blockConcurrencyWhile(async () => {\n    //     await this.#initialize();\n    //   })\n    //   .catch((e) => {\n    //     console.error(`Error while initilaizing ${this.#ParentClass.name}:`, e);\n    //   });\n\n    // TODO: throw error if any of\n    // broadcast/getConnection/getConnections/getConnectionTags\n    // fetch/webSocketMessage/webSocketClose/webSocketError/alarm\n    // have been overridden\n  }\n\n  /**\n   * Handle incoming requests to the server.\n   */\n  async fetch(request: Request): Promise<Response> {\n    if (!this.#_name) {\n      // This is temporary while we solve https://github.com/cloudflare/workerd/issues/2240\n\n      // get namespace and room from headers\n      // const namespace = request.headers.get(\"x-partykit-namespace\");\n      const room = request.headers.get(\"x-partykit-room\");\n      if (\n        // !namespace ||\n        !room\n      ) {\n        throw new Error(`Missing namespace or room headers when connecting to ${this.#ParentClass.name}.\nDid you try connecting directly to this Durable Object? Try using getServerByName(namespace, id) instead.`);\n      }\n      await this.setName(room);\n    }\n\n    try {\n      const url = new URL(request.url);\n\n      // TODO: this is a hack to set the server name,\n      // it'll be replaced with RPC later\n      if (url.pathname === \"/cdn-cgi/partyserver/set-name/\") {\n        // we can just return a 200 for now\n        return Response.json({ ok: true });\n      }\n\n      if (request.headers.get(\"Upgrade\")?.toLowerCase() !== \"websocket\") {\n        return await this.onRequest(request);\n      } else {\n        // Create the websocket pair for the client\n        const { 0: clientWebSocket, 1: serverWebSocket } = new WebSocketPair();\n        let connectionId = url.searchParams.get(\"_pk\");\n        if (!connectionId) {\n          connectionId = nanoid();\n        }\n\n        let connection: Connection = Object.assign(serverWebSocket, {\n          id: connectionId,\n          server: this.name,\n          state: null as unknown as ConnectionState<unknown>,\n          setState<T = unknown>(setState: T | ConnectionSetStateFn<T>) {\n            let state: T;\n            if (setState instanceof Function) {\n              state = setState(this.state as ConnectionState<T>);\n            } else {\n              state = setState;\n            }\n\n            // TODO: deepFreeze object?\n            this.state = state as ConnectionState<T>;\n            return this.state;\n          }\n        });\n\n        const ctx = { request };\n\n        const tags = await this.getConnectionTags(connection, ctx);\n\n        // Accept the websocket connection\n        connection = this.#connectionManager.accept(connection, {\n          tags,\n          server: this.name\n        });\n\n        if (!this.#ParentClass.options.hibernate) {\n          this.#attachSocketEventHandlers(connection);\n        }\n        await this.onConnect(connection, ctx);\n\n        return new Response(null, { status: 101, webSocket: clientWebSocket });\n      }\n    } catch (err) {\n      console.error(\n        `Error in ${this.#ParentClass.name}:${this.name} fetch:`,\n        err\n      );\n      if (!(err instanceof Error)) throw err;\n      if (request.headers.get(\"Upgrade\") === \"websocket\") {\n        // Annoyingly, if we return an HTTP error in response to a WebSocket request, Chrome devtools\n        // won't show us the response body! So... let's send a WebSocket response with an error\n        // frame instead.\n        const pair = new WebSocketPair();\n        pair[1].accept();\n        pair[1].send(JSON.stringify({ error: err.stack }));\n        pair[1].close(1011, \"Uncaught exception during session setup\");\n        return new Response(null, { status: 101, webSocket: pair[0] });\n      } else {\n        return new Response(err.stack, { status: 500 });\n      }\n    }\n  }\n\n  async webSocketMessage(ws: WebSocket, message: WSMessage): Promise<void> {\n    const connection = createLazyConnection(ws);\n\n    // rehydrate the server name if it's wiken up\n    await this.setName(connection.server);\n    // TODO: ^ this shouldn't be async\n\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n\n    return this.onMessage(connection, message);\n  }\n\n  async webSocketClose(\n    ws: WebSocket,\n    code: number,\n    reason: string,\n    wasClean: boolean\n  ): Promise<void> {\n    const connection = createLazyConnection(ws);\n\n    // rehydrate the server name if it's wiken up\n    await this.setName(connection.server);\n    // TODO: ^ this shouldn't be async\n\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n    return this.onClose(connection, code, reason, wasClean);\n  }\n\n  async webSocketError(ws: WebSocket, error: unknown): Promise<void> {\n    const connection = createLazyConnection(ws);\n\n    // rehydrate the server name if it's wiken up\n    await this.setName(connection.server);\n    // TODO: ^ this shouldn't be async\n\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n    return this.onError(connection, error);\n  }\n\n  async #initialize(): Promise<void> {\n    await this.ctx.blockConcurrencyWhile(async () => {\n      this.#status = \"starting\";\n      await this.onStart();\n      this.#status = \"started\";\n    });\n  }\n\n  #attachSocketEventHandlers(connection: Connection) {\n    const handleMessageFromClient = (event: MessageEvent) => {\n      this.onMessage(connection, event.data)?.catch<void>((e) => {\n        console.error(\"onMessage error:\", e);\n      });\n    };\n\n    const handleCloseFromClient = (event: CloseEvent) => {\n      connection.removeEventListener(\"message\", handleMessageFromClient);\n      connection.removeEventListener(\"close\", handleCloseFromClient);\n      this.onClose(connection, event.code, event.reason, event.wasClean)?.catch(\n        (e) => {\n          console.error(\"onClose error:\", e);\n        }\n      );\n    };\n\n    const handleErrorFromClient = (e: ErrorEvent) => {\n      connection.removeEventListener(\"message\", handleMessageFromClient);\n      connection.removeEventListener(\"error\", handleErrorFromClient);\n      this.onError(connection, e.error)?.catch((e) => {\n        console.error(\"onError error:\", e);\n      });\n    };\n\n    connection.addEventListener(\"close\", handleCloseFromClient);\n    connection.addEventListener(\"error\", handleErrorFromClient);\n    connection.addEventListener(\"message\", handleMessageFromClient);\n  }\n\n  // Public API\n\n  #_name: string | undefined;\n\n  #_longErrorAboutNameThrown = false;\n  /**\n   * The name for this server. Write-once-only.\n   */\n  get name(): string {\n    if (!this.#_name) {\n      if (!this.#_longErrorAboutNameThrown) {\n        this.#_longErrorAboutNameThrown = true;\n        throw new Error(\n          `Attempting to read .name on ${this.#ParentClass.name} before it was set. The name can be set by explicitly calling .setName(name) on the stub, or by using routePartyKitRequest(). This is a known issue and will be fixed soon. Follow https://github.com/cloudflare/workerd/issues/2240 for more updates.`\n        );\n      } else {\n        throw new Error(\n          `Attempting to read .name on ${this.#ParentClass.name} before it was set.`\n        );\n      }\n    }\n    return this.#_name;\n  }\n\n  // We won't have an await inside this function\n  // but it will be called remotely,\n  // so we need to mark it as async\n  async setName(name: string) {\n    if (!name) {\n      throw new Error(\"A name is required.\");\n    }\n    if (this.#_name && this.#_name !== name) {\n      throw new Error(\"This server already has a name.\");\n    }\n    this.#_name = name;\n\n    if (this.#status !== \"started\") {\n      await this.ctx.blockConcurrencyWhile(async () => {\n        await this.#initialize();\n      });\n    }\n  }\n\n  #sendMessageToConnection(connection: Connection, message: WSMessage): void {\n    try {\n      connection.send(message);\n    } catch (_e) {\n      // close connection\n      connection.close(1011, \"Unexpected error\");\n    }\n  }\n\n  /** Send a message to all connected clients, except connection ids listed in `without` */\n  broadcast(\n    msg: string | ArrayBuffer | ArrayBufferView,\n    without?: string[] | undefined\n  ): void {\n    for (const connection of this.#connectionManager.getConnections()) {\n      if (!without || !without.includes(connection.id)) {\n        this.#sendMessageToConnection(connection, msg);\n      }\n    }\n  }\n\n  /** Get a connection by connection id */\n  getConnection<TState = unknown>(id: string): Connection<TState> | undefined {\n    return this.#connectionManager.getConnection<TState>(id);\n  }\n\n  /**\n   * Get all connections. Optionally, you can provide a tag to filter returned connections.\n   * Use `Server#getConnectionTags` to tag the connection on connect.\n   */\n  getConnections<TState = unknown>(tag?: string): Iterable<Connection<TState>> {\n    return this.#connectionManager.getConnections<TState>(tag);\n  }\n\n  /**\n   * You can tag a connection to filter them in Server#getConnections.\n   * Each connection supports up to 9 tags, each tag max length is 256 characters.\n   */\n  getConnectionTags(\n    connection: Connection,\n    context: ConnectionContext\n  ): string[] | Promise<string[]> {\n    return [];\n  }\n\n  // Implemented by the user\n\n  /**\n   * Called when the server is started for the first time.\n   */\n  onStart(): void | Promise<void> {}\n\n  /**\n   * Called when a new connection is made to the server.\n   */\n  onConnect(\n    connection: Connection,\n    ctx: ConnectionContext\n  ): void | Promise<void> {\n    console.log(\n      `Connection ${connection.id} connected to ${this.#ParentClass.name}:${this.name}`\n    );\n    // console.log(\n    //   `Implement onConnect on ${this.#ParentClass.name} to handle websocket connections.`\n    // );\n  }\n\n  /**\n   * Called when a message is received from a connection.\n   */\n  onMessage(connection: Connection, message: WSMessage): void | Promise<void> {\n    console.log(\n      `Received message on connection ${this.#ParentClass.name}:${connection.id}`\n    );\n    console.info(\n      `Implement onMessage on ${this.#ParentClass.name} to handle this message.`\n    );\n  }\n\n  /**\n   * Called when a connection is closed.\n   */\n  onClose(\n    connection: Connection,\n    code: number,\n    reason: string,\n    wasClean: boolean\n  ): void | Promise<void> {}\n\n  /**\n   * Called when an error occurs on a connection.\n   */\n  onError(connection: Connection, error: unknown): void | Promise<void> {\n    console.error(\n      `Error on connection ${connection.id} in ${this.#ParentClass.name}:${this.name}:`,\n      error\n    );\n    console.info(\n      `Implement onError on ${this.#ParentClass.name} to handle this error.`\n    );\n  }\n\n  /**\n   * Called when a request is made to the server.\n   */\n  onRequest(request: Request): Response | Promise<Response> {\n    // default to 404\n\n    console.warn(\n      `onRequest hasn't been implemented on ${this.#ParentClass.name}:${this.name} responding to ${request.url}`\n    );\n\n    return new Response(\"Not implemented\", { status: 404 });\n  }\n\n  onAlarm(): void | Promise<void> {\n    console.log(\n      `Implement onAlarm on ${this.#ParentClass.name} to handle alarms.`\n    );\n  }\n\n  async alarm(): Promise<void> {\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n    await this.onAlarm();\n  }\n}\n", "// Polyfill WebSocket status code constants for environments that don't have them\n// in order to support libraries that expect standards-compatible WebSocket\n// implementations (e.g. PartySocket)\n\nimport type {\n  Connection,\n  ConnectionSetStateFn,\n  ConnectionState\n} from \"./types\";\n\nif (!(\"OPEN\" in WebSocket)) {\n  const WebSocketStatus = {\n    // @ts-expect-error\n    CONNECTING: WebSocket.READY_STATE_CONNECTING,\n    // @ts-expect-error\n    OPEN: WebSocket.READY_STATE_OPEN,\n    // @ts-expect-error\n    CLOSING: WebSocket.READY_STATE_CLOSING,\n    // @ts-expect-error\n    CLOSED: WebSocket.READY_STATE_CLOSED\n  };\n\n  Object.assign(WebSocket, WebSocketStatus);\n  // @ts-expect-error\n  Object.assign(WebSocket.prototype, WebSocketStatus);\n}\n\n/**\n * Store both platform attachments and user attachments in different namespaces\n */\ntype ConnectionAttachments = {\n  __pk: {\n    id: string;\n    // TODO: remove this once we have\n    // durable object level setState\n    server: string;\n  };\n  __user?: unknown;\n};\n\n/**\n * Cache websocket attachments to avoid having to rehydrate them on every property access.\n */\nclass AttachmentCache {\n  #cache = new WeakMap<WebSocket, ConnectionAttachments>();\n\n  get(ws: WebSocket): ConnectionAttachments {\n    let attachment = this.#cache.get(ws);\n    if (!attachment) {\n      attachment = WebSocket.prototype.deserializeAttachment.call(\n        ws\n      ) as ConnectionAttachments;\n      if (attachment !== undefined) {\n        this.#cache.set(ws, attachment);\n      } else {\n        throw new Error(\n          \"Missing websocket attachment. This is most likely an issue in PartyServer, please open an issue at https://github.com/threepointone/partyserver/issues\"\n        );\n      }\n    }\n\n    return attachment;\n  }\n\n  set(ws: WebSocket, attachment: ConnectionAttachments) {\n    this.#cache.set(ws, attachment);\n    WebSocket.prototype.serializeAttachment.call(ws, attachment);\n  }\n}\n\nconst attachments = new AttachmentCache();\nconst connections = new WeakSet<Connection>();\nconst isWrapped = (ws: WebSocket): ws is Connection => {\n  return connections.has(ws as Connection);\n};\n\n/**\n * Wraps a WebSocket with Connection fields that rehydrate the\n * socket attachments lazily only when requested.\n */\nexport const createLazyConnection = (\n  ws: WebSocket | Connection\n): Connection => {\n  if (isWrapped(ws)) {\n    return ws;\n  }\n\n  // if state was set on the socket before initializing the connection,\n  // capture it here so we can persist it again\n  let initialState = undefined;\n  if (\"state\" in ws) {\n    initialState = ws.state;\n    // biome-ignore lint/performance/noDelete: <explanation>\n    delete ws.state;\n  }\n\n  const connection = Object.defineProperties(ws, {\n    id: {\n      get() {\n        return attachments.get(ws).__pk.id;\n      }\n    },\n    server: {\n      get() {\n        return attachments.get(ws).__pk.server;\n      }\n    },\n    socket: {\n      get() {\n        return ws;\n      }\n    },\n    state: {\n      get() {\n        return ws.deserializeAttachment() as ConnectionState<unknown>;\n      }\n    },\n    setState: {\n      value: function setState<T>(setState: T | ConnectionSetStateFn<T>) {\n        let state: T;\n        if (setState instanceof Function) {\n          state = setState((this as Connection<T>).state);\n        } else {\n          state = setState;\n        }\n\n        ws.serializeAttachment(state);\n        return state as ConnectionState<T>;\n      }\n    },\n\n    deserializeAttachment: {\n      value: function deserializeAttachment<T = unknown>() {\n        const attachment = attachments.get(ws);\n        return (attachment.__user ?? null) as T;\n      }\n    },\n\n    serializeAttachment: {\n      value: function serializeAttachment<T = unknown>(attachment: T) {\n        const setting = {\n          ...attachments.get(ws),\n          __user: attachment ?? null\n        };\n\n        attachments.set(ws, setting);\n      }\n    }\n  }) as Connection;\n\n  if (initialState) {\n    connection.setState(initialState);\n  }\n\n  connections.add(connection);\n  return connection;\n};\n\nclass HibernatingConnectionIterator<T>\n  implements IterableIterator<Connection<T>>\n{\n  private index = 0;\n  private sockets: WebSocket[] | undefined;\n  constructor(\n    private state: DurableObjectState,\n    private tag?: string\n  ) {}\n\n  [Symbol.iterator](): IterableIterator<Connection<T>> {\n    return this;\n  }\n\n  next(): IteratorResult<Connection<T>, number | undefined> {\n    const sockets =\n      // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>\n      this.sockets ?? (this.sockets = this.state.getWebSockets(this.tag));\n\n    let socket: WebSocket;\n    // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>\n    while ((socket = sockets[this.index++])) {\n      // only yield open sockets to match non-hibernating behaviour\n      if (socket.readyState === WebSocket.READY_STATE_OPEN) {\n        const value = createLazyConnection(socket) as Connection<T>;\n        return { done: false, value };\n      }\n    }\n\n    // reached the end of the iteratee\n    return { done: true, value: undefined };\n  }\n}\n\nexport interface ConnectionManager {\n  getCount(): number;\n  getConnection<TState>(id: string): Connection<TState> | undefined;\n  getConnections<TState>(tag?: string): IterableIterator<Connection<TState>>;\n  accept(\n    connection: Connection,\n    options: { tags: string[]; server: string }\n  ): Connection;\n}\n\n/**\n * When not using hibernation, we track active connections manually.\n */\nexport class InMemoryConnectionManager<TState> implements ConnectionManager {\n  #connections: Map<string, Connection> = new Map();\n  tags: WeakMap<Connection, string[]> = new WeakMap();\n\n  getCount() {\n    return this.#connections.size;\n  }\n\n  getConnection<T = TState>(id: string) {\n    return this.#connections.get(id) as Connection<T> | undefined;\n  }\n\n  *getConnections<T = TState>(tag?: string): IterableIterator<Connection<T>> {\n    if (!tag) {\n      yield* this.#connections\n        .values()\n        .filter(\n          (c) => c.readyState === WebSocket.READY_STATE_OPEN\n        ) as IterableIterator<Connection<T>>;\n      return;\n    }\n\n    // simulate DurableObjectState.getWebSockets(tag) behaviour\n    for (const connection of this.#connections.values()) {\n      const connectionTags = this.tags.get(connection) ?? [];\n      if (connectionTags.includes(tag)) {\n        yield connection as Connection<T>;\n      }\n    }\n  }\n\n  accept(connection: Connection, options: { tags: string[]; server: string }) {\n    connection.accept();\n\n    this.#connections.set(connection.id, connection);\n    this.tags.set(connection, [\n      // make sure we have id tag\n      connection.id,\n      ...options.tags.filter((t) => t !== connection.id)\n    ]);\n\n    const removeConnection = () => {\n      this.#connections.delete(connection.id);\n      connection.removeEventListener(\"close\", removeConnection);\n      connection.removeEventListener(\"error\", removeConnection);\n    };\n    connection.addEventListener(\"close\", removeConnection);\n    connection.addEventListener(\"error\", removeConnection);\n\n    return connection;\n  }\n}\n\n/**\n * When opting into hibernation, the platform tracks connections for us.\n */\nexport class HibernatingConnectionManager<TState> implements ConnectionManager {\n  constructor(private controller: DurableObjectState) {}\n\n  getCount() {\n    return Number(this.controller.getWebSockets().length);\n  }\n\n  getConnection<T = TState>(id: string) {\n    // TODO: Should we cache the connections?\n    const sockets = this.controller.getWebSockets(id);\n    if (sockets.length === 0) return undefined;\n    if (sockets.length === 1)\n      return createLazyConnection(sockets[0]) as Connection<T>;\n\n    throw new Error(\n      `More than one connection found for id ${id}. Did you mean to use getConnections(tag) instead?`\n    );\n  }\n\n  getConnections<T = TState>(tag?: string | undefined) {\n    return new HibernatingConnectionIterator<T>(this.controller, tag);\n  }\n\n  accept(connection: Connection, options: { tags: string[]; server: string }) {\n    // dedupe tags in case user already provided id tag\n    const tags = [\n      connection.id,\n      ...options.tags.filter((t) => t !== connection.id)\n    ];\n\n    // validate tags against documented restrictions\n    // shttps://developers.cloudflare.com/durable-objects/api/hibernatable-websockets-api/#state-methods-for-websockets\n    if (tags.length > 10) {\n      throw new Error(\n        \"A connection can only have 10 tags, including the default id tag.\"\n      );\n    }\n\n    for (const tag of tags) {\n      if (typeof tag !== \"string\") {\n        throw new Error(`A connection tag must be a string. Received: ${tag}`);\n      }\n      if (tag === \"\") {\n        throw new Error(\"A connection tag must not be an empty string.\");\n      }\n      if (tag.length > 256) {\n        throw new Error(\"A connection tag must not exceed 256 characters\");\n      }\n    }\n\n    this.controller.acceptWebSocket(connection, tags);\n    connection.serializeAttachment({\n      __pk: {\n        id: connection.id,\n        server: options.server\n      },\n      __user: null\n    });\n\n    return createLazyConnection(connection);\n  }\n}\n", null, null, null, "import {\n  asyncWrapProviders,\n  createHook,\n  executionAsyncId,\n  executionAsyncResource,\n  triggerAsyncId\n} from \"unenv/node/async_hooks\";\nexport {\n  asyncWrapProviders,\n  createHook,\n  executionAsyncId,\n  executionAsyncResource,\n  triggerAsyncId\n} from \"unenv/node/async_hooks\";\nconst workerdAsyncHooks = process.getBuiltinModule(\"node:async_hooks\");\nexport const { AsyncLocalStorage, AsyncResource } = workerdAsyncHooks;\nexport default {\n  /**\n   * manually unroll unenv-polyfilled-symbols to make it tree-shakeable\n   */\n  asyncWrapProviders,\n  createHook,\n  executionAsyncId,\n  executionAsyncResource,\n  triggerAsyncId,\n  /**\n   * manually unroll workerd-polyfilled-symbols to make it tree-shakeable\n   */\n  AsyncLocalStorage,\n  AsyncResource\n};\n", "import {\n  Server,\n  getServerByName,\n  routePartykitRequest,\n  type Connection,\n  type ConnectionContext,\n  type PartyServerOptions,\n  type WSMessage,\n} from \"partyserver\";\n\nimport { parseCronExpression } from \"cron-schedule\";\nimport { nanoid } from \"nanoid\";\n\nimport type {\n  Prompt,\n  Resource,\n  ServerCapabilities,\n  Tool,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport { AsyncLocalStorage } from \"node:async_hooks\";\nimport { MCPClientManager } from \"./mcp/client\";\nimport { DurableObjectOAuthClientProvider } from \"./mcp/do-oauth-client-provider\";\n\nimport type { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport type { SSEClientTransportOptions } from \"@modelcontextprotocol/sdk/client/sse.js\";\n\nimport { camelCaseToKebabCase } from \"./client\";\nimport type { MCPClientConnection } from \"./mcp/client-connection\";\n\nexport type { Connection, ConnectionContext, WSMessage } from \"partyserver\";\n\n/**\n * RPC request message from client\n */\nexport type RPCRequest = {\n  type: \"rpc\";\n  id: string;\n  method: string;\n  args: unknown[];\n};\n\n/**\n * State update message from client\n */\nexport type StateUpdateMessage = {\n  type: \"cf_agent_state\";\n  state: unknown;\n};\n\n/**\n * RPC response message to client\n */\nexport type RPCResponse = {\n  type: \"rpc\";\n  id: string;\n} & (\n  | {\n      success: true;\n      result: unknown;\n      done?: false;\n    }\n  | {\n      success: true;\n      result: unknown;\n      done: true;\n    }\n  | {\n      success: false;\n      error: string;\n    }\n);\n\n/**\n * Type guard for RPC request messages\n */\nfunction isRPCRequest(msg: unknown): msg is RPCRequest {\n  return (\n    typeof msg === \"object\" &&\n    msg !== null &&\n    \"type\" in msg &&\n    msg.type === \"rpc\" &&\n    \"id\" in msg &&\n    typeof msg.id === \"string\" &&\n    \"method\" in msg &&\n    typeof msg.method === \"string\" &&\n    \"args\" in msg &&\n    Array.isArray((msg as RPCRequest).args)\n  );\n}\n\n/**\n * Type guard for state update messages\n */\nfunction isStateUpdateMessage(msg: unknown): msg is StateUpdateMessage {\n  return (\n    typeof msg === \"object\" &&\n    msg !== null &&\n    \"type\" in msg &&\n    msg.type === \"cf_agent_state\" &&\n    \"state\" in msg\n  );\n}\n\n/**\n * Metadata for a callable method\n */\nexport type CallableMetadata = {\n  /** Optional description of what the method does */\n  description?: string;\n  /** Whether the method supports streaming responses */\n  streaming?: boolean;\n};\n\nconst callableMetadata = new Map<Function, CallableMetadata>();\n\n/**\n * Decorator that marks a method as callable by clients\n * @param metadata Optional metadata about the callable method\n */\nexport function unstable_callable(metadata: CallableMetadata = {}) {\n  return function callableDecorator<This, Args extends unknown[], Return>(\n    target: (this: This, ...args: Args) => Return,\n    context: ClassMethodDecoratorContext\n  ) {\n    if (!callableMetadata.has(target)) {\n      callableMetadata.set(target, metadata);\n    }\n\n    return target;\n  };\n}\n\n/**\n * Represents a scheduled task within an Agent\n * @template T Type of the payload data\n */\nexport type Schedule<T = string> = {\n  /** Unique identifier for the schedule */\n  id: string;\n  /** Name of the method to be called */\n  callback: string;\n  /** Data to be passed to the callback */\n  payload: T;\n} & (\n  | {\n      /** Type of schedule for one-time execution at a specific time */\n      type: \"scheduled\";\n      /** Timestamp when the task should execute */\n      time: number;\n    }\n  | {\n      /** Type of schedule for delayed execution */\n      type: \"delayed\";\n      /** Timestamp when the task should execute */\n      time: number;\n      /** Number of seconds to delay execution */\n      delayInSeconds: number;\n    }\n  | {\n      /** Type of schedule for recurring execution based on cron expression */\n      type: \"cron\";\n      /** Timestamp for the next execution */\n      time: number;\n      /** Cron expression defining the schedule */\n      cron: string;\n    }\n);\n\nfunction getNextCronTime(cron: string) {\n  const interval = parseCronExpression(cron);\n  return interval.getNextDate();\n}\n\n/**\n * MCP Server state update message from server -> Client\n */\nexport type MCPServerMessage = {\n  type: \"cf_agent_mcp_servers\";\n  mcp: MCPServersState;\n};\n\nexport type MCPServersState = {\n  servers: {\n    [id: string]: MCPServer;\n  };\n  tools: Tool[];\n  prompts: Prompt[];\n  resources: Resource[];\n};\n\nexport type MCPServer = {\n  name: string;\n  server_url: string;\n  auth_url: string | null;\n  // This state is specifically about the temporary process of getting a token (if needed).\n  // Scope outside of that can't be relied upon because when the DO sleeps, there's no way\n  // to communicate a change to a non-ready state.\n  state: \"authenticating\" | \"connecting\" | \"ready\" | \"discovering\" | \"failed\";\n  instructions: string | null;\n  capabilities: ServerCapabilities | null;\n};\n\n/**\n * MCP Server data stored in DO SQL for resuming MCP Server connections\n */\ntype MCPServerRow = {\n  id: string;\n  name: string;\n  server_url: string;\n  client_id: string | null;\n  auth_url: string | null;\n  callback_url: string;\n  server_options: string;\n};\n\nconst STATE_ROW_ID = \"cf_state_row_id\";\nconst STATE_WAS_CHANGED = \"cf_state_was_changed\";\n\nconst DEFAULT_STATE = {} as unknown;\n\nconst agentContext = new AsyncLocalStorage<{\n  agent: Agent<unknown>;\n  connection: Connection | undefined;\n  request: Request | undefined;\n}>();\n\nexport function getCurrentAgent<\n  T extends Agent<unknown, unknown> = Agent<unknown, unknown>,\n>(): {\n  agent: T | undefined;\n  connection: Connection | undefined;\n  request: Request<unknown, CfProperties<unknown>> | undefined;\n} {\n  const store = agentContext.getStore() as\n    | {\n        agent: T;\n        connection: Connection | undefined;\n        request: Request<unknown, CfProperties<unknown>> | undefined;\n      }\n    | undefined;\n  if (!store) {\n    return {\n      agent: undefined,\n      connection: undefined,\n      request: undefined,\n    };\n  }\n  return store;\n}\n\n/**\n * Base class for creating Agent implementations\n * @template Env Environment type containing bindings\n * @template State State type to store within the Agent\n */\nexport class Agent<Env, State = unknown> extends Server<Env> {\n  private _state = DEFAULT_STATE as State;\n\n  private _ParentClass: typeof Agent<Env, State> =\n    Object.getPrototypeOf(this).constructor;\n\n  mcp: MCPClientManager = new MCPClientManager(this._ParentClass.name, \"0.0.1\");\n\n  /**\n   * Initial state for the Agent\n   * Override to provide default state values\n   */\n  initialState: State = DEFAULT_STATE as State;\n\n  /**\n   * Current state of the Agent\n   */\n  get state(): State {\n    if (this._state !== DEFAULT_STATE) {\n      // state was previously set, and populated internal state\n      return this._state;\n    }\n    // looks like this is the first time the state is being accessed\n    // check if the state was set in a previous life\n    const wasChanged = this.sql<{ state: \"true\" | undefined }>`\n        SELECT state FROM cf_agents_state WHERE id = ${STATE_WAS_CHANGED}\n      `;\n\n    // ok, let's pick up the actual state from the db\n    const result = this.sql<{ state: State | undefined }>`\n      SELECT state FROM cf_agents_state WHERE id = ${STATE_ROW_ID}\n    `;\n\n    if (\n      wasChanged[0]?.state === \"true\" ||\n      // we do this check for people who updated their code before we shipped wasChanged\n      result[0]?.state\n    ) {\n      const state = result[0]?.state as string; // could be null?\n\n      this._state = JSON.parse(state);\n      return this._state;\n    }\n\n    // ok, this is the first time the state is being accessed\n    // and the state was not set in a previous life\n    // so we need to set the initial state (if provided)\n    if (this.initialState === DEFAULT_STATE) {\n      // no initial state provided, so we return undefined\n      return undefined as State;\n    }\n    // initial state provided, so we set the state,\n    // update db and return the initial state\n    this.setState(this.initialState);\n    return this.initialState;\n  }\n\n  /**\n   * Agent configuration options\n   */\n  static options = {\n    /** Whether the Agent should hibernate when inactive */\n    hibernate: true, // default to hibernate\n  };\n\n  /**\n   * Execute SQL queries against the Agent's database\n   * @template T Type of the returned rows\n   * @param strings SQL query template strings\n   * @param values Values to be inserted into the query\n   * @returns Array of query results\n   */\n  sql<T = Record<string, string | number | boolean | null>>(\n    strings: TemplateStringsArray,\n    ...values: (string | number | boolean | null)[]\n  ) {\n    let query = \"\";\n    try {\n      // Construct the SQL query with placeholders\n      query = strings.reduce(\n        (acc, str, i) => acc + str + (i < values.length ? \"?\" : \"\"),\n        \"\"\n      );\n\n      // Execute the SQL query with the provided values\n      return [...this.ctx.storage.sql.exec(query, ...values)] as T[];\n    } catch (e) {\n      console.error(`failed to execute sql query: ${query}`, e);\n      throw this.onError(e);\n    }\n  }\n  constructor(ctx: AgentContext, env: Env) {\n    super(ctx, env);\n\n    this.sql`\n      CREATE TABLE IF NOT EXISTS cf_agents_state (\n        id TEXT PRIMARY KEY NOT NULL,\n        state TEXT\n      )\n    `;\n\n    void this.ctx.blockConcurrencyWhile(async () => {\n      return this._tryCatch(async () => {\n        // Create alarms table if it doesn't exist\n        this.sql`\n        CREATE TABLE IF NOT EXISTS cf_agents_schedules (\n          id TEXT PRIMARY KEY NOT NULL DEFAULT (randomblob(9)),\n          callback TEXT,\n          payload TEXT,\n          type TEXT NOT NULL CHECK(type IN ('scheduled', 'delayed', 'cron')),\n          time INTEGER,\n          delayInSeconds INTEGER,\n          cron TEXT,\n          created_at INTEGER DEFAULT (unixepoch())\n        )\n      `;\n\n        // execute any pending alarms and schedule the next alarm\n        await this.alarm();\n      });\n    });\n\n    this.sql`\n      CREATE TABLE IF NOT EXISTS cf_agents_mcp_servers (\n        id TEXT PRIMARY KEY NOT NULL,\n        name TEXT NOT NULL,\n        server_url TEXT NOT NULL,\n        callback_url TEXT NOT NULL,\n        client_id TEXT,\n        auth_url TEXT,\n        server_options TEXT\n      )\n    `;\n\n    const _onRequest = this.onRequest.bind(this);\n    this.onRequest = (request: Request) => {\n      return agentContext.run(\n        { agent: this, connection: undefined, request },\n        async () => {\n          if (this.mcp.isCallbackRequest(request)) {\n            await this.mcp.handleCallbackRequest(request);\n\n            // after the MCP connection handshake, we can send updated mcp state\n            this.broadcast(\n              JSON.stringify({\n                type: \"cf_agent_mcp_servers\",\n                mcp: this.getMcpServers(),\n              })\n            );\n\n            // We probably should let the user configure this response/redirect, but this is fine for now.\n            return new Response(\"<script>window.close();</script>\", {\n              status: 200,\n              headers: { \"content-type\": \"text/html\" },\n            });\n          }\n\n          return this._tryCatch(() => _onRequest(request));\n        }\n      );\n    };\n\n    const _onMessage = this.onMessage.bind(this);\n    this.onMessage = async (connection: Connection, message: WSMessage) => {\n      return agentContext.run(\n        { agent: this, connection, request: undefined },\n        async () => {\n          if (typeof message !== \"string\") {\n            return this._tryCatch(() => _onMessage(connection, message));\n          }\n\n          let parsed: unknown;\n          try {\n            parsed = JSON.parse(message);\n          } catch (e) {\n            // silently fail and let the onMessage handler handle it\n            return this._tryCatch(() => _onMessage(connection, message));\n          }\n\n          if (isStateUpdateMessage(parsed)) {\n            this._setStateInternal(parsed.state as State, connection);\n            return;\n          }\n\n          if (isRPCRequest(parsed)) {\n            try {\n              const { id, method, args } = parsed;\n\n              // Check if method exists and is callable\n              const methodFn = this[method as keyof this];\n              if (typeof methodFn !== \"function\") {\n                throw new Error(`Method ${method} does not exist`);\n              }\n\n              if (!this._isCallable(method)) {\n                throw new Error(`Method ${method} is not callable`);\n              }\n\n              const metadata = callableMetadata.get(methodFn as Function);\n\n              // For streaming methods, pass a StreamingResponse object\n              if (metadata?.streaming) {\n                const stream = new StreamingResponse(connection, id);\n                await methodFn.apply(this, [stream, ...args]);\n                return;\n              }\n\n              // For regular methods, execute and send response\n              const result = await methodFn.apply(this, args);\n              const response: RPCResponse = {\n                type: \"rpc\",\n                id,\n                success: true,\n                result,\n                done: true,\n              };\n              connection.send(JSON.stringify(response));\n            } catch (e) {\n              // Send error response\n              const response: RPCResponse = {\n                type: \"rpc\",\n                id: parsed.id,\n                success: false,\n                error:\n                  e instanceof Error ? e.message : \"Unknown error occurred\",\n              };\n              connection.send(JSON.stringify(response));\n              console.error(\"RPC error:\", e);\n            }\n            return;\n          }\n\n          return this._tryCatch(() => _onMessage(connection, message));\n        }\n      );\n    };\n\n    const _onConnect = this.onConnect.bind(this);\n    this.onConnect = (connection: Connection, ctx: ConnectionContext) => {\n      // TODO: This is a hack to ensure the state is sent after the connection is established\n      // must fix this\n      return agentContext.run(\n        { agent: this, connection, request: ctx.request },\n        async () => {\n          setTimeout(() => {\n            if (this.state) {\n              connection.send(\n                JSON.stringify({\n                  type: \"cf_agent_state\",\n                  state: this.state,\n                })\n              );\n            }\n\n            connection.send(\n              JSON.stringify({\n                type: \"cf_agent_mcp_servers\",\n                mcp: this.getMcpServers(),\n              })\n            );\n\n            return this._tryCatch(() => _onConnect(connection, ctx));\n          }, 20);\n        }\n      );\n    };\n\n    const _onStart = this.onStart.bind(this);\n    this.onStart = async () => {\n      return agentContext.run(\n        { agent: this, connection: undefined, request: undefined },\n        async () => {\n          const servers = this.sql<MCPServerRow>`\n            SELECT id, name, server_url, client_id, auth_url, callback_url, server_options FROM cf_agents_mcp_servers;\n          `;\n\n          // from DO storage, reconnect to all servers not currently in the oauth flow using our saved auth information\n          await Promise.allSettled(\n            servers\n              .filter((server) => server.auth_url === null)\n              .map((server) => {\n                return this._connectToMcpServerInternal(\n                  server.name,\n                  server.server_url,\n                  server.callback_url,\n                  server.server_options\n                    ? JSON.parse(server.server_options)\n                    : undefined,\n                  {\n                    id: server.id,\n                    oauthClientId: server.client_id ?? undefined,\n                  }\n                );\n              })\n          );\n\n          this.broadcast(\n            JSON.stringify({\n              type: \"cf_agent_mcp_servers\",\n              mcp: this.getMcpServers(),\n            })\n          );\n\n          await this._tryCatch(() => _onStart());\n        }\n      );\n    };\n  }\n\n  private _setStateInternal(\n    state: State,\n    source: Connection | \"server\" = \"server\"\n  ) {\n    this._state = state;\n    this.sql`\n    INSERT OR REPLACE INTO cf_agents_state (id, state)\n    VALUES (${STATE_ROW_ID}, ${JSON.stringify(state)})\n  `;\n    this.sql`\n    INSERT OR REPLACE INTO cf_agents_state (id, state)\n    VALUES (${STATE_WAS_CHANGED}, ${JSON.stringify(true)})\n  `;\n    this.broadcast(\n      JSON.stringify({\n        type: \"cf_agent_state\",\n        state: state,\n      }),\n      source !== \"server\" ? [source.id] : []\n    );\n    return this._tryCatch(() => {\n      const { connection, request } = agentContext.getStore() || {};\n      return agentContext.run(\n        { agent: this, connection, request },\n        async () => {\n          return this.onStateUpdate(state, source);\n        }\n      );\n    });\n  }\n\n  /**\n   * Update the Agent's state\n   * @param state New state to set\n   */\n  setState(state: State) {\n    this._setStateInternal(state, \"server\");\n  }\n\n  /**\n   * Called when the Agent's state is updated\n   * @param state Updated state\n   * @param source Source of the state update (\"server\" or a client connection)\n   */\n  onStateUpdate(state: State | undefined, source: Connection | \"server\") {\n    // override this to handle state updates\n  }\n\n  /**\n   * Called when the Agent receives an email\n   * @param email Email message to process\n   */\n  onEmail(email: ForwardableEmailMessage) {\n    return agentContext.run(\n      { agent: this, connection: undefined, request: undefined },\n      async () => {\n        console.error(\"onEmail not implemented\");\n      }\n    );\n  }\n\n  private async _tryCatch<T>(fn: () => T | Promise<T>) {\n    try {\n      return await fn();\n    } catch (e) {\n      throw this.onError(e);\n    }\n  }\n\n  override onError(\n    connection: Connection,\n    error: unknown\n  ): void | Promise<void>;\n  override onError(error: unknown): void | Promise<void>;\n  override onError(connectionOrError: Connection | unknown, error?: unknown) {\n    let theError: unknown;\n    if (connectionOrError && error) {\n      theError = error;\n      // this is a websocket connection error\n      console.error(\n        \"Error on websocket connection:\",\n        (connectionOrError as Connection).id,\n        theError\n      );\n      console.error(\n        \"Override onError(connection, error) to handle websocket connection errors\"\n      );\n    } else {\n      theError = connectionOrError;\n      // this is a server error\n      console.error(\"Error on server:\", theError);\n      console.error(\"Override onError(error) to handle server errors\");\n    }\n    throw theError;\n  }\n\n  /**\n   * Render content (not implemented in base class)\n   */\n  render() {\n    throw new Error(\"Not implemented\");\n  }\n\n  /**\n   * Schedule a task to be executed in the future\n   * @template T Type of the payload data\n   * @param when When to execute the task (Date, seconds delay, or cron expression)\n   * @param callback Name of the method to call\n   * @param payload Data to pass to the callback\n   * @returns Schedule object representing the scheduled task\n   */\n  async schedule<T = string>(\n    when: Date | string | number,\n    callback: keyof this,\n    payload?: T\n  ): Promise<Schedule<T>> {\n    const id = nanoid(9);\n\n    if (typeof callback !== \"string\") {\n      throw new Error(\"Callback must be a string\");\n    }\n\n    if (typeof this[callback] !== \"function\") {\n      throw new Error(`this.${callback} is not a function`);\n    }\n\n    if (when instanceof Date) {\n      const timestamp = Math.floor(when.getTime() / 1000);\n      this.sql`\n        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, time)\n        VALUES (${id}, ${callback}, ${JSON.stringify(\n          payload\n        )}, 'scheduled', ${timestamp})\n      `;\n\n      await this._scheduleNextAlarm();\n\n      return {\n        id,\n        callback: callback,\n        payload: payload as T,\n        time: timestamp,\n        type: \"scheduled\",\n      };\n    }\n    if (typeof when === \"number\") {\n      const time = new Date(Date.now() + when * 1000);\n      const timestamp = Math.floor(time.getTime() / 1000);\n\n      this.sql`\n        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, delayInSeconds, time)\n        VALUES (${id}, ${callback}, ${JSON.stringify(\n          payload\n        )}, 'delayed', ${when}, ${timestamp})\n      `;\n\n      await this._scheduleNextAlarm();\n\n      return {\n        id,\n        callback: callback,\n        payload: payload as T,\n        delayInSeconds: when,\n        time: timestamp,\n        type: \"delayed\",\n      };\n    }\n    if (typeof when === \"string\") {\n      const nextExecutionTime = getNextCronTime(when);\n      const timestamp = Math.floor(nextExecutionTime.getTime() / 1000);\n\n      this.sql`\n        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, cron, time)\n        VALUES (${id}, ${callback}, ${JSON.stringify(\n          payload\n        )}, 'cron', ${when}, ${timestamp})\n      `;\n\n      await this._scheduleNextAlarm();\n\n      return {\n        id,\n        callback: callback,\n        payload: payload as T,\n        cron: when,\n        time: timestamp,\n        type: \"cron\",\n      };\n    }\n    throw new Error(\"Invalid schedule type\");\n  }\n\n  /**\n   * Get a scheduled task by ID\n   * @template T Type of the payload data\n   * @param id ID of the scheduled task\n   * @returns The Schedule object or undefined if not found\n   */\n  async getSchedule<T = string>(id: string): Promise<Schedule<T> | undefined> {\n    const result = this.sql<Schedule<string>>`\n      SELECT * FROM cf_agents_schedules WHERE id = ${id}\n    `;\n    if (!result) {\n      console.error(`schedule ${id} not found`);\n      return undefined;\n    }\n\n    return { ...result[0], payload: JSON.parse(result[0].payload) as T };\n  }\n\n  /**\n   * Get scheduled tasks matching the given criteria\n   * @template T Type of the payload data\n   * @param criteria Criteria to filter schedules\n   * @returns Array of matching Schedule objects\n   */\n  getSchedules<T = string>(\n    criteria: {\n      id?: string;\n      type?: \"scheduled\" | \"delayed\" | \"cron\";\n      timeRange?: { start?: Date; end?: Date };\n    } = {}\n  ): Schedule<T>[] {\n    let query = \"SELECT * FROM cf_agents_schedules WHERE 1=1\";\n    const params = [];\n\n    if (criteria.id) {\n      query += \" AND id = ?\";\n      params.push(criteria.id);\n    }\n\n    if (criteria.type) {\n      query += \" AND type = ?\";\n      params.push(criteria.type);\n    }\n\n    if (criteria.timeRange) {\n      query += \" AND time >= ? AND time <= ?\";\n      const start = criteria.timeRange.start || new Date(0);\n      const end = criteria.timeRange.end || new Date(999999999999999);\n      params.push(\n        Math.floor(start.getTime() / 1000),\n        Math.floor(end.getTime() / 1000)\n      );\n    }\n\n    const result = this.ctx.storage.sql\n      .exec(query, ...params)\n      .toArray()\n      .map((row) => ({\n        ...row,\n        payload: JSON.parse(row.payload as string) as T,\n      })) as Schedule<T>[];\n\n    return result;\n  }\n\n  /**\n   * Cancel a scheduled task\n   * @param id ID of the task to cancel\n   * @returns true if the task was cancelled, false otherwise\n   */\n  async cancelSchedule(id: string): Promise<boolean> {\n    this.sql`DELETE FROM cf_agents_schedules WHERE id = ${id}`;\n\n    await this._scheduleNextAlarm();\n    return true;\n  }\n\n  private async _scheduleNextAlarm() {\n    // Find the next schedule that needs to be executed\n    const result = this.sql`\n      SELECT time FROM cf_agents_schedules \n      WHERE time > ${Math.floor(Date.now() / 1000)}\n      ORDER BY time ASC \n      LIMIT 1\n    `;\n    if (!result) return;\n\n    if (result.length > 0 && \"time\" in result[0]) {\n      const nextTime = (result[0].time as number) * 1000;\n      await this.ctx.storage.setAlarm(nextTime);\n    }\n  }\n\n  /**\n   * Method called when an alarm fires.\n   * Executes any scheduled tasks that are due.\n   *\n   * @remarks\n   * To schedule a task, please use the `this.schedule` method instead.\n   * See {@link https://developers.cloudflare.com/agents/api-reference/schedule-tasks/}\n   */\n  public readonly alarm = async () => {\n    const now = Math.floor(Date.now() / 1000);\n\n    // Get all schedules that should be executed now\n    const result = this.sql<Schedule<string>>`\n      SELECT * FROM cf_agents_schedules WHERE time <= ${now}\n    `;\n\n    for (const row of result || []) {\n      const callback = this[row.callback as keyof Agent<Env>];\n      if (!callback) {\n        console.error(`callback ${row.callback} not found`);\n        continue;\n      }\n      await agentContext.run(\n        { agent: this, connection: undefined, request: undefined },\n        async () => {\n          try {\n            await (\n              callback as (\n                payload: unknown,\n                schedule: Schedule<unknown>\n              ) => Promise<void>\n            ).bind(this)(JSON.parse(row.payload as string), row);\n          } catch (e) {\n            console.error(`error executing callback \"${row.callback}\"`, e);\n          }\n        }\n      );\n      if (row.type === \"cron\") {\n        // Update next execution time for cron schedules\n        const nextExecutionTime = getNextCronTime(row.cron);\n        const nextTimestamp = Math.floor(nextExecutionTime.getTime() / 1000);\n\n        this.sql`\n          UPDATE cf_agents_schedules SET time = ${nextTimestamp} WHERE id = ${row.id}\n        `;\n      } else {\n        // Delete one-time schedules after execution\n        this.sql`\n          DELETE FROM cf_agents_schedules WHERE id = ${row.id}\n        `;\n      }\n    }\n\n    // Schedule the next alarm\n    await this._scheduleNextAlarm();\n  };\n\n  /**\n   * Destroy the Agent, removing all state and scheduled tasks\n   */\n  async destroy() {\n    // drop all tables\n    this.sql`DROP TABLE IF EXISTS cf_agents_state`;\n    this.sql`DROP TABLE IF EXISTS cf_agents_schedules`;\n    this.sql`DROP TABLE IF EXISTS cf_agents_mcp_servers`;\n\n    // delete all alarms\n    await this.ctx.storage.deleteAlarm();\n    await this.ctx.storage.deleteAll();\n    this.ctx.abort(\"destroyed\"); // enforce that the agent is evicted\n  }\n\n  /**\n   * Get all methods marked as callable on this Agent\n   * @returns A map of method names to their metadata\n   */\n  private _isCallable(method: string): boolean {\n    return callableMetadata.has(this[method as keyof this] as Function);\n  }\n\n  /**\n   * Connect to a new MCP Server\n   *\n   * @param url MCP Server SSE URL\n   * @param callbackHost Base host for the agent, used for the redirect URI.\n   * @param agentsPrefix agents routing prefix if not using `agents`\n   * @param options MCP client and transport (header) options\n   * @returns authUrl\n   */\n  async addMcpServer(\n    serverName: string,\n    url: string,\n    callbackHost: string,\n    agentsPrefix = \"agents\",\n    options?: {\n      client?: ConstructorParameters<typeof Client>[1];\n      transport?: {\n        headers: HeadersInit;\n      };\n    }\n  ): Promise<{ id: string; authUrl: string | undefined }> {\n    const callbackUrl = `${callbackHost}/${agentsPrefix}/${camelCaseToKebabCase(this._ParentClass.name)}/${this.name}/callback`;\n\n    const result = await this._connectToMcpServerInternal(\n      serverName,\n      url,\n      callbackUrl,\n      options\n    );\n\n    this.broadcast(\n      JSON.stringify({\n        type: \"cf_agent_mcp_servers\",\n        mcp: this.getMcpServers(),\n      })\n    );\n\n    return result;\n  }\n\n  async _connectToMcpServerInternal(\n    serverName: string,\n    url: string,\n    callbackUrl: string,\n    // it's important that any options here are serializable because we put them into our sqlite DB for reconnection purposes\n    options?: {\n      client?: ConstructorParameters<typeof Client>[1];\n      /**\n       * We don't expose the normal set of transport options because:\n       * 1) we can't serialize things like the auth provider or a fetch function into the DB for reconnection purposes\n       * 2) We probably want these options to be agnostic to the transport type (SSE vs Streamable)\n       *\n       * This has the limitation that you can't override fetch, but I think headers should handle nearly all cases needed (i.e. non-standard bearer auth).\n       */\n      transport?: {\n        headers?: HeadersInit;\n      };\n    },\n    reconnect?: {\n      id: string;\n      oauthClientId?: string;\n    }\n  ): Promise<{ id: string; authUrl: string | undefined }> {\n    const authProvider = new DurableObjectOAuthClientProvider(\n      this.ctx.storage,\n      this.name,\n      callbackUrl\n    );\n\n    if (reconnect) {\n      authProvider.serverId = reconnect.id;\n      if (reconnect.oauthClientId) {\n        authProvider.clientId = reconnect.oauthClientId;\n      }\n    }\n\n    // allows passing through transport headers if necessary\n    // this handles some non-standard bearer auth setups (i.e. MCP server behind CF access instead of OAuth)\n    let headerTransportOpts: SSEClientTransportOptions = {};\n    if (options?.transport?.headers) {\n      headerTransportOpts = {\n        eventSourceInit: {\n          fetch: (url, init) =>\n            fetch(url, {\n              ...init,\n              headers: options?.transport?.headers,\n            }),\n        },\n        requestInit: {\n          headers: options?.transport?.headers,\n        },\n      };\n    }\n\n    const { id, authUrl, clientId } = await this.mcp.connect(url, {\n      reconnect,\n      transport: {\n        ...headerTransportOpts,\n        authProvider,\n      },\n      client: options?.client,\n    });\n\n    this.sql`\n      INSERT OR REPLACE INTO cf_agents_mcp_servers (id, name, server_url, client_id, auth_url, callback_url, server_options)\n      VALUES (\n        ${id},\n        ${serverName},\n        ${url},\n        ${clientId ?? null},\n        ${authUrl ?? null},\n        ${callbackUrl},\n        ${options ? JSON.stringify(options) : null}\n      );\n    `;\n\n    return {\n      id,\n      authUrl,\n    };\n  }\n\n  async removeMcpServer(id: string) {\n    this.mcp.closeConnection(id);\n    this.sql`\n      DELETE FROM cf_agents_mcp_servers WHERE id = ${id};\n    `;\n    this.broadcast(\n      JSON.stringify({\n        type: \"cf_agent_mcp_servers\",\n        mcp: this.getMcpServers(),\n      })\n    );\n  }\n\n  getMcpServers(): MCPServersState {\n    const mcpState: MCPServersState = {\n      servers: {},\n      tools: this.mcp.listTools(),\n      prompts: this.mcp.listPrompts(),\n      resources: this.mcp.listResources(),\n    };\n\n    const servers = this.sql<MCPServerRow>`\n      SELECT id, name, server_url, client_id, auth_url, callback_url, server_options FROM cf_agents_mcp_servers;\n    `;\n\n    for (const server of servers) {\n      const serverConn = this.mcp.mcpConnections[server.id];\n      mcpState.servers[server.id] = {\n        name: server.name,\n        server_url: server.server_url,\n        auth_url: server.auth_url,\n        // mark as \"authenticating\" because the server isn't automatically connected, so it's pending authenticating\n        state: serverConn?.connectionState ?? \"authenticating\",\n        instructions: serverConn?.instructions ?? null,\n        capabilities: serverConn?.serverCapabilities ?? null,\n      };\n    }\n\n    return mcpState;\n  }\n}\n\n/**\n * Namespace for creating Agent instances\n * @template Agentic Type of the Agent class\n */\nexport type AgentNamespace<Agentic extends Agent<unknown>> =\n  DurableObjectNamespace<Agentic>;\n\n/**\n * Agent's durable context\n */\nexport type AgentContext = DurableObjectState;\n\n/**\n * Configuration options for Agent routing\n */\nexport type AgentOptions<Env> = PartyServerOptions<Env> & {\n  /**\n   * Whether to enable CORS for the Agent\n   */\n  cors?: boolean | HeadersInit | undefined;\n};\n\n/**\n * Route a request to the appropriate Agent\n * @param request Request to route\n * @param env Environment containing Agent bindings\n * @param options Routing options\n * @returns Response from the Agent or undefined if no route matched\n */\nexport async function routeAgentRequest<Env>(\n  request: Request,\n  env: Env,\n  options?: AgentOptions<Env>\n) {\n  const corsHeaders =\n    options?.cors === true\n      ? {\n          \"Access-Control-Allow-Origin\": \"*\",\n          \"Access-Control-Allow-Methods\": \"GET, POST, HEAD, OPTIONS\",\n          \"Access-Control-Allow-Credentials\": \"true\",\n          \"Access-Control-Max-Age\": \"86400\",\n        }\n      : options?.cors;\n\n  if (request.method === \"OPTIONS\") {\n    if (corsHeaders) {\n      return new Response(null, {\n        headers: corsHeaders,\n      });\n    }\n    console.warn(\n      \"Received an OPTIONS request, but cors was not enabled. Pass `cors: true` or `cors: { ...custom cors headers }` to routeAgentRequest to enable CORS.\"\n    );\n  }\n\n  let response = await routePartykitRequest(\n    request,\n    env as Record<string, unknown>,\n    {\n      prefix: \"agents\",\n      ...(options as PartyServerOptions<Record<string, unknown>>),\n    }\n  );\n\n  if (\n    response &&\n    corsHeaders &&\n    request.headers.get(\"upgrade\")?.toLowerCase() !== \"websocket\" &&\n    request.headers.get(\"Upgrade\")?.toLowerCase() !== \"websocket\"\n  ) {\n    response = new Response(response.body, {\n      headers: {\n        ...response.headers,\n        ...corsHeaders,\n      },\n    });\n  }\n  return response;\n}\n\n/**\n * Route an email to the appropriate Agent\n * @param email Email message to route\n * @param env Environment containing Agent bindings\n * @param options Routing options\n */\nexport async function routeAgentEmail<Env>(\n  email: ForwardableEmailMessage,\n  env: Env,\n  options?: AgentOptions<Env>\n): Promise<void> {}\n\n/**\n * Get or create an Agent by name\n * @template Env Environment type containing bindings\n * @template T Type of the Agent class\n * @param namespace Agent namespace\n * @param name Name of the Agent instance\n * @param options Options for Agent creation\n * @returns Promise resolving to an Agent instance stub\n */\nexport async function getAgentByName<Env, T extends Agent<Env>>(\n  namespace: AgentNamespace<T>,\n  name: string,\n  options?: {\n    jurisdiction?: DurableObjectJurisdiction;\n    locationHint?: DurableObjectLocationHint;\n  }\n) {\n  return getServerByName<Env, T>(namespace, name, options);\n}\n\n/**\n * A wrapper for streaming responses in callable methods\n */\nexport class StreamingResponse {\n  private _connection: Connection;\n  private _id: string;\n  private _closed = false;\n\n  constructor(connection: Connection, id: string) {\n    this._connection = connection;\n    this._id = id;\n  }\n\n  /**\n   * Send a chunk of data to the client\n   * @param chunk The data to send\n   */\n  send(chunk: unknown) {\n    if (this._closed) {\n      throw new Error(\"StreamingResponse is already closed\");\n    }\n    const response: RPCResponse = {\n      type: \"rpc\",\n      id: this._id,\n      success: true,\n      result: chunk,\n      done: false,\n    };\n    this._connection.send(JSON.stringify(response));\n  }\n\n  /**\n   * End the stream and send the final chunk (if any)\n   * @param finalChunk Optional final chunk of data to send\n   */\n  end(finalChunk?: unknown) {\n    if (this._closed) {\n      throw new Error(\"StreamingResponse is already closed\");\n    }\n    this._closed = true;\n    const response: RPCResponse = {\n      type: \"rpc\",\n      id: this._id,\n      success: true,\n      result: finalChunk,\n      done: true,\n    };\n    this._connection.send(JSON.stringify(response));\n  }\n}\n", "import { DurableObject } from \"cloudflare:workers\";\nimport type { Connection, WSMessage } from \"../\";\nimport { Agent } from \"../\";\nimport type { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport type { JSONRPCMessage } from \"@modelcontextprotocol/sdk/types.js\";\nimport {\n  InitializeRequestSchema,\n  isJSONRPCError,\n  isJSONRPCNotification,\n  isJSONRPCRequest,\n  isJSONRPCResponse,\n  JSONRPCMessageSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport type { Transport } from \"@modelcontextprotocol/sdk/shared/transport.js\";\nimport type { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\n\nconst MAXIMUM_MESSAGE_SIZE_BYTES = 4 * 1024 * 1024; // 4MB\n\n// CORS helper functions\nfunction corsHeaders(request: Request, corsOptions: CORSOptions = {}) {\n  const origin = \"*\";\n  return {\n    \"Access-Control-Allow-Origin\": corsOptions.origin || origin,\n    \"Access-Control-Allow-Methods\": corsOptions.methods || \"GET, POST, OPTIONS\",\n    \"Access-Control-Allow-Headers\":\n      corsOptions.headers || \"Content-Type, mcp-session-id\",\n    \"Access-Control-Max-Age\": (corsOptions.maxAge || 86400).toString(),\n    \"Access-Control-Expose-Headers\":\n      corsOptions.exposeHeaders || \"mcp-session-id\",\n  };\n}\n\nfunction isDurableObjectNamespace(\n  namespace: unknown\n): namespace is DurableObjectNamespace<McpAgent> {\n  return (\n    typeof namespace === \"object\" &&\n    namespace !== null &&\n    \"newUniqueId\" in namespace &&\n    typeof namespace.newUniqueId === \"function\" &&\n    \"idFromName\" in namespace &&\n    typeof namespace.idFromName === \"function\"\n  );\n}\n\nfunction handleCORS(\n  request: Request,\n  corsOptions?: CORSOptions\n): Response | null {\n  if (request.method === \"OPTIONS\") {\n    return new Response(null, { headers: corsHeaders(request, corsOptions) });\n  }\n\n  return null;\n}\n\ninterface CORSOptions {\n  origin?: string;\n  methods?: string;\n  headers?: string;\n  maxAge?: number;\n  exposeHeaders?: string;\n}\n\nclass McpSSETransport implements Transport {\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n  sessionId?: string;\n\n  private _getWebSocket: () => WebSocket | null;\n  private _started = false;\n  constructor(getWebSocket: () => WebSocket | null) {\n    this._getWebSocket = getWebSocket;\n  }\n\n  async start() {\n    // The transport does not manage the WebSocket connection since it's terminated\n    // by the Durable Object in order to allow hibernation. There's nothing to initialize.\n    if (this._started) {\n      throw new Error(\"Transport already started\");\n    }\n    this._started = true;\n  }\n\n  async send(message: JSONRPCMessage) {\n    if (!this._started) {\n      throw new Error(\"Transport not started\");\n    }\n    const websocket = this._getWebSocket();\n    if (!websocket) {\n      throw new Error(\"WebSocket not connected\");\n    }\n    try {\n      websocket.send(JSON.stringify(message));\n    } catch (error) {\n      this.onerror?.(error as Error);\n      throw error;\n    }\n  }\n\n  async close() {\n    // Similar to start, the only thing to do is to pass the event on to the server\n    this.onclose?.();\n  }\n}\n\ntype TransportType = \"sse\" | \"streamable-http\" | \"unset\";\n\nclass McpStreamableHttpTransport implements Transport {\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n  sessionId?: string;\n\n  // TODO: If there is an open connection to send server-initiated messages\n  // back, we should use that connection\n  private _getWebSocketForGetRequest: () => WebSocket | null;\n\n  // Get the appropriate websocket connection for a given message id\n  private _getWebSocketForMessageID: (id: string) => WebSocket | null;\n\n  // Notify the server that a response has been sent for a given message id\n  // so that it may clean up it's mapping of message ids to connections\n  // once they are no longer needed\n  private _notifyResponseIdSent: (id: string) => void;\n\n  private _started = false;\n  constructor(\n    getWebSocketForMessageID: (id: string) => WebSocket | null,\n    notifyResponseIdSent: (id: string | number) => void\n  ) {\n    this._getWebSocketForMessageID = getWebSocketForMessageID;\n    this._notifyResponseIdSent = notifyResponseIdSent;\n    // TODO\n    this._getWebSocketForGetRequest = () => null;\n  }\n\n  async start() {\n    // The transport does not manage the WebSocket connection since it's terminated\n    // by the Durable Object in order to allow hibernation. There's nothing to initialize.\n    if (this._started) {\n      throw new Error(\"Transport already started\");\n    }\n    this._started = true;\n  }\n\n  async send(message: JSONRPCMessage) {\n    if (!this._started) {\n      throw new Error(\"Transport not started\");\n    }\n\n    let websocket: WebSocket | null = null;\n\n    if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n      websocket = this._getWebSocketForMessageID(message.id.toString());\n      if (!websocket) {\n        throw new Error(\n          `Could not find WebSocket for message id: ${message.id}`\n        );\n      }\n    } else if (isJSONRPCRequest(message)) {\n      // requests originating from the server must be sent over the\n      // the connection created by a GET request\n      websocket = this._getWebSocketForGetRequest();\n    } else if (isJSONRPCNotification(message)) {\n      // notifications do not have an id\n      // but do have a relatedRequestId field\n      // so that they can be sent to the correct connection\n      websocket = null;\n    }\n\n    try {\n      websocket?.send(JSON.stringify(message));\n      if (isJSONRPCResponse(message)) {\n        this._notifyResponseIdSent(message.id.toString());\n      }\n    } catch (error) {\n      this.onerror?.(error as Error);\n      throw error;\n    }\n  }\n\n  async close() {\n    // Similar to start, the only thing to do is to pass the event on to the server\n    this.onclose?.();\n  }\n}\n\ntype MaybePromise<T> = T | Promise<T>;\n\nexport abstract class McpAgent<\n  Env = unknown,\n  State = unknown,\n  Props extends Record<string, unknown> = Record<string, unknown>,\n> extends DurableObject<Env> {\n  private _status: \"zero\" | \"starting\" | \"started\" = \"zero\";\n  private _transport?: Transport;\n  private _transportType: TransportType = \"unset\";\n  private _requestIdToConnectionId: Map<string | number, string> = new Map();\n\n  /**\n   * Since McpAgent's _aren't_ yet real \"Agents\", let's only expose a couple of the methods\n   * to the outer class: initialState/state/setState/onStateUpdate/sql\n   */\n  private _agent: Agent<Env, State>;\n\n  get mcp() {\n    return this._agent.mcp;\n  }\n\n  protected constructor(ctx: DurableObjectState, env: Env) {\n    super(ctx, env);\n    const self = this;\n\n    this._agent = new (class extends Agent<Env, State> {\n      static options = {\n        hibernate: true,\n      };\n\n      onStateUpdate(state: State | undefined, source: Connection | \"server\") {\n        return self.onStateUpdate(state, source);\n      }\n\n      async onMessage(\n        connection: Connection,\n        message: WSMessage\n      ): Promise<void> {\n        return self.onMessage(connection, message);\n      }\n    })(ctx, env);\n  }\n\n  /**\n   * Agents API allowlist\n   */\n  initialState!: State;\n  get state() {\n    return this._agent.state;\n  }\n  sql<T = Record<string, string | number | boolean | null>>(\n    strings: TemplateStringsArray,\n    ...values: (string | number | boolean | null)[]\n  ) {\n    return this._agent.sql<T>(strings, ...values);\n  }\n\n  setState(state: State) {\n    return this._agent.setState(state);\n  }\n  onStateUpdate(state: State | undefined, source: Connection | \"server\") {\n    // override this to handle state updates\n  }\n  async onStart() {\n    const self = this;\n\n    this._agent = new (class extends Agent<Env, State> {\n      initialState: State = self.initialState;\n      static options = {\n        hibernate: true,\n      };\n\n      onStateUpdate(state: State | undefined, source: Connection | \"server\") {\n        return self.onStateUpdate(state, source);\n      }\n\n      async onMessage(connection: Connection, event: WSMessage) {\n        return self.onMessage(connection, event);\n      }\n    })(this.ctx, this.env);\n\n    this.props = (await this.ctx.storage.get(\"props\")) as Props;\n    this._transportType = (await this.ctx.storage.get(\n      \"transportType\"\n    )) as TransportType;\n    await this._init(this.props);\n\n    const server = await this.server;\n\n    // Connect to the MCP server\n    if (this._transportType === \"sse\") {\n      this._transport = new McpSSETransport(() => this.getWebSocket());\n      await server.connect(this._transport);\n    } else if (this._transportType === \"streamable-http\") {\n      this._transport = new McpStreamableHttpTransport(\n        (id) => this.getWebSocketForResponseID(id),\n        (id) => this._requestIdToConnectionId.delete(id)\n      );\n      await server.connect(this._transport);\n    }\n  }\n\n  /**\n   * McpAgent API\n   */\n  abstract server: MaybePromise<McpServer | Server>;\n  props!: Props;\n  initRun = false;\n\n  abstract init(): Promise<void>;\n\n  async _init(props: Props) {\n    await this.ctx.storage.put(\"props\", props ?? {});\n    if (!this.ctx.storage.get(\"transportType\")) {\n      await this.ctx.storage.put(\"transportType\", \"unset\");\n    }\n    this.props = props;\n    if (!this.initRun) {\n      this.initRun = true;\n      await this.init();\n    }\n  }\n\n  async setInitialized() {\n    await this.ctx.storage.put(\"initialized\", true);\n  }\n\n  async isInitialized() {\n    return (await this.ctx.storage.get(\"initialized\")) === true;\n  }\n\n  private async _initialize(): Promise<void> {\n    await this.ctx.blockConcurrencyWhile(async () => {\n      this._status = \"starting\";\n      await this.onStart();\n      this._status = \"started\";\n    });\n  }\n\n  // Allow the worker to fetch a websocket connection to the agent\n  async fetch(request: Request): Promise<Response> {\n    if (this._status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this._initialize();\n    }\n\n    // Only handle WebSocket upgrade requests\n    if (request.headers.get(\"Upgrade\") !== \"websocket\") {\n      return new Response(\"Expected WebSocket Upgrade request\", {\n        status: 400,\n      });\n    }\n\n    // This request does not come from the user. The worker generates this\n    // request to generate a websocket connection to the agent.\n    const url = new URL(request.url);\n    // This is not the path that the user requested, but the path that the worker\n    // generated. We'll use this path to determine which transport to use.\n    const path = url.pathname;\n    const server = await this.server;\n\n    switch (path) {\n      case \"/sse\": {\n        // For SSE connections, we can only have one open connection per session\n        // If we get an upgrade while already connected, we should error\n        const websockets = this.ctx.getWebSockets();\n        if (websockets.length > 0) {\n          return new Response(\"Websocket already connected\", { status: 400 });\n        }\n\n        // This session must always use the SSE transporo\n        await this.ctx.storage.put(\"transportType\", \"sse\");\n        this._transportType = \"sse\";\n\n        if (!this._transport) {\n          this._transport = new McpSSETransport(() => this.getWebSocket());\n          await server.connect(this._transport);\n        }\n\n        // Defer to the Agent's fetch method to handle the WebSocket connection\n        return this._agent.fetch(request);\n      }\n      case \"/streamable-http\": {\n        if (!this._transport) {\n          this._transport = new McpStreamableHttpTransport(\n            (id) => this.getWebSocketForResponseID(id),\n            (id) => this._requestIdToConnectionId.delete(id)\n          );\n          await server.connect(this._transport);\n        }\n\n        // This session must always use the streamable-http transport\n        await this.ctx.storage.put(\"transportType\", \"streamable-http\");\n        this._transportType = \"streamable-http\";\n\n        return this._agent.fetch(request);\n      }\n      default:\n        return new Response(\n          \"Internal Server Error: Expected /sse or /streamable-http path\",\n          {\n            status: 500,\n          }\n        );\n    }\n  }\n\n  getWebSocket() {\n    const websockets = this.ctx.getWebSockets();\n    if (websockets.length === 0) {\n      return null;\n    }\n    return websockets[0];\n  }\n\n  getWebSocketForResponseID(id: string): WebSocket | null {\n    const connectionId = this._requestIdToConnectionId.get(id);\n    if (connectionId === undefined) {\n      return null;\n    }\n    return this._agent.getConnection(connectionId) ?? null;\n  }\n\n  // All messages received here. This is currently never called\n  async onMessage(connection: Connection, event: WSMessage) {\n    // Since we address the DO via both the protocol and the session id,\n    // this should never happen, but let's enforce it just in case\n    if (this._transportType !== \"streamable-http\") {\n      const err = new Error(\n        \"Internal Server Error: Expected streamable-http protocol\"\n      );\n      this._transport?.onerror?.(err);\n      return;\n    }\n\n    let message: JSONRPCMessage;\n    try {\n      // Ensure event is a string\n      const data =\n        typeof event === \"string\" ? event : new TextDecoder().decode(event);\n      message = JSONRPCMessageSchema.parse(JSON.parse(data));\n    } catch (error) {\n      this._transport?.onerror?.(error as Error);\n      return;\n    }\n\n    // We need to map every incoming message to the connection that it came in on\n    // so that we can send relevant responses and notifications back on the same connection\n    if (isJSONRPCRequest(message)) {\n      this._requestIdToConnectionId.set(message.id.toString(), connection.id);\n    }\n\n    this._transport?.onmessage?.(message);\n  }\n\n  // All messages received over SSE after the initial connection has been established\n  // will be passed here\n  async onSSEMcpMessage(\n    sessionId: string,\n    request: Request\n  ): Promise<Error | null> {\n    if (this._status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this._initialize();\n    }\n\n    // Since we address the DO via both the protocol and the session id,\n    // this should never happen, but let's enforce it just in case\n    if (this._transportType !== \"sse\") {\n      return new Error(\"Internal Server Error: Expected SSE protocol\");\n    }\n\n    try {\n      const message = await request.json();\n      let parsedMessage: JSONRPCMessage;\n      try {\n        parsedMessage = JSONRPCMessageSchema.parse(message);\n      } catch (error) {\n        this._transport?.onerror?.(error as Error);\n        throw error;\n      }\n\n      this._transport?.onmessage?.(parsedMessage);\n      return null;\n    } catch (error) {\n      console.error(\"Error forwarding message to SSE:\", error);\n      this._transport?.onerror?.(error as Error);\n      return error as Error;\n    }\n  }\n\n  // Delegate all websocket events to the underlying agent\n  async webSocketMessage(\n    ws: WebSocket,\n    event: ArrayBuffer | string\n  ): Promise<void> {\n    if (this._status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this._initialize();\n    }\n    return await this._agent.webSocketMessage(ws, event);\n  }\n\n  // WebSocket event handlers for hibernation support\n  async webSocketError(ws: WebSocket, error: unknown): Promise<void> {\n    if (this._status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this._initialize();\n    }\n    return await this._agent.webSocketError(ws, error);\n  }\n\n  async webSocketClose(\n    ws: WebSocket,\n    code: number,\n    reason: string,\n    wasClean: boolean\n  ): Promise<void> {\n    if (this._status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this._initialize();\n    }\n    return await this._agent.webSocketClose(ws, code, reason, wasClean);\n  }\n\n  static mount(\n    path: string,\n    {\n      binding = \"MCP_OBJECT\",\n      corsOptions,\n    }: {\n      binding?: string;\n      corsOptions?: CORSOptions;\n    } = {}\n  ) {\n    return McpAgent.serveSSE(path, { binding, corsOptions });\n  }\n\n  static serveSSE(\n    path: string,\n    {\n      binding = \"MCP_OBJECT\",\n      corsOptions,\n    }: {\n      binding?: string;\n      corsOptions?: CORSOptions;\n    } = {}\n  ) {\n    let pathname = path;\n    if (path === \"/\") {\n      pathname = \"/*\";\n    }\n    const basePattern = new URLPattern({ pathname });\n    const messagePattern = new URLPattern({ pathname: `${pathname}/message` });\n\n    return {\n      async fetch<Env>(\n        this: void,\n        request: Request,\n        env: Env,\n        ctx: ExecutionContext\n      ): Promise<Response> {\n        // Handle CORS preflight\n        const corsResponse = handleCORS(request, corsOptions);\n        if (corsResponse) return corsResponse;\n\n        const url = new URL(request.url);\n        const bindingValue = env[binding as keyof typeof env] as unknown;\n\n        // Ensure we have a binding of some sort\n        if (bindingValue == null || typeof bindingValue !== \"object\") {\n          console.error(\n            `Could not find McpAgent binding for ${binding}. Did you update your wrangler configuration?`\n          );\n          return new Response(\"Invalid binding\", { status: 500 });\n        }\n\n        // Ensure that the binding is to a DurableObject\n        if (!isDurableObjectNamespace(bindingValue)) {\n          return new Response(\"Invalid binding\", { status: 500 });\n        }\n\n        const namespace =\n          bindingValue satisfies DurableObjectNamespace<McpAgent>;\n\n        // Handle initial SSE connection\n        if (request.method === \"GET\" && basePattern.test(url)) {\n          // Use a session ID if one is passed in, or create a unique\n          // session ID for this connection\n          const sessionId =\n            url.searchParams.get(\"sessionId\") ||\n            namespace.newUniqueId().toString();\n\n          // Create a Transform Stream for SSE\n          const { readable, writable } = new TransformStream();\n          const writer = writable.getWriter();\n          const encoder = new TextEncoder();\n\n          // Send the endpoint event\n          const endpointUrl = new URL(request.url);\n          endpointUrl.pathname = encodeURI(`${pathname}/message`);\n          endpointUrl.searchParams.set(\"sessionId\", sessionId);\n          const relativeUrlWithSession =\n            endpointUrl.pathname + endpointUrl.search + endpointUrl.hash;\n          const endpointMessage = `event: endpoint\\ndata: ${relativeUrlWithSession}\\n\\n`;\n          writer.write(encoder.encode(endpointMessage));\n\n          // Get the Durable Object\n          const id = namespace.idFromName(`sse:${sessionId}`);\n          const doStub = namespace.get(id);\n\n          // Initialize the object\n          await doStub._init(ctx.props);\n\n          // Connect to the Durable Object via WebSocket\n          const upgradeUrl = new URL(request.url);\n          // enforce that the path that the DO receives is always /sse\n          upgradeUrl.pathname = \"/sse\";\n          const response = await doStub.fetch(\n            new Request(upgradeUrl, {\n              headers: {\n                Upgrade: \"websocket\",\n                // Required by PartyServer\n                \"x-partykit-room\": sessionId,\n              },\n            })\n          );\n\n          // Get the WebSocket\n          const ws = response.webSocket;\n          if (!ws) {\n            console.error(\"Failed to establish WebSocket connection\");\n            await writer.close();\n            return new Response(\"Failed to establish WebSocket connection\", {\n              status: 500,\n            });\n          }\n\n          // Accept the WebSocket\n          ws.accept();\n\n          // Handle messages from the Durable Object\n          ws.addEventListener(\"message\", (event) => {\n            async function onMessage(event: MessageEvent) {\n              try {\n                const message = JSON.parse(event.data);\n\n                // validate that the message is a valid JSONRPC message\n                const result = JSONRPCMessageSchema.safeParse(message);\n                if (!result.success) {\n                  // The message was not a valid JSONRPC message, so we will drop it\n                  // PartyKit will broadcast state change messages to all connected clients\n                  // and we need to filter those out so they are not passed to MCP clients\n                  return;\n                }\n\n                // Send the message as an SSE event\n                const messageText = `event: message\\ndata: ${JSON.stringify(result.data)}\\n\\n`;\n                await writer.write(encoder.encode(messageText));\n              } catch (error) {\n                console.error(\"Error forwarding message to SSE:\", error);\n              }\n            }\n            onMessage(event).catch(console.error);\n          });\n\n          // Handle WebSocket errors\n          ws.addEventListener(\"error\", (error) => {\n            async function onError(error: Event) {\n              try {\n                await writer.close();\n              } catch (e) {\n                // Ignore errors when closing\n              }\n            }\n            onError(error).catch(console.error);\n          });\n\n          // Handle WebSocket closure\n          ws.addEventListener(\"close\", () => {\n            async function onClose() {\n              try {\n                await writer.close();\n              } catch (error) {\n                console.error(\"Error closing SSE connection:\", error);\n              }\n            }\n            onClose().catch(console.error);\n          });\n\n          // Return the SSE response\n          return new Response(readable, {\n            headers: {\n              \"Content-Type\": \"text/event-stream\",\n              \"Cache-Control\": \"no-cache\",\n              Connection: \"keep-alive\",\n              ...corsHeaders(request, corsOptions),\n            },\n          });\n        }\n\n        // Handle incoming MCP messages. These will be passed to McpAgent\n        // but the response will be sent back via the open SSE connection\n        // so we only need to return a 202 Accepted response for success\n        if (request.method === \"POST\" && messagePattern.test(url)) {\n          const sessionId = url.searchParams.get(\"sessionId\");\n          if (!sessionId) {\n            return new Response(\n              `Missing sessionId. Expected POST to ${pathname} to initiate new one`,\n              { status: 400 }\n            );\n          }\n\n          const contentType = request.headers.get(\"content-type\") || \"\";\n          if (!contentType.includes(\"application/json\")) {\n            return new Response(`Unsupported content-type: ${contentType}`, {\n              status: 400,\n            });\n          }\n\n          // check if the request body is too large\n          const contentLength = Number.parseInt(\n            request.headers.get(\"content-length\") || \"0\",\n            10\n          );\n          if (contentLength > MAXIMUM_MESSAGE_SIZE_BYTES) {\n            return new Response(\n              `Request body too large: ${contentLength} bytes`,\n              {\n                status: 400,\n              }\n            );\n          }\n\n          // Get the Durable Object\n          const id = namespace.idFromName(`sse:${sessionId}`);\n          const doStub = namespace.get(id);\n\n          // Forward the request to the Durable Object\n          const error = await doStub.onSSEMcpMessage(sessionId, request);\n\n          if (error) {\n            return new Response(error.message, {\n              status: 400,\n              headers: {\n                \"Content-Type\": \"text/event-stream\",\n                \"Cache-Control\": \"no-cache\",\n                Connection: \"keep-alive\",\n                ...corsHeaders(request, corsOptions),\n              },\n            });\n          }\n\n          return new Response(\"Accepted\", {\n            status: 202,\n            headers: {\n              \"Content-Type\": \"text/event-stream\",\n              \"Cache-Control\": \"no-cache\",\n              Connection: \"keep-alive\",\n              ...corsHeaders(request, corsOptions),\n            },\n          });\n        }\n\n        return new Response(\"Not Found\", { status: 404 });\n      },\n    };\n  }\n\n  static serve(\n    path: string,\n    {\n      binding = \"MCP_OBJECT\",\n      corsOptions,\n    }: { binding?: string; corsOptions?: CORSOptions } = {}\n  ) {\n    let pathname = path;\n    if (path === \"/\") {\n      pathname = \"/*\";\n    }\n    const basePattern = new URLPattern({ pathname });\n\n    return {\n      async fetch<Env>(\n        this: void,\n        request: Request,\n        env: Env,\n        ctx: ExecutionContext\n      ): Promise<Response> {\n        // Handle CORS preflight\n        const corsResponse = handleCORS(request, corsOptions);\n        if (corsResponse) {\n          return corsResponse;\n        }\n\n        const url = new URL(request.url);\n        const bindingValue = env[binding as keyof typeof env] as unknown;\n\n        // Ensure we have a binding of some sort\n        if (bindingValue == null || typeof bindingValue !== \"object\") {\n          console.error(\n            `Could not find McpAgent binding for ${binding}. Did you update your wrangler configuration?`\n          );\n          return new Response(\"Invalid binding\", { status: 500 });\n        }\n\n        // Ensure that the binding is to a DurableObject\n        if (!isDurableObjectNamespace(bindingValue)) {\n          return new Response(\"Invalid binding\", { status: 500 });\n        }\n\n        const namespace =\n          bindingValue satisfies DurableObjectNamespace<McpAgent>;\n\n        if (request.method === \"POST\" && basePattern.test(url)) {\n          // validate the Accept header\n          const acceptHeader = request.headers.get(\"accept\");\n          // The client MUST include an Accept header, listing both application/json and text/event-stream as supported content types.\n          if (\n            !acceptHeader?.includes(\"application/json\") ||\n            !acceptHeader.includes(\"text/event-stream\")\n          ) {\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32000,\n                message:\n                  \"Not Acceptable: Client must accept both application/json and text/event-stream\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 406 });\n          }\n\n          const ct = request.headers.get(\"content-type\");\n          if (!ct || !ct.includes(\"application/json\")) {\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32000,\n                message:\n                  \"Unsupported Media Type: Content-Type must be application/json\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 415 });\n          }\n\n          // Check content length against maximum allowed size\n          const contentLength = Number.parseInt(\n            request.headers.get(\"content-length\") ?? \"0\",\n            10\n          );\n          if (contentLength > MAXIMUM_MESSAGE_SIZE_BYTES) {\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32000,\n                message: `Request body too large. Maximum size is ${MAXIMUM_MESSAGE_SIZE_BYTES} bytes`,\n              },\n              id: null,\n            });\n            return new Response(body, { status: 413 });\n          }\n\n          let sessionId = request.headers.get(\"mcp-session-id\");\n          let rawMessage: unknown;\n\n          try {\n            rawMessage = await request.json();\n          } catch (error) {\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32700,\n                message: \"Parse error: Invalid JSON\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 400 });\n          }\n\n          // Make sure the message is an array to simplify logic\n          let arrayMessage: unknown[];\n          if (Array.isArray(rawMessage)) {\n            arrayMessage = rawMessage;\n          } else {\n            arrayMessage = [rawMessage];\n          }\n\n          let messages: JSONRPCMessage[] = [];\n\n          // Try to parse each message as JSON RPC. Fail if any message is invalid\n          for (const msg of arrayMessage) {\n            if (!JSONRPCMessageSchema.safeParse(msg).success) {\n              const body = JSON.stringify({\n                jsonrpc: \"2.0\",\n                error: {\n                  code: -32700,\n                  message: \"Parse error: Invalid JSON-RPC message\",\n                },\n                id: null,\n              });\n              return new Response(body, { status: 400 });\n            }\n          }\n\n          messages = arrayMessage.map((msg) => JSONRPCMessageSchema.parse(msg));\n\n          // Before we pass the messages to the agent, there's another error condition we need to enforce\n          // Check if this is an initialization request\n          // https://spec.modelcontextprotocol.io/specification/2025-03-26/basic/lifecycle/\n          const isInitializationRequest = messages.some(\n            (msg) => InitializeRequestSchema.safeParse(msg).success\n          );\n\n          if (isInitializationRequest && sessionId) {\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32600,\n                message:\n                  \"Invalid Request: Initialization requests must not include a sessionId\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 400 });\n          }\n\n          // The initialization request must be the only request in the batch\n          if (isInitializationRequest && messages.length > 1) {\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32600,\n                message:\n                  \"Invalid Request: Only one initialization request is allowed\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 400 });\n          }\n\n          // If an Mcp-Session-Id is returned by the server during initialization,\n          // clients using the Streamable HTTP transport MUST include it\n          // in the Mcp-Session-Id header on all of their subsequent HTTP requests.\n          if (!isInitializationRequest && !sessionId) {\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32000,\n                message: \"Bad Request: Mcp-Session-Id header is required\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 400 });\n          }\n\n          // If we don't have a sessionId, we are serving an initialization request\n          // and need to generate a new sessionId\n          sessionId = sessionId ?? namespace.newUniqueId().toString();\n\n          // fetch the agent DO\n          const id = namespace.idFromName(`streamable-http:${sessionId}`);\n          const doStub = namespace.get(id);\n          const isInitialized = await doStub.isInitialized();\n\n          if (isInitializationRequest) {\n            await doStub._init(ctx.props);\n            await doStub.setInitialized();\n          } else if (!isInitialized) {\n            // if we have gotten here, then a session id that was never initialized\n            // was provided\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32001,\n                message: \"Session not found\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 404 });\n          }\n\n          // We've evaluated all the error conditions! Now it's time to establish\n          // all the streams\n\n          // Create a Transform Stream for SSE\n          const { readable, writable } = new TransformStream();\n          const writer = writable.getWriter();\n          const encoder = new TextEncoder();\n\n          // Connect to the Durable Object via WebSocket\n          const upgradeUrl = new URL(request.url);\n          upgradeUrl.pathname = \"/streamable-http\";\n          const response = await doStub.fetch(\n            new Request(upgradeUrl, {\n              headers: {\n                Upgrade: \"websocket\",\n                // Required by PartyServer\n                \"x-partykit-room\": sessionId,\n              },\n            })\n          );\n\n          // Get the WebSocket\n          const ws = response.webSocket;\n          if (!ws) {\n            console.error(\"Failed to establish WebSocket connection\");\n\n            await writer.close();\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32001,\n                message: \"Failed to establish WebSocket connection\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 500 });\n          }\n\n          // Keep track of the request ids that we have sent to the server\n          // so that we can close the connection once we have received\n          // all the responses\n          const requestIds: Set<string | number> = new Set();\n\n          // Accept the WebSocket\n          ws.accept();\n\n          // Handle messages from the Durable Object\n          ws.addEventListener(\"message\", (event) => {\n            async function onMessage(event: MessageEvent) {\n              try {\n                const data =\n                  typeof event.data === \"string\"\n                    ? event.data\n                    : new TextDecoder().decode(event.data);\n                const message = JSON.parse(data);\n\n                // validate that the message is a valid JSONRPC message\n                const result = JSONRPCMessageSchema.safeParse(message);\n                if (!result.success) {\n                  // The message was not a valid JSONRPC message, so we will drop it\n                  // PartyKit will broadcast state change messages to all connected clients\n                  // and we need to filter those out so they are not passed to MCP clients\n                  return;\n                }\n\n                // If the message is a response or an error, remove the id from the set of\n                // request ids\n                if (\n                  isJSONRPCResponse(result.data) ||\n                  isJSONRPCError(result.data)\n                ) {\n                  requestIds.delete(result.data.id);\n                }\n\n                // Send the message as an SSE event\n                const messageText = `event: message\\ndata: ${JSON.stringify(result.data)}\\n\\n`;\n                await writer.write(encoder.encode(messageText));\n\n                // If we have received all the responses, close the connection\n                if (requestIds.size === 0) {\n                  ws!.close();\n                }\n              } catch (error) {\n                console.error(\"Error forwarding message to SSE:\", error);\n              }\n            }\n            onMessage(event).catch(console.error);\n          });\n\n          // Handle WebSocket errors\n          ws.addEventListener(\"error\", (error) => {\n            async function onError(error: Event) {\n              try {\n                await writer.close();\n              } catch (e) {\n                // Ignore errors when closing\n              }\n            }\n            onError(error).catch(console.error);\n          });\n\n          // Handle WebSocket closure\n          ws.addEventListener(\"close\", () => {\n            async function onClose() {\n              try {\n                await writer.close();\n              } catch (error) {\n                console.error(\"Error closing SSE connection:\", error);\n              }\n            }\n            onClose().catch(console.error);\n          });\n\n          // If there are no requests, we send the messages to the agent and acknowledge the request with a 202\n          // since we don't expect any responses back through this connection\n          const hasOnlyNotificationsOrResponses = messages.every(\n            (msg) => isJSONRPCNotification(msg) || isJSONRPCResponse(msg)\n          );\n          if (hasOnlyNotificationsOrResponses) {\n            for (const message of messages) {\n              ws.send(JSON.stringify(message));\n            }\n\n            // closing the websocket will also close the SSE connection\n            ws.close();\n\n            return new Response(null, {\n              status: 202,\n              headers: corsHeaders(request, corsOptions),\n            });\n          }\n\n          for (const message of messages) {\n            if (isJSONRPCRequest(message)) {\n              // add each request id that we send off to a set\n              // so that we can keep track of which requests we\n              // still need a response for\n              requestIds.add(message.id);\n            }\n            ws.send(JSON.stringify(message));\n          }\n\n          // Return the SSE response. We handle closing the stream in the ws \"message\"\n          // handler\n          return new Response(readable, {\n            headers: {\n              \"Content-Type\": \"text/event-stream\",\n              \"Cache-Control\": \"no-cache\",\n              Connection: \"keep-alive\",\n              \"mcp-session-id\": sessionId,\n              ...corsHeaders(request, corsOptions),\n            },\n            status: 200,\n          });\n        }\n\n        // We don't yet support GET or DELETE requests\n        const body = JSON.stringify({\n          jsonrpc: \"2.0\",\n          error: {\n            code: -32000,\n            message: \"Method not allowed\",\n          },\n          id: null,\n        });\n        return new Response(body, { status: 405 });\n      },\n    };\n  }\n}\n", null, null, null, null, "import SupabaseClient from './SupabaseClient'\nimport type { GenericSchema, SupabaseClientOptions } from './lib/types'\n\nexport * from '@supabase/auth-js'\nexport type { User as AuthUser, Session as AuthSession } from '@supabase/auth-js'\nexport {\n  type PostgrestResponse,\n  type PostgrestSingleResponse,\n  type PostgrestMaybeSingleResponse,\n  PostgrestError,\n} from '@supabase/postgrest-js'\nexport {\n  FunctionsHttpError,\n  FunctionsFetchError,\n  FunctionsRelayError,\n  FunctionsError,\n  type FunctionInvokeOptions,\n  FunctionRegion,\n} from '@supabase/functions-js'\nexport * from '@supabase/realtime-js'\nexport { default as SupabaseClient } from './SupabaseClient'\nexport type { SupabaseClientOptions, QueryResult, QueryData, QueryError } from './lib/types'\n\n/**\n * Creates a new Supabase Client.\n */\nexport const createClient = <\n  Database = any,\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\n    ? 'public'\n    : string & keyof Database,\n  Schema extends GenericSchema = Database[SchemaName] extends GenericSchema\n    ? Database[SchemaName]\n    : any\n>(\n  supabaseUrl: string,\n  supabaseKey: string,\n  options?: SupabaseClientOptions<SchemaName>\n): SupabaseClient<Database, SchemaName, Schema> => {\n  return new SupabaseClient<Database, SchemaName, Schema>(supabaseUrl, supabaseKey, options)\n}\n", "export { FunctionsClient } from './FunctionsClient'\nexport {\n  type FunctionInvokeOptions,\n  FunctionsError,\n  FunctionsFetchError,\n  FunctionsHttpError,\n  FunctionsRelayError,\n  FunctionRegion,\n  type FunctionsResponse,\n} from './types'\n", "import { Fetch } from './types'\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  let _fetch: Fetch\n  if (customFetch) {\n    _fetch = customFetch\n  } else if (typeof fetch === 'undefined') {\n    _fetch = (...args) =>\n      import('@supabase/node-fetch' as any).then(({ default: fetch }) => fetch(...args))\n  } else {\n    _fetch = fetch\n  }\n  return (...args) => _fetch(...args)\n}\n", "export type Fetch = typeof fetch\n\n/**\n * Response format\n *\n */\nexport interface FunctionsResponseSuccess<T> {\n  data: T\n  error: null\n}\nexport interface FunctionsResponseFailure {\n  data: null\n  error: any\n}\nexport type FunctionsResponse<T> = FunctionsResponseSuccess<T> | FunctionsResponseFailure\n\nexport class FunctionsError extends Error {\n  context: any\n  constructor(message: string, name = 'FunctionsError', context?: any) {\n    super(message)\n    this.name = name\n    this.context = context\n  }\n}\n\nexport class FunctionsFetchError extends FunctionsError {\n  constructor(context: any) {\n    super('Failed to send a request to the Edge Function', 'FunctionsFetchError', context)\n  }\n}\n\nexport class FunctionsRelayError extends FunctionsError {\n  constructor(context: any) {\n    super('Relay Error invoking the Edge Function', 'FunctionsRelayError', context)\n  }\n}\n\nexport class FunctionsHttpError extends FunctionsError {\n  constructor(context: any) {\n    super('Edge Function returned a non-2xx status code', 'FunctionsHttpError', context)\n  }\n}\n// Define the enum for the 'region' property\nexport enum FunctionRegion {\n  Any = 'any',\n  ApNortheast1 = 'ap-northeast-1',\n  ApNortheast2 = 'ap-northeast-2',\n  ApSouth1 = 'ap-south-1',\n  ApSoutheast1 = 'ap-southeast-1',\n  ApSoutheast2 = 'ap-southeast-2',\n  CaCentral1 = 'ca-central-1',\n  EuCentral1 = 'eu-central-1',\n  EuWest1 = 'eu-west-1',\n  EuWest2 = 'eu-west-2',\n  EuWest3 = 'eu-west-3',\n  SaEast1 = 'sa-east-1',\n  UsEast1 = 'us-east-1',\n  UsWest1 = 'us-west-1',\n  UsWest2 = 'us-west-2',\n}\n\nexport type FunctionInvokeOptions = {\n  /**\n   * Object representing the headers to send with the request.\n   * */\n  headers?: { [key: string]: string }\n  /**\n   * The HTTP verb of the request\n   */\n  method?: 'POST' | 'GET' | 'PUT' | 'PATCH' | 'DELETE'\n  /**\n   * The Region to invoke the function in.\n   */\n  region?: FunctionRegion\n  /**\n   * The body of the request.\n   */\n  body?:\n    | File\n    | Blob\n    | ArrayBuffer\n    | FormData\n    | ReadableStream<Uint8Array>\n    | Record<string, any>\n    | string\n}\n", "import { resolveFetch } from './helper'\nimport {\n  Fetch,\n  FunctionsFetchError,\n  FunctionsHttpError,\n  FunctionsRelayError,\n  FunctionsResponse,\n  FunctionInvokeOptions,\n  FunctionRegion,\n} from './types'\n\nexport class FunctionsClient {\n  protected url: string\n  protected headers: Record<string, string>\n  protected region: FunctionRegion\n  protected fetch: Fetch\n\n  constructor(\n    url: string,\n    {\n      headers = {},\n      customFetch,\n      region = FunctionRegion.Any,\n    }: {\n      headers?: Record<string, string>\n      customFetch?: Fetch\n      region?: FunctionRegion\n    } = {}\n  ) {\n    this.url = url\n    this.headers = headers\n    this.region = region\n    this.fetch = resolveFetch(customFetch)\n  }\n\n  /**\n   * Updates the authorization header\n   * @param token - the new jwt token sent in the authorisation header\n   */\n  setAuth(token: string) {\n    this.headers.Authorization = `Bearer ${token}`\n  }\n\n  /**\n   * Invokes a function\n   * @param functionName - The name of the Function to invoke.\n   * @param options - Options for invoking the Function.\n   */\n  async invoke<T = any>(\n    functionName: string,\n    options: FunctionInvokeOptions = {}\n  ): Promise<FunctionsResponse<T>> {\n    try {\n      const { headers, method, body: functionArgs } = options\n      let _headers: Record<string, string> = {}\n      let { region } = options\n      if (!region) {\n        region = this.region\n      }\n      if (region && region !== 'any') {\n        _headers['x-region'] = region\n      }\n      let body: any\n      if (\n        functionArgs &&\n        ((headers && !Object.prototype.hasOwnProperty.call(headers, 'Content-Type')) || !headers)\n      ) {\n        if (\n          (typeof Blob !== 'undefined' && functionArgs instanceof Blob) ||\n          functionArgs instanceof ArrayBuffer\n        ) {\n          // will work for File as File inherits Blob\n          // also works for ArrayBuffer as it is the same underlying structure as a Blob\n          _headers['Content-Type'] = 'application/octet-stream'\n          body = functionArgs\n        } else if (typeof functionArgs === 'string') {\n          // plain string\n          _headers['Content-Type'] = 'text/plain'\n          body = functionArgs\n        } else if (typeof FormData !== 'undefined' && functionArgs instanceof FormData) {\n          // don't set content-type headers\n          // Request will automatically add the right boundary value\n          body = functionArgs\n        } else {\n          // default, assume this is JSON\n          _headers['Content-Type'] = 'application/json'\n          body = JSON.stringify(functionArgs)\n        }\n      }\n\n      const response = await this.fetch(`${this.url}/${functionName}`, {\n        method: method || 'POST',\n        // headers priority is (high to low):\n        // 1. invoke-level headers\n        // 2. client-level headers\n        // 3. default Content-Type header\n        headers: { ..._headers, ...this.headers, ...headers },\n        body,\n      }).catch((fetchError) => {\n        throw new FunctionsFetchError(fetchError)\n      })\n\n      const isRelayError = response.headers.get('x-relay-error')\n      if (isRelayError && isRelayError === 'true') {\n        throw new FunctionsRelayError(response)\n      }\n\n      if (!response.ok) {\n        throw new FunctionsHttpError(response)\n      }\n\n      let responseType = (response.headers.get('Content-Type') ?? 'text/plain').split(';')[0].trim()\n      let data: any\n      if (responseType === 'application/json') {\n        data = await response.json()\n      } else if (responseType === 'application/octet-stream') {\n        data = await response.blob()\n      } else if (responseType === 'text/event-stream') {\n        data = response\n      } else if (responseType === 'multipart/form-data') {\n        data = await response.formData()\n      } else {\n        // default to text\n        data = await response.text()\n      }\n\n      return { data, error: null }\n    } catch (error) {\n      return { data: null, error }\n    }\n  }\n}\n", "import index from '../cjs/index.js'\nconst {\n  PostgrestClient,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestTransformBuilder,\n  PostgrestBuilder,\n  PostgrestError,\n} = index\n\nexport {\n  PostgrestBuilder,\n  PostgrestClient,\n  PostgrestFilterBuilder,\n  PostgrestQueryBuilder,\n  PostgrestTransformBuilder,\n  PostgrestError,\n}\n\n// compatibility with CJS output\nexport default {\n  PostgrestClient,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestTransformBuilder,\n  PostgrestBuilder,\n  PostgrestError,\n}\n", "import RealtimeClient, {\n  RealtimeClientOptions,\n  RealtimeMessage,\n  RealtimeRemoveChannelResponse,\n} from './RealtimeClient'\nimport RealtimeChannel, {\n  RealtimeChannelOptions,\n  RealtimeChannelSendResponse,\n  RealtimePostgresChangesFilter,\n  RealtimePostgresChangesPayload,\n  RealtimePostgresInsertPayload,\n  RealtimePostgresUpdatePayload,\n  RealtimePostgresDeletePayload,\n  REALTIME_LISTEN_TYPES,\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT,\n  REALTIME_SUBSCRIBE_STATES,\n  REALTIME_CHANNEL_STATES,\n} from './RealtimeChannel'\nimport RealtimePresence, {\n  RealtimePresenceState,\n  RealtimePresenceJoinPayload,\n  RealtimePresenceLeavePayload,\n  REALTIME_PRESENCE_LISTEN_EVENTS,\n} from './RealtimePresence'\n\nexport {\n  RealtimePresence,\n  RealtimeChannel,\n  RealtimeChannelOptions,\n  RealtimeChannelSendResponse,\n  RealtimeClient,\n  RealtimeClientOptions,\n  RealtimeMessage,\n  RealtimePostgresChangesFilter,\n  RealtimePostgresChangesPayload,\n  RealtimePostgresInsertPayload,\n  RealtimePostgresUpdatePayload,\n  RealtimePostgresDeletePayload,\n  RealtimePresenceJoinPayload,\n  RealtimePresenceLeavePayload,\n  RealtimePresenceState,\n  RealtimeRemoveChannelResponse,\n  REALTIME_LISTEN_TYPES,\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT,\n  REALTIME_PRESENCE_LISTEN_EVENTS,\n  REALTIME_SUBSCRIBE_STATES,\n  REALTIME_CHANNEL_STATES,\n}\n", "import WebSocket from './WebSocket'\n\nimport {\n  CHANNEL_EVENTS,\n  CONNECTION_STATE,\n  DEFAULT_HEADERS,\n  DEFAULT_TIMEOUT,\n  SOCKET_STATES,\n  TRANSPORTS,\n  VSN,\n  WS_CLOSE_NORMAL,\n} from './lib/constants'\n\nimport Serializer from './lib/serializer'\nimport Timer from './lib/timer'\n\nimport { httpEndpointURL } from './lib/transformers'\nimport RealtimeChannel from './RealtimeChannel'\nimport type { RealtimeChannelOptions } from './RealtimeChannel'\n\ntype Fetch = typeof fetch\n\nexport type Channel = {\n  name: string\n  inserted_at: string\n  updated_at: string\n  id: number\n}\nexport type LogLevel = 'info' | 'warn' | 'error'\n\nexport type RealtimeMessage = {\n  topic: string\n  event: string\n  payload: any\n  ref: string\n  join_ref?: string\n}\n\nexport type RealtimeRemoveChannelResponse = 'ok' | 'timed out' | 'error'\nexport type HeartbeatStatus =\n  | 'sent'\n  | 'ok'\n  | 'error'\n  | 'timeout'\n  | 'disconnected'\n\nconst noop = () => {}\n\nexport interface WebSocketLikeConstructor {\n  new (\n    address: string | URL,\n    _ignored?: any,\n    options?: { headers: Object | undefined }\n  ): WebSocketLike\n}\n\nexport type WebSocketLike = WebSocket | WSWebSocketDummy\n\nexport interface WebSocketLikeError {\n  error: any\n  message: string\n  type: string\n}\n\nexport type RealtimeClientOptions = {\n  transport?: WebSocketLikeConstructor\n  timeout?: number\n  heartbeatIntervalMs?: number\n  logger?: Function\n  encode?: Function\n  decode?: Function\n  reconnectAfterMs?: Function\n  headers?: { [key: string]: string }\n  params?: { [key: string]: any }\n  //Deprecated: Use it in favour of correct casing `logLevel`\n  log_level?: LogLevel\n  logLevel?: LogLevel\n  fetch?: Fetch\n  worker?: boolean\n  workerUrl?: string\n  accessToken?: () => Promise<string | null>\n}\n\nconst WORKER_SCRIPT = `\n  addEventListener(\"message\", (e) => {\n    if (e.data.event === \"start\") {\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\n    }\n  });`\n\nexport default class RealtimeClient {\n  accessTokenValue: string | null = null\n  apiKey: string | null = null\n  channels: RealtimeChannel[] = new Array()\n  endPoint: string = ''\n  httpEndpoint: string = ''\n  headers?: { [key: string]: string } = DEFAULT_HEADERS\n  params?: { [key: string]: string } = {}\n  timeout: number = DEFAULT_TIMEOUT\n  transport: WebSocketLikeConstructor | null\n  heartbeatIntervalMs: number = 25000\n  heartbeatTimer: ReturnType<typeof setInterval> | undefined = undefined\n  pendingHeartbeatRef: string | null = null\n  heartbeatCallback: (status: HeartbeatStatus) => void = noop\n  ref: number = 0\n  reconnectTimer: Timer\n  logger: Function = noop\n  logLevel?: LogLevel\n  encode: Function\n  decode: Function\n  reconnectAfterMs: Function\n  conn: WebSocketLike | null = null\n  sendBuffer: Function[] = []\n  serializer: Serializer = new Serializer()\n  stateChangeCallbacks: {\n    open: Function[]\n    close: Function[]\n    error: Function[]\n    message: Function[]\n  } = {\n    open: [],\n    close: [],\n    error: [],\n    message: [],\n  }\n  fetch: Fetch\n  accessToken: (() => Promise<string | null>) | null = null\n  worker?: boolean\n  workerUrl?: string\n  workerRef?: Worker\n\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.logLevel Sets the log level for Realtime\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   * @param options.worker Use Web Worker to set a side flow. Defaults to false.\n   * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\n   */\n  constructor(endPoint: string, options?: RealtimeClientOptions) {\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\n    this.httpEndpoint = httpEndpointURL(endPoint)\n    if (options?.transport) {\n      this.transport = options.transport\n    } else {\n      this.transport = null\n    }\n    if (options?.params) this.params = options.params\n    if (options?.headers) this.headers = { ...this.headers, ...options.headers }\n    if (options?.timeout) this.timeout = options.timeout\n    if (options?.logger) this.logger = options.logger\n    if (options?.logLevel || options?.log_level) {\n      this.logLevel = options.logLevel || options.log_level\n      this.params = { ...this.params, log_level: this.logLevel as string }\n    }\n\n    if (options?.heartbeatIntervalMs)\n      this.heartbeatIntervalMs = options.heartbeatIntervalMs\n\n    const accessTokenValue = options?.params?.apikey\n    if (accessTokenValue) {\n      this.accessTokenValue = accessTokenValue\n      this.apiKey = accessTokenValue\n    }\n\n    this.reconnectAfterMs = options?.reconnectAfterMs\n      ? options.reconnectAfterMs\n      : (tries: number) => {\n          return [1000, 2000, 5000, 10000][tries - 1] || 10000\n        }\n    this.encode = options?.encode\n      ? options.encode\n      : (payload: JSON, callback: Function) => {\n          return callback(JSON.stringify(payload))\n        }\n    this.decode = options?.decode\n      ? options.decode\n      : this.serializer.decode.bind(this.serializer)\n    this.reconnectTimer = new Timer(async () => {\n      this.disconnect()\n      this.connect()\n    }, this.reconnectAfterMs)\n\n    this.fetch = this._resolveFetch(options?.fetch)\n    if (options?.worker) {\n      if (typeof window !== 'undefined' && !window.Worker) {\n        throw new Error('Web Worker is not supported')\n      }\n      this.worker = options?.worker || false\n      this.workerUrl = options?.workerUrl\n    }\n    this.accessToken = options?.accessToken || null\n  }\n\n  /**\n   * Connects the socket, unless already connected.\n   */\n  connect(): void {\n    if (this.conn) {\n      return\n    }\n    if (!this.transport) {\n      this.transport = WebSocket\n    }\n    if (this.transport) {\n      // Detect if using the native browser WebSocket\n      const isBrowser =\n        typeof window !== 'undefined' && this.transport === window.WebSocket\n      if (isBrowser) {\n        this.conn = new this.transport(this.endpointURL())\n      } else {\n        this.conn = new this.transport(this.endpointURL(), undefined, {\n          headers: this.headers,\n        })\n      }\n      this.setupConnection()\n      return\n    }\n    this.conn = new WSWebSocketDummy(this.endpointURL(), undefined, {\n      close: () => {\n        this.conn = null\n      },\n    })\n  }\n\n  /**\n   * Returns the URL of the websocket.\n   * @returns string The URL of the websocket.\n   */\n  endpointURL(): string {\n    return this._appendParams(\n      this.endPoint,\n      Object.assign({}, this.params, { vsn: VSN })\n    )\n  }\n\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n  disconnect(code?: number, reason?: string): void {\n    if (this.conn) {\n      this.conn.onclose = function () {} // noop\n      if (code) {\n        this.conn.close(code, reason ?? '')\n      } else {\n        this.conn.close()\n      }\n      this.conn = null\n\n      // remove open handles\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n      this.reconnectTimer.reset()\n      this.channels.forEach((channel) => channel.teardown())\n    }\n  }\n\n  /**\n   * Returns all created channels\n   */\n  getChannels(): RealtimeChannel[] {\n    return this.channels\n  }\n\n  /**\n   * Unsubscribes and removes a single channel\n   * @param channel A RealtimeChannel instance\n   */\n  async removeChannel(\n    channel: RealtimeChannel\n  ): Promise<RealtimeRemoveChannelResponse> {\n    const status = await channel.unsubscribe()\n    this.channels = this.channels.filter((c) => c._joinRef !== channel._joinRef)\n\n    if (this.channels.length === 0) {\n      this.disconnect()\n    }\n\n    return status\n  }\n\n  /**\n   * Unsubscribes and removes all channels\n   */\n  async removeAllChannels(): Promise<RealtimeRemoveChannelResponse[]> {\n    const values_1 = await Promise.all(\n      this.channels.map((channel) => channel.unsubscribe())\n    )\n    this.channels = []\n    this.disconnect()\n    return values_1\n  }\n\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overridden.\n   */\n  log(kind: string, msg: string, data?: any) {\n    this.logger(kind, msg, data)\n  }\n\n  /**\n   * Returns the current state of the socket.\n   */\n  connectionState(): CONNECTION_STATE {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing\n      default:\n        return CONNECTION_STATE.Closed\n    }\n  }\n\n  /**\n   * Returns `true` is the connection is open.\n   */\n  isConnected(): boolean {\n    return this.connectionState() === CONNECTION_STATE.Open\n  }\n\n  channel(\n    topic: string,\n    params: RealtimeChannelOptions = { config: {} }\n  ): RealtimeChannel {\n    const realtimeTopic = `realtime:${topic}`\n    const exists = this.getChannels().find(\n      (c: RealtimeChannel) => c.topic === realtimeTopic\n    )\n\n    if (!exists) {\n      const chan = new RealtimeChannel(`realtime:${topic}`, params, this)\n      this.channels.push(chan)\n\n      return chan\n    } else {\n      return exists\n    }\n  }\n\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n  push(data: RealtimeMessage): void {\n    const { topic, event, payload, ref } = data\n    const callback = () => {\n      this.encode(data, (result: any) => {\n        this.conn?.send(result)\n      })\n    }\n    this.log('push', `${topic} ${event} (${ref})`, payload)\n    if (this.isConnected()) {\n      callback()\n    } else {\n      this.sendBuffer.push(callback)\n    }\n  }\n\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * If param is null it will use the `accessToken` callback function or the token set on the client.\n   *\n   * On callback used, it will set the value of the token internal to the client.\n   *\n   * @param token A JWT string to override the token set on the client.\n   */\n  async setAuth(token: string | null = null): Promise<void> {\n    let tokenToSend =\n      token ||\n      (this.accessToken && (await this.accessToken())) ||\n      this.accessTokenValue\n\n    if (this.accessTokenValue != tokenToSend) {\n      this.accessTokenValue = tokenToSend\n      this.channels.forEach((channel) => {\n        tokenToSend &&\n          channel.updateJoinPayload({\n            access_token: tokenToSend,\n            version: this.headers && this.headers['X-Client-Info'],\n          })\n\n        if (channel.joinedOnce && channel._isJoined()) {\n          channel._push(CHANNEL_EVENTS.access_token, {\n            access_token: tokenToSend,\n          })\n        }\n      })\n    }\n  }\n  /**\n   * Sends a heartbeat message if the socket is connected.\n   */\n  async sendHeartbeat() {\n    if (!this.isConnected()) {\n      this.heartbeatCallback('disconnected')\n      return\n    }\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null\n      this.log(\n        'transport',\n        'heartbeat timeout. Attempting to re-establish connection'\n      )\n      this.heartbeatCallback('timeout')\n      this.conn?.close(WS_CLOSE_NORMAL, 'hearbeat timeout')\n      return\n    }\n    this.pendingHeartbeatRef = this._makeRef()\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef,\n    })\n    this.heartbeatCallback('sent')\n    await this.setAuth()\n  }\n\n  onHeartbeat(callback: (status: HeartbeatStatus) => void): void {\n    this.heartbeatCallback = callback\n  }\n  /**\n   * Flushes send buffer\n   */\n  flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback())\n      this.sendBuffer = []\n    }\n  }\n\n  /**\n   * Use either custom fetch, if provided, or default fetch to make HTTP requests\n   *\n   * @internal\n   */\n  _resolveFetch = (customFetch?: Fetch): Fetch => {\n    let _fetch: Fetch\n    if (customFetch) {\n      _fetch = customFetch\n    } else if (typeof fetch === 'undefined') {\n      _fetch = (...args) =>\n        import('@supabase/node-fetch' as any).then(({ default: fetch }) =>\n          fetch(...args)\n        )\n    } else {\n      _fetch = fetch\n    }\n    return (...args) => _fetch(...args)\n  }\n\n  /**\n   * Return the next message ref, accounting for overflows\n   *\n   * @internal\n   */\n  _makeRef(): string {\n    let newRef = this.ref + 1\n    if (newRef === this.ref) {\n      this.ref = 0\n    } else {\n      this.ref = newRef\n    }\n\n    return this.ref.toString()\n  }\n\n  /**\n   * Unsubscribe from channels with the specified topic.\n   *\n   * @internal\n   */\n  _leaveOpenTopic(topic: string): void {\n    let dupChannel = this.channels.find(\n      (c) => c.topic === topic && (c._isJoined() || c._isJoining())\n    )\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`)\n      dupChannel.unsubscribe()\n    }\n  }\n\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   *\n   * @internal\n   */\n  _remove(channel: RealtimeChannel) {\n    this.channels = this.channels.filter((c) => c.topic !== channel.topic)\n  }\n\n  /**\n   * Sets up connection handlers.\n   *\n   * @internal\n   */\n  private setupConnection(): void {\n    if (this.conn) {\n      this.conn.binaryType = 'arraybuffer'\n      this.conn.onopen = () => this._onConnOpen()\n      this.conn.onerror = (error: WebSocketLikeError) =>\n        this._onConnError(error as WebSocketLikeError)\n      this.conn.onmessage = (event: any) => this._onConnMessage(event)\n      this.conn.onclose = (event: any) => this._onConnClose(event)\n    }\n  }\n\n  /** @internal */\n  private _onConnMessage(rawMessage: { data: any }) {\n    this.decode(rawMessage.data, (msg: RealtimeMessage) => {\n      let { topic, event, payload, ref } = msg\n\n      if (topic === 'phoenix' && event === 'phx_reply') {\n        this.heartbeatCallback(msg.payload.status == 'ok' ? 'ok' : 'error')\n      }\n\n      if (ref && ref === this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null\n      }\n\n      this.log(\n        'receive',\n        `${payload.status || ''} ${topic} ${event} ${\n          (ref && '(' + ref + ')') || ''\n        }`,\n        payload\n      )\n\n      Array.from(this.channels)\n        .filter((channel: RealtimeChannel) => channel._isMember(topic))\n        .forEach((channel: RealtimeChannel) =>\n          channel._trigger(event, payload, ref)\n        )\n\n      this.stateChangeCallbacks.message.forEach((callback) => callback(msg))\n    })\n  }\n\n  /** @internal */\n  private _onConnOpen() {\n    this.log('transport', `connected to ${this.endpointURL()}`)\n    this.flushSendBuffer()\n    this.reconnectTimer.reset()\n    if (!this.worker) {\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n      this.heartbeatTimer = setInterval(\n        () => this.sendHeartbeat(),\n        this.heartbeatIntervalMs\n      )\n    } else {\n      if (this.workerUrl) {\n        this.log('worker', `starting worker for from ${this.workerUrl}`)\n      } else {\n        this.log('worker', `starting default worker`)\n      }\n      const objectUrl = this._workerObjectUrl(this.workerUrl!)\n      this.workerRef = new Worker(objectUrl)\n      this.workerRef.onerror = (error) => {\n        this.log('worker', 'worker error', (error as ErrorEvent).message)\n        this.workerRef!.terminate()\n      }\n      this.workerRef.onmessage = (event) => {\n        if (event.data.event === 'keepAlive') {\n          this.sendHeartbeat()\n        }\n      }\n      this.workerRef.postMessage({\n        event: 'start',\n        interval: this.heartbeatIntervalMs,\n      })\n    }\n    this.stateChangeCallbacks.open.forEach((callback) => callback())\n  }\n\n  /** @internal */\n  private _onConnClose(event: any) {\n    this.log('transport', 'close', event)\n    this._triggerChanError()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.reconnectTimer.scheduleTimeout()\n    this.stateChangeCallbacks.close.forEach((callback) => callback(event))\n  }\n\n  /** @internal */\n  private _onConnError(error: WebSocketLikeError) {\n    this.log('transport', error.message)\n    this._triggerChanError()\n    this.stateChangeCallbacks.error.forEach((callback) => callback(error))\n  }\n\n  /** @internal */\n  private _triggerChanError() {\n    this.channels.forEach((channel: RealtimeChannel) =>\n      channel._trigger(CHANNEL_EVENTS.error)\n    )\n  }\n\n  /** @internal */\n  private _appendParams(\n    url: string,\n    params: { [key: string]: string }\n  ): string {\n    if (Object.keys(params).length === 0) {\n      return url\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?'\n    const query = new URLSearchParams(params)\n    return `${url}${prefix}${query}`\n  }\n\n  private _workerObjectUrl(url: string | undefined): string {\n    let result_url: string\n    if (url) {\n      result_url = url\n    } else {\n      const blob = new Blob([WORKER_SCRIPT], { type: 'application/javascript' })\n      result_url = URL.createObjectURL(blob)\n    }\n    return result_url\n  }\n}\n\nclass WSWebSocketDummy {\n  binaryType: string = 'arraybuffer'\n  close: Function\n  onclose: Function = () => {}\n  onerror: Function = () => {}\n  onmessage: Function = () => {}\n  onopen: Function = () => {}\n  readyState: number = SOCKET_STATES.connecting\n  send: Function = () => {}\n  url: string | URL | null = null\n\n  constructor(\n    address: string,\n    _protocols: undefined,\n    options: { close: Function }\n  ) {\n    this.url = address\n    this.close = options.close\n  }\n}\n", "// Node.js WebSocket entry point\n\nlet WebSocketImpl: any\n\nif (typeof window === 'undefined') {\n  // Node.js environment\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  WebSocketImpl = require('ws')\n} else {\n  // Browser environment\n  WebSocketImpl = window.WebSocket\n}\n\nexport default WebSocketImpl\n", "import { version } from './version'\n\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `realtime-js/${version}` }\n\nexport const VSN: string = '1.0.0'\n\nexport const VERSION = version\n\nexport const DEFAULT_TIMEOUT = 10000\n\nexport const WS_CLOSE_NORMAL = 1000\n\nexport enum SOCKET_STATES {\n  connecting = 0,\n  open = 1,\n  closing = 2,\n  closed = 3,\n}\n\nexport enum CHANNEL_STATES {\n  closed = 'closed',\n  errored = 'errored',\n  joined = 'joined',\n  joining = 'joining',\n  leaving = 'leaving',\n}\n\nexport enum CHANNEL_EVENTS {\n  close = 'phx_close',\n  error = 'phx_error',\n  join = 'phx_join',\n  reply = 'phx_reply',\n  leave = 'phx_leave',\n  access_token = 'access_token',\n}\n\nexport enum TRANSPORTS {\n  websocket = 'websocket',\n}\n\nexport enum CONNECTION_STATE {\n  Connecting = 'connecting',\n  Open = 'open',\n  Closing = 'closing',\n  Closed = 'closed',\n}\n", "export const version = '2.11.10'\n", "// This file draws heavily from https://github.com/phoenixframework/phoenix/commit/cf098e9cf7a44ee6479d31d911a97d3c7430c6fe\n// License: https://github.com/phoenixframework/phoenix/blob/master/LICENSE.md\n\nexport default class Serializer {\n  HEADER_LENGTH = 1\n\n  decode(rawPayload: ArrayBuffer | string, callback: Function) {\n    if (rawPayload.constructor === ArrayBuffer) {\n      return callback(this._binaryDecode(rawPayload))\n    }\n\n    if (typeof rawPayload === 'string') {\n      return callback(JSON.parse(rawPayload))\n    }\n\n    return callback({})\n  }\n\n  private _binaryDecode(buffer: ArrayBuffer) {\n    const view = new DataView(buffer)\n    const decoder = new TextDecoder()\n\n    return this._decodeBroadcast(buffer, view, decoder)\n  }\n\n  private _decodeBroadcast(\n    buffer: ArrayBuffer,\n    view: DataView,\n    decoder: TextDecoder\n  ): {\n    ref: null\n    topic: string\n    event: string\n    payload: { [key: string]: any }\n  } {\n    const topicSize = view.getUint8(1)\n    const eventSize = view.getUint8(2)\n    let offset = this.HEADER_LENGTH + 2\n    const topic = decoder.decode(buffer.slice(offset, offset + topicSize))\n    offset = offset + topicSize\n    const event = decoder.decode(buffer.slice(offset, offset + eventSize))\n    offset = offset + eventSize\n    const data = JSON.parse(\n      decoder.decode(buffer.slice(offset, buffer.byteLength))\n    )\n\n    return { ref: null, topic: topic, event: event, payload: data }\n  }\n}\n", "/**\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\n *\n * @example\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *      return [1000, 5000, 10000][tries - 1] || 10000\n *    })\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n *    reconnectTimer.scheduleTimeout() // fires after 5000\n *    reconnectTimer.reset()\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n */\nexport default class Timer {\n  timer: number | undefined = undefined\n  tries: number = 0\n\n  constructor(public callback: Function, public timerCalc: Function) {\n    this.callback = callback\n    this.timerCalc = timerCalc\n  }\n\n  reset() {\n    this.tries = 0\n    clearTimeout(this.timer)\n  }\n\n  // Cancels any previous scheduleTimeout and schedules callback\n  scheduleTimeout() {\n    clearTimeout(this.timer)\n\n    this.timer = <any>setTimeout(() => {\n      this.tries = this.tries + 1\n      this.callback()\n    }, this.timerCalc(this.tries + 1))\n  }\n}\n", "/**\n * Helpers to convert the change Payload into native JS types.\n */\n\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\n\nexport enum PostgresTypes {\n  abstime = 'abstime',\n  bool = 'bool',\n  date = 'date',\n  daterange = 'daterange',\n  float4 = 'float4',\n  float8 = 'float8',\n  int2 = 'int2',\n  int4 = 'int4',\n  int4range = 'int4range',\n  int8 = 'int8',\n  int8range = 'int8range',\n  json = 'json',\n  jsonb = 'jsonb',\n  money = 'money',\n  numeric = 'numeric',\n  oid = 'oid',\n  reltime = 'reltime',\n  text = 'text',\n  time = 'time',\n  timestamp = 'timestamp',\n  timestamptz = 'timestamptz',\n  timetz = 'timetz',\n  tsrange = 'tsrange',\n  tstzrange = 'tstzrange',\n}\n\ntype Columns = {\n  name: string // the column name. eg: \"user_id\"\n  type: string // the column type. eg: \"uuid\"\n  flags?: string[] // any special flags for the column. eg: [\"key\"]\n  type_modifier?: number // the type modifier. eg: 4294967295\n}[]\n\ntype BaseValue = null | string | number | boolean\ntype RecordValue = BaseValue | BaseValue[]\n\ntype Record = {\n  [key: string]: RecordValue\n}\n\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} record\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */\nexport const convertChangeData = (\n  columns: Columns,\n  record: Record,\n  options: { skipTypes?: string[] } = {}\n): Record => {\n  const skipTypes = options.skipTypes ?? []\n\n  return Object.keys(record).reduce((acc, rec_key) => {\n    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes)\n    return acc\n  }, {} as Record)\n}\n\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} record The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */\nexport const convertColumn = (\n  columnName: string,\n  columns: Columns,\n  record: Record,\n  skipTypes: string[]\n): RecordValue => {\n  const column = columns.find((x) => x.name === columnName)\n  const colType = column?.type\n  const value = record[columnName]\n\n  if (colType && !skipTypes.includes(colType)) {\n    return convertCell(colType, value)\n  }\n\n  return noop(value)\n}\n\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} value The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */\nexport const convertCell = (type: string, value: RecordValue): RecordValue => {\n  // if data type is an array\n  if (type.charAt(0) === '_') {\n    const dataType = type.slice(1, type.length)\n    return toArray(value, dataType)\n  }\n\n  // If not null, convert to correct type.\n  switch (type) {\n    case PostgresTypes.bool:\n      return toBoolean(value)\n    case PostgresTypes.float4:\n    case PostgresTypes.float8:\n    case PostgresTypes.int2:\n    case PostgresTypes.int4:\n    case PostgresTypes.int8:\n    case PostgresTypes.numeric:\n    case PostgresTypes.oid:\n      return toNumber(value)\n    case PostgresTypes.json:\n    case PostgresTypes.jsonb:\n      return toJson(value)\n    case PostgresTypes.timestamp:\n      return toTimestampString(value) // Format to be consistent with PostgREST\n    case PostgresTypes.abstime: // To allow users to cast it based on Timezone\n    case PostgresTypes.date: // To allow users to cast it based on Timezone\n    case PostgresTypes.daterange:\n    case PostgresTypes.int4range:\n    case PostgresTypes.int8range:\n    case PostgresTypes.money:\n    case PostgresTypes.reltime: // To allow users to cast it based on Timezone\n    case PostgresTypes.text:\n    case PostgresTypes.time: // To allow users to cast it based on Timezone\n    case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone\n    case PostgresTypes.timetz: // To allow users to cast it based on Timezone\n    case PostgresTypes.tsrange:\n    case PostgresTypes.tstzrange:\n      return noop(value)\n    default:\n      // Return the value for remaining types\n      return noop(value)\n  }\n}\n\nconst noop = (value: RecordValue): RecordValue => {\n  return value\n}\nexport const toBoolean = (value: RecordValue): RecordValue => {\n  switch (value) {\n    case 't':\n      return true\n    case 'f':\n      return false\n    default:\n      return value\n  }\n}\nexport const toNumber = (value: RecordValue): RecordValue => {\n  if (typeof value === 'string') {\n    const parsedValue = parseFloat(value)\n    if (!Number.isNaN(parsedValue)) {\n      return parsedValue\n    }\n  }\n  return value\n}\nexport const toJson = (value: RecordValue): RecordValue => {\n  if (typeof value === 'string') {\n    try {\n      return JSON.parse(value)\n    } catch (error) {\n      console.log(`JSON parse error: ${error}`)\n      return value\n    }\n  }\n  return value\n}\n\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{}', 'int4')\n * //=> []\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\n * @example toArray([1,2,3,4], 'int4')\n * //=> [1,2,3,4]\n */\nexport const toArray = (value: RecordValue, type: string): RecordValue => {\n  if (typeof value !== 'string') {\n    return value\n  }\n\n  const lastIdx = value.length - 1\n  const closeBrace = value[lastIdx]\n  const openBrace = value[0]\n\n  // Confirm value is a Postgres array by checking curly brackets\n  if (openBrace === '{' && closeBrace === '}') {\n    let arr\n    const valTrim = value.slice(1, lastIdx)\n\n    // TODO: find a better solution to separate Postgres array data\n    try {\n      arr = JSON.parse('[' + valTrim + ']')\n    } catch (_) {\n      // WARNING: splitting on comma does not cover all edge cases\n      arr = valTrim ? valTrim.split(',') : []\n    }\n\n    return arr.map((val: BaseValue) => convertCell(type, val))\n  }\n\n  return value\n}\n\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */\nexport const toTimestampString = (value: RecordValue): RecordValue => {\n  if (typeof value === 'string') {\n    return value.replace(' ', 'T')\n  }\n\n  return value\n}\n\nexport const httpEndpointURL = (socketUrl: string): string => {\n  let url = socketUrl\n  url = url.replace(/^ws/i, 'http')\n  url = url.replace(/(\\/socket\\/websocket|\\/socket|\\/websocket)\\/?$/i, '')\n  return url.replace(/\\/+$/, '')\n}\n", "import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants'\nimport Push from './lib/push'\nimport type RealtimeClient from './RealtimeClient'\nimport Timer from './lib/timer'\nimport RealtimePresence, {\n  REALTIME_PRESENCE_LISTEN_EVENTS,\n} from './RealtimePresence'\nimport type {\n  RealtimePresenceJoinPayload,\n  RealtimePresenceLeavePayload,\n  RealtimePresenceState,\n} from './RealtimePresence'\nimport * as Transformers from './lib/transformers'\nimport { httpEndpointURL } from './lib/transformers'\n\nexport type RealtimeChannelOptions = {\n  config: {\n    /**\n     * self option enables client to receive message it broadcast\n     * ack option instructs server to acknowledge that broadcast message was received\n     */\n    broadcast?: { self?: boolean; ack?: boolean }\n    /**\n     * key option is used to track presence payload across clients\n     */\n    presence?: { key?: string }\n    /**\n     * defines if the channel is private or not and if RLS policies will be used to check data\n     */\n    private?: boolean\n  }\n}\n\ntype RealtimePostgresChangesPayloadBase = {\n  schema: string\n  table: string\n  commit_timestamp: string\n  errors: string[]\n}\n\nexport type RealtimePostgresInsertPayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`\n    new: T\n    old: {}\n  }\n\nexport type RealtimePostgresUpdatePayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`\n    new: T\n    old: Partial<T>\n  }\n\nexport type RealtimePostgresDeletePayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`\n    new: {}\n    old: Partial<T>\n  }\n\nexport type RealtimePostgresChangesPayload<T extends { [key: string]: any }> =\n  | RealtimePostgresInsertPayload<T>\n  | RealtimePostgresUpdatePayload<T>\n  | RealtimePostgresDeletePayload<T>\n\nexport type RealtimePostgresChangesFilter<\n  T extends `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT}`\n> = {\n  /**\n   * The type of database change to listen to.\n   */\n  event: T\n  /**\n   * The database schema to listen to.\n   */\n  schema: string\n  /**\n   * The database table to listen to.\n   */\n  table?: string\n  /**\n   * Receive database changes when filter is matched.\n   */\n  filter?: string\n}\n\nexport type RealtimeChannelSendResponse = 'ok' | 'timed out' | 'error'\n\nexport enum REALTIME_POSTGRES_CHANGES_LISTEN_EVENT {\n  ALL = '*',\n  INSERT = 'INSERT',\n  UPDATE = 'UPDATE',\n  DELETE = 'DELETE',\n}\n\nexport enum REALTIME_LISTEN_TYPES {\n  BROADCAST = 'broadcast',\n  PRESENCE = 'presence',\n  POSTGRES_CHANGES = 'postgres_changes',\n  SYSTEM = 'system',\n}\n\nexport enum REALTIME_SUBSCRIBE_STATES {\n  SUBSCRIBED = 'SUBSCRIBED',\n  TIMED_OUT = 'TIMED_OUT',\n  CLOSED = 'CLOSED',\n  CHANNEL_ERROR = 'CHANNEL_ERROR',\n}\n\nexport const REALTIME_CHANNEL_STATES = CHANNEL_STATES\n\ninterface PostgresChangesFilters {\n  postgres_changes: {\n    id: string\n    event: string\n    schema?: string\n    table?: string\n    filter?: string\n  }[]\n}\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */\nexport default class RealtimeChannel {\n  bindings: {\n    [key: string]: {\n      type: string\n      filter: { [key: string]: any }\n      callback: Function\n      id?: string\n    }[]\n  } = {}\n  timeout: number\n  state = CHANNEL_STATES.closed\n  joinedOnce = false\n  joinPush: Push\n  rejoinTimer: Timer\n  pushBuffer: Push[] = []\n  presence: RealtimePresence\n  broadcastEndpointURL: string\n  subTopic: string\n  private: boolean\n\n  constructor(\n    /** Topic name can be any string. */\n    public topic: string,\n    public params: RealtimeChannelOptions = { config: {} },\n    public socket: RealtimeClient\n  ) {\n    this.subTopic = topic.replace(/^realtime:/i, '')\n    this.params.config = {\n      ...{\n        broadcast: { ack: false, self: false },\n        presence: { key: '' },\n        private: false,\n      },\n      ...params.config,\n    }\n    this.timeout = this.socket.timeout\n    this.joinPush = new Push(\n      this,\n      CHANNEL_EVENTS.join,\n      this.params,\n      this.timeout\n    )\n    this.rejoinTimer = new Timer(\n      () => this._rejoinUntilConnected(),\n      this.socket.reconnectAfterMs\n    )\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined\n      this.rejoinTimer.reset()\n      this.pushBuffer.forEach((pushEvent: Push) => pushEvent.send())\n      this.pushBuffer = []\n    })\n    this._onClose(() => {\n      this.rejoinTimer.reset()\n      this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`)\n      this.state = CHANNEL_STATES.closed\n      this.socket._remove(this)\n    })\n    this._onError((reason: string) => {\n      if (this._isLeaving() || this._isClosed()) {\n        return\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.joinPush.receive('timeout', () => {\n      if (!this._isJoining()) {\n        return\n      }\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this._on(CHANNEL_EVENTS.reply, {}, (payload: any, ref: string) => {\n      this._trigger(this._replyEventName(ref), payload)\n    })\n\n    this.presence = new RealtimePresence(this)\n\n    this.broadcastEndpointURL =\n      httpEndpointURL(this.socket.endPoint) + '/api/broadcast'\n    this.private = this.params.config.private || false\n  }\n\n  /** Subscribe registers your client with the server */\n  subscribe(\n    callback?: (status: REALTIME_SUBSCRIBE_STATES, err?: Error) => void,\n    timeout = this.timeout\n  ): RealtimeChannel {\n    if (!this.socket.isConnected()) {\n      this.socket.connect()\n    }\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`\n    } else {\n      const {\n        config: { broadcast, presence, private: isPrivate },\n      } = this.params\n\n      this._onError((e: Error) =>\n        callback?.(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e)\n      )\n      this._onClose(() => callback?.(REALTIME_SUBSCRIBE_STATES.CLOSED))\n\n      const accessTokenPayload: { access_token?: string } = {}\n      const config = {\n        broadcast,\n        presence,\n        postgres_changes:\n          this.bindings.postgres_changes?.map((r) => r.filter) ?? [],\n        private: isPrivate,\n      }\n\n      if (this.socket.accessTokenValue) {\n        accessTokenPayload.access_token = this.socket.accessTokenValue\n      }\n\n      this.updateJoinPayload({ ...{ config }, ...accessTokenPayload })\n\n      this.joinedOnce = true\n      this._rejoin(timeout)\n\n      this.joinPush\n        .receive('ok', async ({ postgres_changes }: PostgresChangesFilters) => {\n          this.socket.setAuth()\n          if (postgres_changes === undefined) {\n            callback?.(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED)\n            return\n          } else {\n            const clientPostgresBindings = this.bindings.postgres_changes\n            const bindingsLen = clientPostgresBindings?.length ?? 0\n            const newPostgresBindings = []\n\n            for (let i = 0; i < bindingsLen; i++) {\n              const clientPostgresBinding = clientPostgresBindings[i]\n              const {\n                filter: { event, schema, table, filter },\n              } = clientPostgresBinding\n              const serverPostgresFilter =\n                postgres_changes && postgres_changes[i]\n\n              if (\n                serverPostgresFilter &&\n                serverPostgresFilter.event === event &&\n                serverPostgresFilter.schema === schema &&\n                serverPostgresFilter.table === table &&\n                serverPostgresFilter.filter === filter\n              ) {\n                newPostgresBindings.push({\n                  ...clientPostgresBinding,\n                  id: serverPostgresFilter.id,\n                })\n              } else {\n                this.unsubscribe()\n                this.state = CHANNEL_STATES.errored\n\n                callback?.(\n                  REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR,\n                  new Error(\n                    'mismatch between server and client bindings for postgres changes'\n                  )\n                )\n                return\n              }\n            }\n\n            this.bindings.postgres_changes = newPostgresBindings\n\n            callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED)\n            return\n          }\n        })\n        .receive('error', (error: { [key: string]: any }) => {\n          this.state = CHANNEL_STATES.errored\n          callback?.(\n            REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR,\n            new Error(\n              JSON.stringify(Object.values(error).join(', ') || 'error')\n            )\n          )\n          return\n        })\n        .receive('timeout', () => {\n          callback?.(REALTIME_SUBSCRIBE_STATES.TIMED_OUT)\n          return\n        })\n    }\n    return this\n  }\n\n  presenceState<\n    T extends { [key: string]: any } = {}\n  >(): RealtimePresenceState<T> {\n    return this.presence.state as RealtimePresenceState<T>\n  }\n\n  async track(\n    payload: { [key: string]: any },\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    return await this.send(\n      {\n        type: 'presence',\n        event: 'track',\n        payload,\n      },\n      opts.timeout || this.timeout\n    )\n  }\n\n  async untrack(\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    return await this.send(\n      {\n        type: 'presence',\n        event: 'untrack',\n      },\n      opts\n    )\n  }\n\n  /**\n   * Creates an event handler that listens to changes.\n   */\n  on(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.SYNC}` },\n    callback: () => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.JOIN}` },\n    callback: (payload: RealtimePresenceJoinPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.LEAVE}` },\n    callback: (payload: RealtimePresenceLeavePayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.ALL}`>,\n    callback: (payload: RealtimePostgresChangesPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`>,\n    callback: (payload: RealtimePostgresInsertPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`>,\n    callback: (payload: RealtimePostgresUpdatePayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`>,\n    callback: (payload: RealtimePostgresDeletePayload<T>) => void\n  ): RealtimeChannel\n  /**\n   * The following is placed here to display on supabase.com/docs/reference/javascript/subscribe.\n   * @param type One of \"broadcast\", \"presence\", or \"postgres_changes\".\n   * @param filter Custom object specific to the Realtime feature detailing which payloads to receive.\n   * @param callback Function to be invoked when event handler is triggered.\n   */\n  on(\n    type: `${REALTIME_LISTEN_TYPES.BROADCAST}`,\n    filter: { event: string },\n    callback: (payload: {\n      type: `${REALTIME_LISTEN_TYPES.BROADCAST}`\n      event: string\n      [key: string]: any\n    }) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.BROADCAST}`,\n    filter: { event: string },\n    callback: (payload: {\n      type: `${REALTIME_LISTEN_TYPES.BROADCAST}`\n      event: string\n      payload: T\n    }) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.SYSTEM}`,\n    filter: {},\n    callback: (payload: any) => void\n  ): RealtimeChannel\n  on(\n    type: `${REALTIME_LISTEN_TYPES}`,\n    filter: { event: string; [key: string]: string },\n    callback: (payload: any) => void\n  ): RealtimeChannel {\n    return this._on(type, filter, callback)\n  }\n  /**\n   * Sends a message into the channel.\n   *\n   * @param args Arguments to send to channel\n   * @param args.type The type of event to send\n   * @param args.event The name of the event being sent\n   * @param args.payload Payload to be sent\n   * @param opts Options to be used during the send process\n   */\n  async send(\n    args: {\n      type: 'broadcast' | 'presence' | 'postgres_changes'\n      event: string\n      payload?: any\n      [key: string]: any\n    },\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    if (!this._canPush() && args.type === 'broadcast') {\n      const { event, payload: endpoint_payload } = args\n      const authorization = this.socket.accessTokenValue\n        ? `Bearer ${this.socket.accessTokenValue}`\n        : ''\n      const options = {\n        method: 'POST',\n        headers: {\n          Authorization: authorization,\n          apikey: this.socket.apiKey ? this.socket.apiKey : '',\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          messages: [\n            {\n              topic: this.subTopic,\n              event,\n              payload: endpoint_payload,\n              private: this.private,\n            },\n          ],\n        }),\n      }\n\n      try {\n        const response = await this._fetchWithTimeout(\n          this.broadcastEndpointURL,\n          options,\n          opts.timeout ?? this.timeout\n        )\n\n        await response.body?.cancel()\n        return response.ok ? 'ok' : 'error'\n      } catch (error: any) {\n        if (error.name === 'AbortError') {\n          return 'timed out'\n        } else {\n          return 'error'\n        }\n      }\n    } else {\n      return new Promise((resolve) => {\n        const push = this._push(args.type, args, opts.timeout || this.timeout)\n\n        if (args.type === 'broadcast' && !this.params?.config?.broadcast?.ack) {\n          resolve('ok')\n        }\n\n        push.receive('ok', () => resolve('ok'))\n        push.receive('error', () => resolve('error'))\n        push.receive('timeout', () => resolve('timed out'))\n      })\n    }\n  }\n\n  updateJoinPayload(payload: { [key: string]: any }): void {\n    this.joinPush.updatePayload(payload)\n  }\n\n  /**\n   * Leaves the channel.\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n  unsubscribe(timeout = this.timeout): Promise<'ok' | 'timed out' | 'error'> {\n    this.state = CHANNEL_STATES.leaving\n    const onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`)\n      this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef())\n    }\n\n    this.joinPush.destroy()\n\n    return new Promise((resolve) => {\n      const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout)\n      leavePush\n        .receive('ok', () => {\n          onClose()\n          resolve('ok')\n        })\n        .receive('timeout', () => {\n          onClose()\n          resolve('timed out')\n        })\n        .receive('error', () => {\n          resolve('error')\n        })\n\n      leavePush.send()\n      if (!this._canPush()) {\n        leavePush.trigger('ok', {})\n      }\n    })\n  }\n  /**\n   * Teardown the channel.\n   *\n   * Destroys and stops related timers.\n   */\n  teardown() {\n    this.pushBuffer.forEach((push: Push) => push.destroy())\n    this.rejoinTimer && clearTimeout(this.rejoinTimer.timer)\n    this.joinPush.destroy()\n  }\n\n  /** @internal */\n\n  async _fetchWithTimeout(\n    url: string,\n    options: { [key: string]: any },\n    timeout: number\n  ) {\n    const controller = new AbortController()\n    const id = setTimeout(() => controller.abort(), timeout)\n\n    const response = await this.socket.fetch(url, {\n      ...options,\n      signal: controller.signal,\n    })\n\n    clearTimeout(id)\n\n    return response\n  }\n\n  /** @internal */\n  _push(\n    event: string,\n    payload: { [key: string]: any },\n    timeout = this.timeout\n  ) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`\n    }\n    let pushEvent = new Push(this, event, payload, timeout)\n    if (this._canPush()) {\n      pushEvent.send()\n    } else {\n      pushEvent.startTimeout()\n      this.pushBuffer.push(pushEvent)\n    }\n\n    return pushEvent\n  }\n\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   *\n   * @internal\n   */\n  _onMessage(_event: string, payload: any, _ref?: string) {\n    return payload\n  }\n\n  /** @internal */\n  _isMember(topic: string): boolean {\n    return this.topic === topic\n  }\n\n  /** @internal */\n  _joinRef(): string {\n    return this.joinPush.ref\n  }\n\n  /** @internal */\n  _trigger(type: string, payload?: any, ref?: string) {\n    const typeLower = type.toLocaleLowerCase()\n    const { close, error, leave, join } = CHANNEL_EVENTS\n    const events: string[] = [close, error, leave, join]\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n      return\n    }\n    let handledPayload = this._onMessage(typeLower, payload, ref)\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified'\n    }\n\n    if (['insert', 'update', 'delete'].includes(typeLower)) {\n      this.bindings.postgres_changes\n        ?.filter((bind) => {\n          return (\n            bind.filter?.event === '*' ||\n            bind.filter?.event?.toLocaleLowerCase() === typeLower\n          )\n        })\n        .map((bind) => bind.callback(handledPayload, ref))\n    } else {\n      this.bindings[typeLower]\n        ?.filter((bind) => {\n          if (\n            ['broadcast', 'presence', 'postgres_changes'].includes(typeLower)\n          ) {\n            if ('id' in bind) {\n              const bindId = bind.id\n              const bindEvent = bind.filter?.event\n              return (\n                bindId &&\n                payload.ids?.includes(bindId) &&\n                (bindEvent === '*' ||\n                  bindEvent?.toLocaleLowerCase() ===\n                    payload.data?.type.toLocaleLowerCase())\n              )\n            } else {\n              const bindEvent = bind?.filter?.event?.toLocaleLowerCase()\n              return (\n                bindEvent === '*' ||\n                bindEvent === payload?.event?.toLocaleLowerCase()\n              )\n            }\n          } else {\n            return bind.type.toLocaleLowerCase() === typeLower\n          }\n        })\n        .map((bind) => {\n          if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n            const postgresChanges = handledPayload.data\n            const { schema, table, commit_timestamp, type, errors } =\n              postgresChanges\n            const enrichedPayload = {\n              schema: schema,\n              table: table,\n              commit_timestamp: commit_timestamp,\n              eventType: type,\n              new: {},\n              old: {},\n              errors: errors,\n            }\n            handledPayload = {\n              ...enrichedPayload,\n              ...this._getPayloadRecords(postgresChanges),\n            }\n          }\n          bind.callback(handledPayload, ref)\n        })\n    }\n  }\n\n  /** @internal */\n  _isClosed(): boolean {\n    return this.state === CHANNEL_STATES.closed\n  }\n\n  /** @internal */\n  _isJoined(): boolean {\n    return this.state === CHANNEL_STATES.joined\n  }\n\n  /** @internal */\n  _isJoining(): boolean {\n    return this.state === CHANNEL_STATES.joining\n  }\n\n  /** @internal */\n  _isLeaving(): boolean {\n    return this.state === CHANNEL_STATES.leaving\n  }\n\n  /** @internal */\n  _replyEventName(ref: string): string {\n    return `chan_reply_${ref}`\n  }\n\n  /** @internal */\n  _on(type: string, filter: { [key: string]: any }, callback: Function) {\n    const typeLower = type.toLocaleLowerCase()\n\n    const binding = {\n      type: typeLower,\n      filter: filter,\n      callback: callback,\n    }\n\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower].push(binding)\n    } else {\n      this.bindings[typeLower] = [binding]\n    }\n\n    return this\n  }\n\n  /** @internal */\n  _off(type: string, filter: { [key: string]: any }) {\n    const typeLower = type.toLocaleLowerCase()\n\n    this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\n      return !(\n        bind.type?.toLocaleLowerCase() === typeLower &&\n        RealtimeChannel.isEqual(bind.filter, filter)\n      )\n    })\n    return this\n  }\n\n  /** @internal */\n  private static isEqual(\n    obj1: { [key: string]: string },\n    obj2: { [key: string]: string }\n  ) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false\n    }\n\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /** @internal */\n  private _rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout()\n    if (this.socket.isConnected()) {\n      this._rejoin()\n    }\n  }\n\n  /**\n   * Registers a callback that will be executed when the channel closes.\n   *\n   * @internal\n   */\n  private _onClose(callback: Function) {\n    this._on(CHANNEL_EVENTS.close, {}, callback)\n  }\n\n  /**\n   * Registers a callback that will be executed when the channel encounteres an error.\n   *\n   * @internal\n   */\n  private _onError(callback: Function) {\n    this._on(CHANNEL_EVENTS.error, {}, (reason: string) => callback(reason))\n  }\n\n  /**\n   * Returns `true` if the socket is connected and the channel has been joined.\n   *\n   * @internal\n   */\n  private _canPush(): boolean {\n    return this.socket.isConnected() && this._isJoined()\n  }\n\n  /** @internal */\n  private _rejoin(timeout = this.timeout): void {\n    if (this._isLeaving()) {\n      return\n    }\n    this.socket._leaveOpenTopic(this.topic)\n    this.state = CHANNEL_STATES.joining\n    this.joinPush.resend(timeout)\n  }\n\n  /** @internal */\n  private _getPayloadRecords(payload: any) {\n    const records = {\n      new: {},\n      old: {},\n    }\n\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n      records.new = Transformers.convertChangeData(\n        payload.columns,\n        payload.record\n      )\n    }\n\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n      records.old = Transformers.convertChangeData(\n        payload.columns,\n        payload.old_record\n      )\n    }\n\n    return records\n  }\n}\n", "import { DEFAULT_TIMEOUT } from '../lib/constants'\nimport type RealtimeChannel from '../RealtimeChannel'\n\nexport default class Push {\n  sent: boolean = false\n  timeoutTimer: number | undefined = undefined\n  ref: string = ''\n  receivedResp: {\n    status: string\n    response: { [key: string]: any }\n  } | null = null\n  recHooks: {\n    status: string\n    callback: Function\n  }[] = []\n  refEvent: string | null = null\n\n  /**\n   * Initializes the Push\n   *\n   * @param channel The Channel\n   * @param event The event, for example `\"phx_join\"`\n   * @param payload The payload, for example `{user_id: 123}`\n   * @param timeout The push timeout in milliseconds\n   */\n  constructor(\n    public channel: RealtimeChannel,\n    public event: string,\n    public payload: { [key: string]: any } = {},\n    public timeout: number = DEFAULT_TIMEOUT\n  ) {}\n\n  resend(timeout: number) {\n    this.timeout = timeout\n    this._cancelRefEvent()\n    this.ref = ''\n    this.refEvent = null\n    this.receivedResp = null\n    this.sent = false\n    this.send()\n  }\n\n  send() {\n    if (this._hasReceived('timeout')) {\n      return\n    }\n    this.startTimeout()\n    this.sent = true\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload,\n      ref: this.ref,\n      join_ref: this.channel._joinRef(),\n    })\n  }\n\n  updatePayload(payload: { [key: string]: any }): void {\n    this.payload = { ...this.payload, ...payload }\n  }\n\n  receive(status: string, callback: Function) {\n    if (this._hasReceived(status)) {\n      callback(this.receivedResp?.response)\n    }\n\n    this.recHooks.push({ status, callback })\n    return this\n  }\n\n  startTimeout() {\n    if (this.timeoutTimer) {\n      return\n    }\n    this.ref = this.channel.socket._makeRef()\n    this.refEvent = this.channel._replyEventName(this.ref)\n\n    const callback = (payload: any) => {\n      this._cancelRefEvent()\n      this._cancelTimeout()\n      this.receivedResp = payload\n      this._matchReceive(payload)\n    }\n\n    this.channel._on(this.refEvent, {}, callback)\n\n    this.timeoutTimer = <any>setTimeout(() => {\n      this.trigger('timeout', {})\n    }, this.timeout)\n  }\n\n  trigger(status: string, response: any) {\n    if (this.refEvent)\n      this.channel._trigger(this.refEvent, { status, response })\n  }\n\n  destroy() {\n    this._cancelRefEvent()\n    this._cancelTimeout()\n  }\n\n  private _cancelRefEvent() {\n    if (!this.refEvent) {\n      return\n    }\n\n    this.channel._off(this.refEvent, {})\n  }\n\n  private _cancelTimeout() {\n    clearTimeout(this.timeoutTimer)\n    this.timeoutTimer = undefined\n  }\n\n  private _matchReceive({\n    status,\n    response,\n  }: {\n    status: string\n    response: Function\n  }) {\n    this.recHooks\n      .filter((h) => h.status === status)\n      .forEach((h) => h.callback(response))\n  }\n\n  private _hasReceived(status: string) {\n    return this.receivedResp && this.receivedResp.status === status\n  }\n}\n", "/*\n  This file draws heavily from https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/assets/js/phoenix/presence.js\n  License: https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/LICENSE.md\n*/\n\nimport type {\n  PresenceOpts,\n  PresenceOnJoinCallback,\n  PresenceOnLeaveCallback,\n} from 'phoenix'\nimport type RealtimeChannel from './RealtimeChannel'\n\ntype Presence<T extends { [key: string]: any } = {}> = {\n  presence_ref: string\n} & T\n\nexport type RealtimePresenceState<T extends { [key: string]: any } = {}> = {\n  [key: string]: Presence<T>[]\n}\n\nexport type RealtimePresenceJoinPayload<T extends { [key: string]: any }> = {\n  event: `${REALTIME_PRESENCE_LISTEN_EVENTS.JOIN}`\n  key: string\n  currentPresences: Presence<T>[]\n  newPresences: Presence<T>[]\n}\n\nexport type RealtimePresenceLeavePayload<T extends { [key: string]: any }> = {\n  event: `${REALTIME_PRESENCE_LISTEN_EVENTS.LEAVE}`\n  key: string\n  currentPresences: Presence<T>[]\n  leftPresences: Presence<T>[]\n}\n\nexport enum REALTIME_PRESENCE_LISTEN_EVENTS {\n  SYNC = 'sync',\n  JOIN = 'join',\n  LEAVE = 'leave',\n}\n\ntype PresenceDiff = {\n  joins: RealtimePresenceState\n  leaves: RealtimePresenceState\n}\n\ntype RawPresenceState = {\n  [key: string]: {\n    metas: {\n      phx_ref?: string\n      phx_ref_prev?: string\n      [key: string]: any\n    }[]\n  }\n}\n\ntype RawPresenceDiff = {\n  joins: RawPresenceState\n  leaves: RawPresenceState\n}\n\ntype PresenceChooser<T> = (key: string, presences: Presence[]) => T\n\nexport default class RealtimePresence {\n  state: RealtimePresenceState = {}\n  pendingDiffs: RawPresenceDiff[] = []\n  joinRef: string | null = null\n  caller: {\n    onJoin: PresenceOnJoinCallback\n    onLeave: PresenceOnLeaveCallback\n    onSync: () => void\n  } = {\n    onJoin: () => {},\n    onLeave: () => {},\n    onSync: () => {},\n  }\n\n  /**\n   * Initializes the Presence.\n   *\n   * @param channel - The RealtimeChannel\n   * @param opts - The options,\n   *        for example `{events: {state: 'state', diff: 'diff'}}`\n   */\n  constructor(public channel: RealtimeChannel, opts?: PresenceOpts) {\n    const events = opts?.events || {\n      state: 'presence_state',\n      diff: 'presence_diff',\n    }\n\n    this.channel._on(events.state, {}, (newState: RawPresenceState) => {\n      const { onJoin, onLeave, onSync } = this.caller\n\n      this.joinRef = this.channel._joinRef()\n\n      this.state = RealtimePresence.syncState(\n        this.state,\n        newState,\n        onJoin,\n        onLeave\n      )\n\n      this.pendingDiffs.forEach((diff) => {\n        this.state = RealtimePresence.syncDiff(\n          this.state,\n          diff,\n          onJoin,\n          onLeave\n        )\n      })\n\n      this.pendingDiffs = []\n\n      onSync()\n    })\n\n    this.channel._on(events.diff, {}, (diff: RawPresenceDiff) => {\n      const { onJoin, onLeave, onSync } = this.caller\n\n      if (this.inPendingSyncState()) {\n        this.pendingDiffs.push(diff)\n      } else {\n        this.state = RealtimePresence.syncDiff(\n          this.state,\n          diff,\n          onJoin,\n          onLeave\n        )\n\n        onSync()\n      }\n    })\n\n    this.onJoin((key, currentPresences, newPresences) => {\n      this.channel._trigger('presence', {\n        event: 'join',\n        key,\n        currentPresences,\n        newPresences,\n      })\n    })\n\n    this.onLeave((key, currentPresences, leftPresences) => {\n      this.channel._trigger('presence', {\n        event: 'leave',\n        key,\n        currentPresences,\n        leftPresences,\n      })\n    })\n\n    this.onSync(() => {\n      this.channel._trigger('presence', { event: 'sync' })\n    })\n  }\n\n  /**\n   * Used to sync the list of presences on the server with the\n   * client's state.\n   *\n   * An optional `onJoin` and `onLeave` callback can be provided to\n   * react to changes in the client's local presences across\n   * disconnects and reconnects with the server.\n   *\n   * @internal\n   */\n  private static syncState(\n    currentState: RealtimePresenceState,\n    newState: RawPresenceState | RealtimePresenceState,\n    onJoin: PresenceOnJoinCallback,\n    onLeave: PresenceOnLeaveCallback\n  ): RealtimePresenceState {\n    const state = this.cloneDeep(currentState)\n    const transformedState = this.transformState(newState)\n    const joins: RealtimePresenceState = {}\n    const leaves: RealtimePresenceState = {}\n\n    this.map(state, (key: string, presences: Presence[]) => {\n      if (!transformedState[key]) {\n        leaves[key] = presences\n      }\n    })\n\n    this.map(transformedState, (key, newPresences: Presence[]) => {\n      const currentPresences: Presence[] = state[key]\n\n      if (currentPresences) {\n        const newPresenceRefs = newPresences.map(\n          (m: Presence) => m.presence_ref\n        )\n        const curPresenceRefs = currentPresences.map(\n          (m: Presence) => m.presence_ref\n        )\n        const joinedPresences: Presence[] = newPresences.filter(\n          (m: Presence) => curPresenceRefs.indexOf(m.presence_ref) < 0\n        )\n        const leftPresences: Presence[] = currentPresences.filter(\n          (m: Presence) => newPresenceRefs.indexOf(m.presence_ref) < 0\n        )\n\n        if (joinedPresences.length > 0) {\n          joins[key] = joinedPresences\n        }\n\n        if (leftPresences.length > 0) {\n          leaves[key] = leftPresences\n        }\n      } else {\n        joins[key] = newPresences\n      }\n    })\n\n    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave)\n  }\n\n  /**\n   * Used to sync a diff of presence join and leave events from the\n   * server, as they happen.\n   *\n   * Like `syncState`, `syncDiff` accepts optional `onJoin` and\n   * `onLeave` callbacks to react to a user joining or leaving from a\n   * device.\n   *\n   * @internal\n   */\n  private static syncDiff(\n    state: RealtimePresenceState,\n    diff: RawPresenceDiff | PresenceDiff,\n    onJoin: PresenceOnJoinCallback,\n    onLeave: PresenceOnLeaveCallback\n  ): RealtimePresenceState {\n    const { joins, leaves } = {\n      joins: this.transformState(diff.joins),\n      leaves: this.transformState(diff.leaves),\n    }\n\n    if (!onJoin) {\n      onJoin = () => {}\n    }\n\n    if (!onLeave) {\n      onLeave = () => {}\n    }\n\n    this.map(joins, (key, newPresences: Presence[]) => {\n      const currentPresences: Presence[] = state[key] ?? []\n      state[key] = this.cloneDeep(newPresences)\n\n      if (currentPresences.length > 0) {\n        const joinedPresenceRefs = state[key].map(\n          (m: Presence) => m.presence_ref\n        )\n        const curPresences: Presence[] = currentPresences.filter(\n          (m: Presence) => joinedPresenceRefs.indexOf(m.presence_ref) < 0\n        )\n\n        state[key].unshift(...curPresences)\n      }\n\n      onJoin(key, currentPresences, newPresences)\n    })\n\n    this.map(leaves, (key, leftPresences: Presence[]) => {\n      let currentPresences: Presence[] = state[key]\n\n      if (!currentPresences) return\n\n      const presenceRefsToRemove = leftPresences.map(\n        (m: Presence) => m.presence_ref\n      )\n      currentPresences = currentPresences.filter(\n        (m: Presence) => presenceRefsToRemove.indexOf(m.presence_ref) < 0\n      )\n\n      state[key] = currentPresences\n\n      onLeave(key, currentPresences, leftPresences)\n\n      if (currentPresences.length === 0) delete state[key]\n    })\n\n    return state\n  }\n\n  /** @internal */\n  private static map<T = any>(\n    obj: RealtimePresenceState,\n    func: PresenceChooser<T>\n  ): T[] {\n    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]))\n  }\n\n  /**\n   * Remove 'metas' key\n   * Change 'phx_ref' to 'presence_ref'\n   * Remove 'phx_ref' and 'phx_ref_prev'\n   *\n   * @example\n   * // returns {\n   *  abc123: [\n   *    { presence_ref: '2', user_id: 1 },\n   *    { presence_ref: '3', user_id: 2 }\n   *  ]\n   * }\n   * RealtimePresence.transformState({\n   *  abc123: {\n   *    metas: [\n   *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },\n   *      { phx_ref: '3', user_id: 2 }\n   *    ]\n   *  }\n   * })\n   *\n   * @internal\n   */\n  private static transformState(\n    state: RawPresenceState | RealtimePresenceState\n  ): RealtimePresenceState {\n    state = this.cloneDeep(state)\n\n    return Object.getOwnPropertyNames(state).reduce((newState, key) => {\n      const presences = state[key]\n\n      if ('metas' in presences) {\n        newState[key] = presences.metas.map((presence) => {\n          presence['presence_ref'] = presence['phx_ref']\n\n          delete presence['phx_ref']\n          delete presence['phx_ref_prev']\n\n          return presence\n        }) as Presence[]\n      } else {\n        newState[key] = presences\n      }\n\n      return newState\n    }, {} as RealtimePresenceState)\n  }\n\n  /** @internal */\n  private static cloneDeep(obj: { [key: string]: any }) {\n    return JSON.parse(JSON.stringify(obj))\n  }\n\n  /** @internal */\n  private onJoin(callback: PresenceOnJoinCallback): void {\n    this.caller.onJoin = callback\n  }\n\n  /** @internal */\n  private onLeave(callback: PresenceOnLeaveCallback): void {\n    this.caller.onLeave = callback\n  }\n\n  /** @internal */\n  private onSync(callback: () => void): void {\n    this.caller.onSync = callback\n  }\n\n  /** @internal */\n  private inPendingSyncState(): boolean {\n    return !this.joinRef || this.joinRef !== this.channel._joinRef()\n  }\n}\n", "export { StorageClient as StorageClient } from './StorageClient'\nexport * from './lib/types'\nexport * from './lib/errors'\n", "import StorageFileApi from './packages/StorageFileApi'\nimport StorageBucketApi from './packages/StorageBucketApi'\nimport { Fetch } from './lib/fetch'\n\nexport class StorageClient extends StorageBucketApi {\n  constructor(url: string, headers: { [key: string]: string } = {}, fetch?: Fetch) {\n    super(url, headers, fetch)\n  }\n\n  /**\n   * Perform file operation in a bucket.\n   *\n   * @param id The bucket id to operate on.\n   */\n  from(id: string): StorageFileApi {\n    return new StorageFileApi(this.url, this.headers, id, this.fetch)\n  }\n}\n", "export class StorageError extends Error {\n  protected __isStorageError = true\n\n  constructor(message: string) {\n    super(message)\n    this.name = 'StorageError'\n  }\n}\n\nexport function isStorageError(error: unknown): error is StorageError {\n  return typeof error === 'object' && error !== null && '__isStorageError' in error\n}\n\nexport class StorageApiError extends StorageError {\n  status: number\n\n  constructor(message: string, status: number) {\n    super(message)\n    this.name = 'StorageApiError'\n    this.status = status\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status,\n    }\n  }\n}\n\nexport class StorageUnknownError extends StorageError {\n  originalError: unknown\n\n  constructor(message: string, originalError: unknown) {\n    super(message)\n    this.name = 'StorageUnknownError'\n    this.originalError = originalError\n  }\n}\n", "type Fetch = typeof fetch\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  let _fetch: Fetch\n  if (customFetch) {\n    _fetch = customFetch\n  } else if (typeof fetch === 'undefined') {\n    _fetch = (...args) =>\n      import('@supabase/node-fetch' as any).then(({ default: fetch }) => fetch(...args))\n  } else {\n    _fetch = fetch\n  }\n  return (...args) => _fetch(...args)\n}\n\nexport const resolveResponse = async (): Promise<typeof Response> => {\n  if (typeof Response === 'undefined') {\n    // @ts-ignore\n    return (await import('@supabase/node-fetch' as any)).Response\n  }\n\n  return Response\n}\n\nexport const recursiveToCamel = (item: Record<string, any>): unknown => {\n  if (Array.isArray(item)) {\n    return item.map((el) => recursiveToCamel(el))\n  } else if (typeof item === 'function' || item !== Object(item)) {\n    return item\n  }\n\n  const result: Record<string, any> = {}\n  Object.entries(item).forEach(([key, value]) => {\n    const newKey = key.replace(/([-_][a-z])/gi, (c) => c.toUpperCase().replace(/[-_]/g, ''))\n    result[newKey] = recursiveToCamel(value)\n  })\n\n  return result\n}\n", "import { StorageApiError, StorageUnknownError } from './errors'\nimport { resolveResponse } from './helpers'\nimport { FetchParameters } from './types'\n\nexport type Fetch = typeof fetch\n\nexport interface FetchOptions {\n  headers?: {\n    [key: string]: string\n  }\n  noResolveJson?: boolean\n}\n\nexport type RequestMethodType = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD'\n\nconst _getErrorMessage = (err: any): string =>\n  err.msg || err.message || err.error_description || err.error || JSON.stringify(err)\n\nconst handleError = async (\n  error: unknown,\n  reject: (reason?: any) => void,\n  options?: FetchOptions\n) => {\n  const Res = await resolveResponse()\n\n  if (error instanceof Res && !options?.noResolveJson) {\n    error\n      .json()\n      .then((err) => {\n        reject(new StorageApiError(_getErrorMessage(err), error.status || 500))\n      })\n      .catch((err) => {\n        reject(new StorageUnknownError(_getErrorMessage(err), err))\n      })\n  } else {\n    reject(new StorageUnknownError(_getErrorMessage(error), error))\n  }\n}\n\nconst _getRequestParams = (\n  method: RequestMethodType,\n  options?: FetchOptions,\n  parameters?: FetchParameters,\n  body?: object\n) => {\n  const params: { [k: string]: any } = { method, headers: options?.headers || {} }\n\n  if (method === 'GET') {\n    return params\n  }\n\n  params.headers = { 'Content-Type': 'application/json', ...options?.headers }\n\n  if (body) {\n    params.body = JSON.stringify(body)\n  }\n  return { ...params, ...parameters }\n}\n\nasync function _handleRequest(\n  fetcher: Fetch,\n  method: RequestMethodType,\n  url: string,\n  options?: FetchOptions,\n  parameters?: FetchParameters,\n  body?: object\n): Promise<any> {\n  return new Promise((resolve, reject) => {\n    fetcher(url, _getRequestParams(method, options, parameters, body))\n      .then((result) => {\n        if (!result.ok) throw result\n        if (options?.noResolveJson) return result\n        return result.json()\n      })\n      .then((data) => resolve(data))\n      .catch((error) => handleError(error, reject, options))\n  })\n}\n\nexport async function get(\n  fetcher: Fetch,\n  url: string,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'GET', url, options, parameters)\n}\n\nexport async function post(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'POST', url, options, parameters, body)\n}\n\nexport async function put(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'PUT', url, options, parameters, body)\n}\n\nexport async function head(\n  fetcher: Fetch,\n  url: string,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(\n    fetcher,\n    'HEAD',\n    url,\n    {\n      ...options,\n      noResolveJson: true,\n    },\n    parameters\n  )\n}\n\nexport async function remove(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'DELETE', url, options, parameters, body)\n}\n", "import { isStorageError, StorageError, StorageUnknownError } from '../lib/errors'\nimport { Fetch, get, head, post, remove } from '../lib/fetch'\nimport { recursiveToCamel, resolveFetch } from '../lib/helpers'\nimport {\n  FileObject,\n  FileOptions,\n  SearchOptions,\n  FetchParameters,\n  TransformOptions,\n  DestinationOptions,\n  FileObjectV2,\n  Camelize,\n} from '../lib/types'\n\nconst DEFAULT_SEARCH_OPTIONS = {\n  limit: 100,\n  offset: 0,\n  sortBy: {\n    column: 'name',\n    order: 'asc',\n  },\n}\n\nconst DEFAULT_FILE_OPTIONS: FileOptions = {\n  cacheControl: '3600',\n  contentType: 'text/plain;charset=UTF-8',\n  upsert: false,\n}\n\ntype FileBody =\n  | ArrayBuffer\n  | ArrayBufferView\n  | Blob\n  | Buffer\n  | File\n  | FormData\n  | NodeJS.ReadableStream\n  | ReadableStream<Uint8Array>\n  | URLSearchParams\n  | string\n\nexport default class StorageFileApi {\n  protected url: string\n  protected headers: { [key: string]: string }\n  protected bucketId?: string\n  protected fetch: Fetch\n\n  constructor(\n    url: string,\n    headers: { [key: string]: string } = {},\n    bucketId?: string,\n    fetch?: Fetch\n  ) {\n    this.url = url\n    this.headers = headers\n    this.bucketId = bucketId\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /**\n   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n   *\n   * @param method HTTP method.\n   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param fileBody The body of the file to be stored in the bucket.\n   */\n  private async uploadOrUpdate(\n    method: 'POST' | 'PUT',\n    path: string,\n    fileBody: FileBody,\n    fileOptions?: FileOptions\n  ): Promise<\n    | {\n        data: { id: string; path: string; fullPath: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      let body\n      const options = { ...DEFAULT_FILE_OPTIONS, ...fileOptions }\n      let headers: Record<string, string> = {\n        ...this.headers,\n        ...(method === 'POST' && { 'x-upsert': String(options.upsert as boolean) }),\n      }\n\n      const metadata = options.metadata\n\n      if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n        body = new FormData()\n        body.append('cacheControl', options.cacheControl as string)\n        if (metadata) {\n          body.append('metadata', this.encodeMetadata(metadata))\n        }\n        body.append('', fileBody)\n      } else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n        body = fileBody\n        body.append('cacheControl', options.cacheControl as string)\n        if (metadata) {\n          body.append('metadata', this.encodeMetadata(metadata))\n        }\n      } else {\n        body = fileBody\n        headers['cache-control'] = `max-age=${options.cacheControl}`\n        headers['content-type'] = options.contentType as string\n\n        if (metadata) {\n          headers['x-metadata'] = this.toBase64(this.encodeMetadata(metadata))\n        }\n      }\n\n      if (fileOptions?.headers) {\n        headers = { ...headers, ...fileOptions.headers }\n      }\n\n      const cleanPath = this._removeEmptyFolders(path)\n      const _path = this._getFinalPath(cleanPath)\n      const res = await this.fetch(`${this.url}/object/${_path}`, {\n        method,\n        body: body as BodyInit,\n        headers,\n        ...(options?.duplex ? { duplex: options.duplex } : {}),\n      })\n\n      const data = await res.json()\n\n      if (res.ok) {\n        return {\n          data: { path: cleanPath, id: data.Id, fullPath: data.Key },\n          error: null,\n        }\n      } else {\n        const error = data\n        return { data: null, error }\n      }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Uploads a file to an existing bucket.\n   *\n   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param fileBody The body of the file to be stored in the bucket.\n   */\n  async upload(\n    path: string,\n    fileBody: FileBody,\n    fileOptions?: FileOptions\n  ): Promise<\n    | {\n        data: { id: string; path: string; fullPath: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    return this.uploadOrUpdate('POST', path, fileBody, fileOptions)\n  }\n\n  /**\n   * Upload a file with a token generated from `createSignedUploadUrl`.\n   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param token The token generated from `createSignedUploadUrl`\n   * @param fileBody The body of the file to be stored in the bucket.\n   */\n  async uploadToSignedUrl(\n    path: string,\n    token: string,\n    fileBody: FileBody,\n    fileOptions?: FileOptions\n  ) {\n    const cleanPath = this._removeEmptyFolders(path)\n    const _path = this._getFinalPath(cleanPath)\n\n    const url = new URL(this.url + `/object/upload/sign/${_path}`)\n    url.searchParams.set('token', token)\n\n    try {\n      let body\n      const options = { upsert: DEFAULT_FILE_OPTIONS.upsert, ...fileOptions }\n      const headers: Record<string, string> = {\n        ...this.headers,\n        ...{ 'x-upsert': String(options.upsert as boolean) },\n      }\n\n      if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n        body = new FormData()\n        body.append('cacheControl', options.cacheControl as string)\n        body.append('', fileBody)\n      } else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n        body = fileBody\n        body.append('cacheControl', options.cacheControl as string)\n      } else {\n        body = fileBody\n        headers['cache-control'] = `max-age=${options.cacheControl}`\n        headers['content-type'] = options.contentType as string\n      }\n\n      const res = await this.fetch(url.toString(), {\n        method: 'PUT',\n        body: body as BodyInit,\n        headers,\n      })\n\n      const data = await res.json()\n\n      if (res.ok) {\n        return {\n          data: { path: cleanPath, fullPath: data.Key },\n          error: null,\n        }\n      } else {\n        const error = data\n        return { data: null, error }\n      }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates a signed upload URL.\n   * Signed upload URLs can be used to upload files to the bucket without further authentication.\n   * They are valid for 2 hours.\n   * @param path The file path, including the current file name. For example `folder/image.png`.\n   * @param options.upsert If set to true, allows the file to be overwritten if it already exists.\n   */\n  async createSignedUploadUrl(\n    path: string,\n    options?: { upsert: boolean }\n  ): Promise<\n    | {\n        data: { signedUrl: string; token: string; path: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      let _path = this._getFinalPath(path)\n\n      const headers = { ...this.headers }\n\n      if (options?.upsert) {\n        headers['x-upsert'] = 'true'\n      }\n\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/upload/sign/${_path}`,\n        {},\n        { headers }\n      )\n\n      const url = new URL(this.url + data.url)\n\n      const token = url.searchParams.get('token')\n\n      if (!token) {\n        throw new StorageError('No token returned by API')\n      }\n\n      return { data: { signedUrl: url.toString(), path, token }, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Replaces an existing file at the specified path with a new one.\n   *\n   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.\n   * @param fileBody The body of the file to be stored in the bucket.\n   */\n  async update(\n    path: string,\n    fileBody:\n      | ArrayBuffer\n      | ArrayBufferView\n      | Blob\n      | Buffer\n      | File\n      | FormData\n      | NodeJS.ReadableStream\n      | ReadableStream<Uint8Array>\n      | URLSearchParams\n      | string,\n    fileOptions?: FileOptions\n  ): Promise<\n    | {\n        data: { id: string; path: string; fullPath: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    return this.uploadOrUpdate('PUT', path, fileBody, fileOptions)\n  }\n\n  /**\n   * Moves an existing file to a new path in the same bucket.\n   *\n   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n   * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n   * @param options The destination options.\n   */\n  async move(\n    fromPath: string,\n    toPath: string,\n    options?: DestinationOptions\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/move`,\n        {\n          bucketId: this.bucketId,\n          sourceKey: fromPath,\n          destinationKey: toPath,\n          destinationBucket: options?.destinationBucket,\n        },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Copies an existing file to a new path in the same bucket.\n   *\n   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n   * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n   * @param options The destination options.\n   */\n  async copy(\n    fromPath: string,\n    toPath: string,\n    options?: DestinationOptions\n  ): Promise<\n    | {\n        data: { path: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/copy`,\n        {\n          bucketId: this.bucketId,\n          sourceKey: fromPath,\n          destinationKey: toPath,\n          destinationBucket: options?.destinationBucket,\n        },\n        { headers: this.headers }\n      )\n      return { data: { path: data.Key }, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.\n   *\n   * @param path The file path, including the current file name. For example `folder/image.png`.\n   * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n   * @param options.transform Transform the asset before serving it to the client.\n   */\n  async createSignedUrl(\n    path: string,\n    expiresIn: number,\n    options?: { download?: string | boolean; transform?: TransformOptions }\n  ): Promise<\n    | {\n        data: { signedUrl: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      let _path = this._getFinalPath(path)\n\n      let data = await post(\n        this.fetch,\n        `${this.url}/object/sign/${_path}`,\n        { expiresIn, ...(options?.transform ? { transform: options.transform } : {}) },\n        { headers: this.headers }\n      )\n      const downloadQueryParam = options?.download\n        ? `&download=${options.download === true ? '' : options.download}`\n        : ''\n      const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`)\n      data = { signedUrl }\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.\n   *\n   * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n   * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n   */\n  async createSignedUrls(\n    paths: string[],\n    expiresIn: number,\n    options?: { download: string | boolean }\n  ): Promise<\n    | {\n        data: { error: string | null; path: string | null; signedUrl: string }[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/sign/${this.bucketId}`,\n        { expiresIn, paths },\n        { headers: this.headers }\n      )\n\n      const downloadQueryParam = options?.download\n        ? `&download=${options.download === true ? '' : options.download}`\n        : ''\n      return {\n        data: data.map((datum: { signedURL: string }) => ({\n          ...datum,\n          signedUrl: datum.signedURL\n            ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`)\n            : null,\n        })),\n        error: null,\n      }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.\n   *\n   * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.\n   * @param options.transform Transform the asset before serving it to the client.\n   */\n  async download(\n    path: string,\n    options?: { transform?: TransformOptions }\n  ): Promise<\n    | {\n        data: Blob\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    const wantsTransformation = typeof options?.transform !== 'undefined'\n    const renderPath = wantsTransformation ? 'render/image/authenticated' : 'object'\n    const transformationQuery = this.transformOptsToQueryString(options?.transform || {})\n    const queryString = transformationQuery ? `?${transformationQuery}` : ''\n\n    try {\n      const _path = this._getFinalPath(path)\n      const res = await get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {\n        headers: this.headers,\n        noResolveJson: true,\n      })\n      const data = await res.blob()\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Retrieves the details of an existing file.\n   * @param path\n   */\n  async info(\n    path: string\n  ): Promise<\n    | {\n        data: Camelize<FileObjectV2>\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    const _path = this._getFinalPath(path)\n\n    try {\n      const data = await get(this.fetch, `${this.url}/object/info/${_path}`, {\n        headers: this.headers,\n      })\n\n      return { data: recursiveToCamel(data) as Camelize<FileObjectV2>, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Checks the existence of a file.\n   * @param path\n   */\n  async exists(\n    path: string\n  ): Promise<\n    | {\n        data: boolean\n        error: null\n      }\n    | {\n        data: boolean\n        error: StorageError\n      }\n  > {\n    const _path = this._getFinalPath(path)\n\n    try {\n      await head(this.fetch, `${this.url}/object/${_path}`, {\n        headers: this.headers,\n      })\n\n      return { data: true, error: null }\n    } catch (error) {\n      if (isStorageError(error) && error instanceof StorageUnknownError) {\n        const originalError = (error.originalError as unknown) as { status: number }\n\n        if ([400, 404].includes(originalError?.status)) {\n          return { data: false, error }\n        }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.\n   * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.\n   *\n   * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.\n   * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n   * @param options.transform Transform the asset before serving it to the client.\n   */\n  getPublicUrl(\n    path: string,\n    options?: { download?: string | boolean; transform?: TransformOptions }\n  ): { data: { publicUrl: string } } {\n    const _path = this._getFinalPath(path)\n    const _queryString = []\n\n    const downloadQueryParam = options?.download\n      ? `download=${options.download === true ? '' : options.download}`\n      : ''\n\n    if (downloadQueryParam !== '') {\n      _queryString.push(downloadQueryParam)\n    }\n\n    const wantsTransformation = typeof options?.transform !== 'undefined'\n    const renderPath = wantsTransformation ? 'render/image' : 'object'\n    const transformationQuery = this.transformOptsToQueryString(options?.transform || {})\n\n    if (transformationQuery !== '') {\n      _queryString.push(transformationQuery)\n    }\n\n    let queryString = _queryString.join('&')\n    if (queryString !== '') {\n      queryString = `?${queryString}`\n    }\n\n    return {\n      data: { publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`) },\n    }\n  }\n\n  /**\n   * Deletes files within the same bucket\n   *\n   * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].\n   */\n  async remove(\n    paths: string[]\n  ): Promise<\n    | {\n        data: FileObject[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await remove(\n        this.fetch,\n        `${this.url}/object/${this.bucketId}`,\n        { prefixes: paths },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Get file metadata\n   * @param id the file id to retrieve metadata\n   */\n  // async getMetadata(\n  //   id: string\n  // ): Promise<\n  //   | {\n  //       data: Metadata\n  //       error: null\n  //     }\n  //   | {\n  //       data: null\n  //       error: StorageError\n  //     }\n  // > {\n  //   try {\n  //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })\n  //     return { data, error: null }\n  //   } catch (error) {\n  //     if (isStorageError(error)) {\n  //       return { data: null, error }\n  //     }\n\n  //     throw error\n  //   }\n  // }\n\n  /**\n   * Update file metadata\n   * @param id the file id to update metadata\n   * @param meta the new file metadata\n   */\n  // async updateMetadata(\n  //   id: string,\n  //   meta: Metadata\n  // ): Promise<\n  //   | {\n  //       data: Metadata\n  //       error: null\n  //     }\n  //   | {\n  //       data: null\n  //       error: StorageError\n  //     }\n  // > {\n  //   try {\n  //     const data = await post(\n  //       this.fetch,\n  //       `${this.url}/metadata/${id}`,\n  //       { ...meta },\n  //       { headers: this.headers }\n  //     )\n  //     return { data, error: null }\n  //   } catch (error) {\n  //     if (isStorageError(error)) {\n  //       return { data: null, error }\n  //     }\n\n  //     throw error\n  //   }\n  // }\n\n  /**\n   * Lists all the files within a bucket.\n   * @param path The folder path.\n   */\n  async list(\n    path?: string,\n    options?: SearchOptions,\n    parameters?: FetchParameters\n  ): Promise<\n    | {\n        data: FileObject[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const body = { ...DEFAULT_SEARCH_OPTIONS, ...options, prefix: path || '' }\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/list/${this.bucketId}`,\n        body,\n        { headers: this.headers },\n        parameters\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  protected encodeMetadata(metadata: Record<string, any>) {\n    return JSON.stringify(metadata)\n  }\n\n  toBase64(data: string) {\n    if (typeof Buffer !== 'undefined') {\n      return Buffer.from(data).toString('base64')\n    }\n    return btoa(data)\n  }\n\n  private _getFinalPath(path: string) {\n    return `${this.bucketId}/${path}`\n  }\n\n  private _removeEmptyFolders(path: string) {\n    return path.replace(/^\\/|\\/$/g, '').replace(/\\/+/g, '/')\n  }\n\n  private transformOptsToQueryString(transform: TransformOptions) {\n    const params = []\n    if (transform.width) {\n      params.push(`width=${transform.width}`)\n    }\n\n    if (transform.height) {\n      params.push(`height=${transform.height}`)\n    }\n\n    if (transform.resize) {\n      params.push(`resize=${transform.resize}`)\n    }\n\n    if (transform.format) {\n      params.push(`format=${transform.format}`)\n    }\n\n    if (transform.quality) {\n      params.push(`quality=${transform.quality}`)\n    }\n\n    return params.join('&')\n  }\n}\n", "import { version } from './version'\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `storage-js/${version}` }\n", "// generated by genversion\nexport const version = '2.7.1'\n", "import { DEFAULT_HEADERS } from '../lib/constants'\nimport { isStorageError, StorageError } from '../lib/errors'\nimport { Fetch, get, post, put, remove } from '../lib/fetch'\nimport { resolveFetch } from '../lib/helpers'\nimport { Bucket } from '../lib/types'\n\nexport default class StorageBucketApi {\n  protected url: string\n  protected headers: { [key: string]: string }\n  protected fetch: Fetch\n\n  constructor(url: string, headers: { [key: string]: string } = {}, fetch?: Fetch) {\n    this.url = url\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /**\n   * Retrieves the details of all Storage buckets within an existing project.\n   */\n  async listBuckets(): Promise<\n    | {\n        data: Bucket[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await get(this.fetch, `${this.url}/bucket`, { headers: this.headers })\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Retrieves the details of an existing Storage bucket.\n   *\n   * @param id The unique identifier of the bucket you would like to retrieve.\n   */\n  async getBucket(\n    id: string\n  ): Promise<\n    | {\n        data: Bucket\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers })\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates a new Storage bucket\n   *\n   * @param id A unique identifier for the bucket you are creating.\n   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.\n   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n   * The global file size limit takes precedence over this value.\n   * The default value is null, which doesn't set a per bucket file size limit.\n   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n   * The default value is null, which allows files with all mime types to be uploaded.\n   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n   * @returns newly created bucket id\n   */\n  async createBucket(\n    id: string,\n    options: {\n      public: boolean\n      fileSizeLimit?: number | string | null\n      allowedMimeTypes?: string[] | null\n    } = {\n      public: false,\n    }\n  ): Promise<\n    | {\n        data: Pick<Bucket, 'name'>\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/bucket`,\n        {\n          id,\n          name: id,\n          public: options.public,\n          file_size_limit: options.fileSizeLimit,\n          allowed_mime_types: options.allowedMimeTypes,\n        },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Updates a Storage bucket\n   *\n   * @param id A unique identifier for the bucket you are updating.\n   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.\n   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n   * The global file size limit takes precedence over this value.\n   * The default value is null, which doesn't set a per bucket file size limit.\n   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n   * The default value is null, which allows files with all mime types to be uploaded.\n   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n   */\n  async updateBucket(\n    id: string,\n    options: {\n      public: boolean\n      fileSizeLimit?: number | string | null\n      allowedMimeTypes?: string[] | null\n    }\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await put(\n        this.fetch,\n        `${this.url}/bucket/${id}`,\n        {\n          id,\n          name: id,\n          public: options.public,\n          file_size_limit: options.fileSizeLimit,\n          allowed_mime_types: options.allowedMimeTypes,\n        },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Removes all objects inside a single bucket.\n   *\n   * @param id The unique identifier of the bucket you would like to empty.\n   */\n  async emptyBucket(\n    id: string\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/bucket/${id}/empty`,\n        {},\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n   * You must first `empty()` the bucket.\n   *\n   * @param id The unique identifier of the bucket you would like to delete.\n   */\n  async deleteBucket(\n    id: string\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await remove(\n        this.fetch,\n        `${this.url}/bucket/${id}`,\n        {},\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n}\n", "// constants.ts\nimport { RealtimeClientOptions } from '@supabase/realtime-js'\nimport { SupabaseAuthClientOptions } from './types'\nimport { version } from './version'\n\nlet JS_ENV = ''\n// @ts-ignore\nif (typeof Deno !== 'undefined') {\n  JS_ENV = 'deno'\n} else if (typeof document !== 'undefined') {\n  JS_ENV = 'web'\n} else if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n  JS_ENV = 'react-native'\n} else {\n  JS_ENV = 'node'\n}\n\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `supabase-js-${JS_ENV}/${version}` }\n\nexport const DEFAULT_GLOBAL_OPTIONS = {\n  headers: DEFAULT_HEADERS,\n}\n\nexport const DEFAULT_DB_OPTIONS = {\n  schema: 'public',\n}\n\nexport const DEFAULT_AUTH_OPTIONS: SupabaseAuthClientOptions = {\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  flowType: 'implicit',\n}\n\nexport const DEFAULT_REALTIME_OPTIONS: RealtimeClientOptions = {}\n", "export const version = '2.50.0'\n", "// @ts-ignore\nimport nodeFetch, { Headers as NodeFetchHeaders } from '@supabase/node-fetch'\n\ntype Fetch = typeof fetch\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  let _fetch: Fetch\n  if (customFetch) {\n    _fetch = customFetch\n  } else if (typeof fetch === 'undefined') {\n    _fetch = nodeFetch as unknown as Fetch\n  } else {\n    _fetch = fetch\n  }\n  return (...args: Parameters<Fetch>) => _fetch(...args)\n}\n\nexport const resolveHeadersConstructor = () => {\n  if (typeof Headers === 'undefined') {\n    return NodeFetchHeaders\n  }\n\n  return Headers\n}\n\nexport const fetchWithAuth = (\n  supabaseKey: string,\n  getAccessToken: () => Promise<string | null>,\n  customFetch?: Fetch\n): Fetch => {\n  const fetch = resolveFetch(customFetch)\n  const HeadersConstructor = resolveHeadersConstructor()\n\n  return async (input, init) => {\n    const accessToken = (await getAccessToken()) ?? supabaseKey\n    let headers = new HeadersConstructor(init?.headers)\n\n    if (!headers.has('apikey')) {\n      headers.set('apikey', supabaseKey)\n    }\n\n    if (!headers.has('Authorization')) {\n      headers.set('Authorization', `Bearer ${accessToken}`)\n    }\n\n    return fetch(input, { ...init, headers })\n  }\n}\n", "// helpers.ts\nimport { SupabaseClientOptions } from './types'\n\nexport function uuid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = (Math.random() * 16) | 0,\n      v = c == 'x' ? r : (r & 0x3) | 0x8\n    return v.toString(16)\n  })\n}\n\nexport function ensureTrailingSlash(url: string): string {\n  return url.endsWith('/') ? url : url + '/'\n}\n\nexport const isBrowser = () => typeof window !== 'undefined'\n\nexport function applySettingDefaults<\n  Database = any,\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\n    ? 'public'\n    : string & keyof Database\n>(\n  options: SupabaseClientOptions<SchemaName>,\n  defaults: SupabaseClientOptions<any>\n): Required<SupabaseClientOptions<SchemaName>> {\n  const {\n    db: dbOptions,\n    auth: authOptions,\n    realtime: realtimeOptions,\n    global: globalOptions,\n  } = options\n  const {\n    db: DEFAULT_DB_OPTIONS,\n    auth: DEFAULT_AUTH_OPTIONS,\n    realtime: DEFAULT_REALTIME_OPTIONS,\n    global: DEFAULT_GLOBAL_OPTIONS,\n  } = defaults\n\n  const result: Required<SupabaseClientOptions<SchemaName>> = {\n    db: {\n      ...DEFAULT_DB_OPTIONS,\n      ...dbOptions,\n    },\n    auth: {\n      ...DEFAULT_AUTH_OPTIONS,\n      ...authOptions,\n    },\n    realtime: {\n      ...DEFAULT_REALTIME_OPTIONS,\n      ...realtimeOptions,\n    },\n    global: {\n      ...DEFAULT_GLOBAL_OPTIONS,\n      ...globalOptions,\n      headers: {\n        ...(DEFAULT_GLOBAL_OPTIONS?.headers ?? {}),\n        ...(globalOptions?.headers ?? {}),\n      },\n    },\n    accessToken: async () => '',\n  }\n\n  if (options.accessToken) {\n    result.accessToken = options.accessToken\n  } else {\n    // hack around Required<>\n    delete (result as any).accessToken\n  }\n\n  return result\n}\n", "import { AuthClient } from '@supabase/auth-js'\nimport { SupabaseAuthClientOptions } from './types'\n\nexport class SupabaseAuthClient extends AuthClient {\n  constructor(options: SupabaseAuthClientOptions) {\n    super(options)\n  }\n}\n", "import GoTrueAdminApi from './GoTrueAdminApi'\nimport GoTrueClient from './GoTrueClient'\nimport AuthAdminApi from './AuthAdminApi'\nimport AuthClient from './AuthClient'\nexport { GoTrueAdminApi, GoTrueClient, AuthAdminApi, AuthClient }\nexport * from './lib/types'\nexport * from './lib/errors'\nexport {\n  navigatorLock,\n  NavigatorLockAcquireTimeoutError,\n  internals as lockInternals,\n  processLock,\n} from './lib/locks'\n", "import { version } from './version'\n\n/** Current session will be checked for refresh at this interval. */\nexport const AUTO_REFRESH_TICK_DURATION_MS = 30 * 1000\n\n/**\n * A token refresh will be attempted this many ticks before the current session expires. */\nexport const AUTO_REFRESH_TICK_THRESHOLD = 3\n\n/*\n * Earliest time before an access token expires that the session should be refreshed.\n */\nexport const EXPIRY_MARGIN_MS = AUTO_REFRESH_TICK_THRESHOLD * AUTO_REFRESH_TICK_DURATION_MS\n\nexport const GOTRUE_URL = 'http://localhost:9999'\nexport const STORAGE_KEY = 'supabase.auth.token'\nexport const AUDIENCE = ''\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `gotrue-js/${version}` }\nexport const NETWORK_FAILURE = {\n  MAX_RETRIES: 10,\n  RETRY_INTERVAL: 2, // in deciseconds\n}\n\nexport const API_VERSION_HEADER_NAME = 'X-Supabase-Api-Version'\nexport const API_VERSIONS = {\n  '2024-01-01': {\n    timestamp: Date.parse('2024-01-01T00:00:00.0Z'),\n    name: '2024-01-01',\n  },\n}\n\nexport const BASE64URL_REGEX = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i\n\nexport const JWKS_TTL = 600000 // 10 minutes\n", "export const version = '2.70.0'\n", "import { API_VERSION_HEADER_NAME, BASE64URL_REGEX } from './constants'\nimport { AuthInvalidJwtError } from './errors'\nimport { base64UrlToUint8Array, stringFromBase64URL } from './base64url'\nimport { JwtHeader, JwtPayload, SupportedStorage } from './types'\n\nexport function expiresAt(expiresIn: number) {\n  const timeNow = Math.round(Date.now() / 1000)\n  return timeNow + expiresIn\n}\n\nexport function uuid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16) | 0,\n      v = c == 'x' ? r : (r & 0x3) | 0x8\n    return v.toString(16)\n  })\n}\n\nexport const isBrowser = () => typeof window !== 'undefined' && typeof document !== 'undefined'\n\nconst localStorageWriteTests = {\n  tested: false,\n  writable: false,\n}\n\n/**\n * Checks whether localStorage is supported on this browser.\n */\nexport const supportsLocalStorage = () => {\n  if (!isBrowser()) {\n    return false\n  }\n\n  try {\n    if (typeof globalThis.localStorage !== 'object') {\n      return false\n    }\n  } catch (e) {\n    // DOM exception when accessing `localStorage`\n    return false\n  }\n\n  if (localStorageWriteTests.tested) {\n    return localStorageWriteTests.writable\n  }\n\n  const randomKey = `lswt-${Math.random()}${Math.random()}`\n\n  try {\n    globalThis.localStorage.setItem(randomKey, randomKey)\n    globalThis.localStorage.removeItem(randomKey)\n\n    localStorageWriteTests.tested = true\n    localStorageWriteTests.writable = true\n  } catch (e) {\n    // localStorage can't be written to\n    // https://www.chromium.org/for-testers/bug-reporting-guidelines/uncaught-securityerror-failed-to-read-the-localstorage-property-from-window-access-is-denied-for-this-document\n\n    localStorageWriteTests.tested = true\n    localStorageWriteTests.writable = false\n  }\n\n  return localStorageWriteTests.writable\n}\n\n/**\n * Extracts parameters encoded in the URL both in the query and fragment.\n */\nexport function parseParametersFromURL(href: string) {\n  const result: { [parameter: string]: string } = {}\n\n  const url = new URL(href)\n\n  if (url.hash && url.hash[0] === '#') {\n    try {\n      const hashSearchParams = new URLSearchParams(url.hash.substring(1))\n      hashSearchParams.forEach((value, key) => {\n        result[key] = value\n      })\n    } catch (e: any) {\n      // hash is not a query string\n    }\n  }\n\n  // search parameters take precedence over hash parameters\n  url.searchParams.forEach((value, key) => {\n    result[key] = value\n  })\n\n  return result\n}\n\ntype Fetch = typeof fetch\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  let _fetch: Fetch\n  if (customFetch) {\n    _fetch = customFetch\n  } else if (typeof fetch === 'undefined') {\n    _fetch = (...args) =>\n      import('@supabase/node-fetch' as any).then(({ default: fetch }) => fetch(...args))\n  } else {\n    _fetch = fetch\n  }\n  return (...args) => _fetch(...args)\n}\n\nexport const looksLikeFetchResponse = (maybeResponse: unknown): maybeResponse is Response => {\n  return (\n    typeof maybeResponse === 'object' &&\n    maybeResponse !== null &&\n    'status' in maybeResponse &&\n    'ok' in maybeResponse &&\n    'json' in maybeResponse &&\n    typeof (maybeResponse as any).json === 'function'\n  )\n}\n\n// Storage helpers\nexport const setItemAsync = async (\n  storage: SupportedStorage,\n  key: string,\n  data: any\n): Promise<void> => {\n  await storage.setItem(key, JSON.stringify(data))\n}\n\nexport const getItemAsync = async (storage: SupportedStorage, key: string): Promise<unknown> => {\n  const value = await storage.getItem(key)\n\n  if (!value) {\n    return null\n  }\n\n  try {\n    return JSON.parse(value)\n  } catch {\n    return value\n  }\n}\n\nexport const removeItemAsync = async (storage: SupportedStorage, key: string): Promise<void> => {\n  await storage.removeItem(key)\n}\n\n/**\n * A deferred represents some asynchronous work that is not yet finished, which\n * may or may not culminate in a value.\n * Taken from: https://github.com/mike-north/types/blob/master/src/async.ts\n */\nexport class Deferred<T = any> {\n  public static promiseConstructor: PromiseConstructor = Promise\n\n  public readonly promise!: PromiseLike<T>\n\n  public readonly resolve!: (value?: T | PromiseLike<T>) => void\n\n  public readonly reject!: (reason?: any) => any\n\n  public constructor() {\n    // eslint-disable-next-line @typescript-eslint/no-extra-semi\n    ;(this as any).promise = new Deferred.promiseConstructor((res, rej) => {\n      // eslint-disable-next-line @typescript-eslint/no-extra-semi\n      ;(this as any).resolve = res\n      // eslint-disable-next-line @typescript-eslint/no-extra-semi\n      ;(this as any).reject = rej\n    })\n  }\n}\n\nexport function decodeJWT(token: string): {\n  header: JwtHeader\n  payload: JwtPayload\n  signature: Uint8Array\n  raw: {\n    header: string\n    payload: string\n  }\n} {\n  const parts = token.split('.')\n\n  if (parts.length !== 3) {\n    throw new AuthInvalidJwtError('Invalid JWT structure')\n  }\n\n  // Regex checks for base64url format\n  for (let i = 0; i < parts.length; i++) {\n    if (!BASE64URL_REGEX.test(parts[i] as string)) {\n      throw new AuthInvalidJwtError('JWT not in base64url format')\n    }\n  }\n  const data = {\n    // using base64url lib\n    header: JSON.parse(stringFromBase64URL(parts[0])),\n    payload: JSON.parse(stringFromBase64URL(parts[1])),\n    signature: base64UrlToUint8Array(parts[2]),\n    raw: {\n      header: parts[0],\n      payload: parts[1],\n    },\n  }\n  return data\n}\n\n/**\n * Creates a promise that resolves to null after some time.\n */\nexport async function sleep(time: number): Promise<null> {\n  return await new Promise((accept) => {\n    setTimeout(() => accept(null), time)\n  })\n}\n\n/**\n * Converts the provided async function into a retryable function. Each result\n * or thrown error is sent to the isRetryable function which should return true\n * if the function should run again.\n */\nexport function retryable<T>(\n  fn: (attempt: number) => Promise<T>,\n  isRetryable: (attempt: number, error: any | null, result?: T) => boolean\n): Promise<T> {\n  const promise = new Promise<T>((accept, reject) => {\n    // eslint-disable-next-line @typescript-eslint/no-extra-semi\n    ;(async () => {\n      for (let attempt = 0; attempt < Infinity; attempt++) {\n        try {\n          const result = await fn(attempt)\n\n          if (!isRetryable(attempt, null, result)) {\n            accept(result)\n            return\n          }\n        } catch (e: any) {\n          if (!isRetryable(attempt, e)) {\n            reject(e)\n            return\n          }\n        }\n      }\n    })()\n  })\n\n  return promise\n}\n\nfunction dec2hex(dec: number) {\n  return ('0' + dec.toString(16)).substr(-2)\n}\n\n// Functions below taken from: https://stackoverflow.com/questions/63309409/creating-a-code-verifier-and-challenge-for-pkce-auth-on-spotify-api-in-reactjs\nexport function generatePKCEVerifier() {\n  const verifierLength = 56\n  const array = new Uint32Array(verifierLength)\n  if (typeof crypto === 'undefined') {\n    const charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~'\n    const charSetLen = charSet.length\n    let verifier = ''\n    for (let i = 0; i < verifierLength; i++) {\n      verifier += charSet.charAt(Math.floor(Math.random() * charSetLen))\n    }\n    return verifier\n  }\n  crypto.getRandomValues(array)\n  return Array.from(array, dec2hex).join('')\n}\n\nasync function sha256(randomString: string) {\n  const encoder = new TextEncoder()\n  const encodedData = encoder.encode(randomString)\n  const hash = await crypto.subtle.digest('SHA-256', encodedData)\n  const bytes = new Uint8Array(hash)\n\n  return Array.from(bytes)\n    .map((c) => String.fromCharCode(c))\n    .join('')\n}\n\nexport async function generatePKCEChallenge(verifier: string) {\n  const hasCryptoSupport =\n    typeof crypto !== 'undefined' &&\n    typeof crypto.subtle !== 'undefined' &&\n    typeof TextEncoder !== 'undefined'\n\n  if (!hasCryptoSupport) {\n    console.warn(\n      'WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.'\n    )\n    return verifier\n  }\n  const hashed = await sha256(verifier)\n  return btoa(hashed).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '')\n}\n\nexport async function getCodeChallengeAndMethod(\n  storage: SupportedStorage,\n  storageKey: string,\n  isPasswordRecovery = false\n) {\n  const codeVerifier = generatePKCEVerifier()\n  let storedCodeVerifier = codeVerifier\n  if (isPasswordRecovery) {\n    storedCodeVerifier += '/PASSWORD_RECOVERY'\n  }\n  await setItemAsync(storage, `${storageKey}-code-verifier`, storedCodeVerifier)\n  const codeChallenge = await generatePKCEChallenge(codeVerifier)\n  const codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\n  return [codeChallenge, codeChallengeMethod]\n}\n\n/** Parses the API version which is 2YYY-MM-DD. */\nconst API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i\n\nexport function parseResponseAPIVersion(response: Response) {\n  const apiVersion = response.headers.get(API_VERSION_HEADER_NAME)\n\n  if (!apiVersion) {\n    return null\n  }\n\n  if (!apiVersion.match(API_VERSION_REGEX)) {\n    return null\n  }\n\n  try {\n    const date = new Date(`${apiVersion}T00:00:00.0Z`)\n    return date\n  } catch (e: any) {\n    return null\n  }\n}\n\nexport function validateExp(exp: number) {\n  if (!exp) {\n    throw new Error('Missing exp claim')\n  }\n  const timeNow = Math.floor(Date.now() / 1000)\n  if (exp <= timeNow) {\n    throw new Error('JWT has expired')\n  }\n}\n\nexport function getAlgorithm(alg: 'RS256' | 'ES256'): RsaHashedImportParams | EcKeyImportParams {\n  switch (alg) {\n    case 'RS256':\n      return {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: { name: 'SHA-256' },\n      }\n    case 'ES256':\n      return {\n        name: 'ECDSA',\n        namedCurve: 'P-256',\n        hash: { name: 'SHA-256' },\n      }\n    default:\n      throw new Error('Invalid alg claim')\n  }\n}\n\nconst UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/\n\nexport function validateUUID(str: string) {\n  if (!UUID_REGEX.test(str)) {\n    throw new Error('@supabase/auth-js: Expected parameter to be UUID but is not')\n  }\n}\n", "import { WeakPasswordReasons } from './types'\nimport { ErrorCode } from './error-codes'\n\nexport class AuthError extends Error {\n  /**\n   * Error code associated with the error. Most errors coming from\n   * HTTP responses will have a code, though some errors that occur\n   * before a response is received will not have one present. In that\n   * case {@link #status} will also be undefined.\n   */\n  code: ErrorCode | (string & {}) | undefined\n\n  /** HTTP status code that caused the error. */\n  status: number | undefined\n\n  protected __isAuthError = true\n\n  constructor(message: string, status?: number, code?: string) {\n    super(message)\n    this.name = 'AuthError'\n    this.status = status\n    this.code = code\n  }\n}\n\nexport function isAuthError(error: unknown): error is AuthError {\n  return typeof error === 'object' && error !== null && '__isAuthError' in error\n}\n\nexport class AuthApiError extends AuthError {\n  status: number\n\n  constructor(message: string, status: number, code: string | undefined) {\n    super(message, status, code)\n    this.name = 'AuthApiError'\n    this.status = status\n    this.code = code\n  }\n}\n\nexport function isAuthApiError(error: unknown): error is AuthApiError {\n  return isAuthError(error) && error.name === 'AuthApiError'\n}\n\nexport class AuthUnknownError extends AuthError {\n  originalError: unknown\n\n  constructor(message: string, originalError: unknown) {\n    super(message)\n    this.name = 'AuthUnknownError'\n    this.originalError = originalError\n  }\n}\n\nexport class CustomAuthError extends AuthError {\n  name: string\n  status: number\n\n  constructor(message: string, name: string, status: number, code: string | undefined) {\n    super(message, status, code)\n    this.name = name\n    this.status = status\n  }\n}\n\nexport class AuthSessionMissingError extends CustomAuthError {\n  constructor() {\n    super('Auth session missing!', 'AuthSessionMissingError', 400, undefined)\n  }\n}\n\nexport function isAuthSessionMissingError(error: any): error is AuthSessionMissingError {\n  return isAuthError(error) && error.name === 'AuthSessionMissingError'\n}\n\nexport class AuthInvalidTokenResponseError extends CustomAuthError {\n  constructor() {\n    super('Auth session or user missing', 'AuthInvalidTokenResponseError', 500, undefined)\n  }\n}\n\nexport class AuthInvalidCredentialsError extends CustomAuthError {\n  constructor(message: string) {\n    super(message, 'AuthInvalidCredentialsError', 400, undefined)\n  }\n}\n\nexport class AuthImplicitGrantRedirectError extends CustomAuthError {\n  details: { error: string; code: string } | null = null\n  constructor(message: string, details: { error: string; code: string } | null = null) {\n    super(message, 'AuthImplicitGrantRedirectError', 500, undefined)\n    this.details = details\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status,\n      details: this.details,\n    }\n  }\n}\n\nexport function isAuthImplicitGrantRedirectError(\n  error: any\n): error is AuthImplicitGrantRedirectError {\n  return isAuthError(error) && error.name === 'AuthImplicitGrantRedirectError'\n}\n\nexport class AuthPKCEGrantCodeExchangeError extends CustomAuthError {\n  details: { error: string; code: string } | null = null\n\n  constructor(message: string, details: { error: string; code: string } | null = null) {\n    super(message, 'AuthPKCEGrantCodeExchangeError', 500, undefined)\n    this.details = details\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status,\n      details: this.details,\n    }\n  }\n}\n\nexport class AuthRetryableFetchError extends CustomAuthError {\n  constructor(message: string, status: number) {\n    super(message, 'AuthRetryableFetchError', status, undefined)\n  }\n}\n\nexport function isAuthRetryableFetchError(error: unknown): error is AuthRetryableFetchError {\n  return isAuthError(error) && error.name === 'AuthRetryableFetchError'\n}\n\n/**\n * This error is thrown on certain methods when the password used is deemed\n * weak. Inspect the reasons to identify what password strength rules are\n * inadequate.\n */\nexport class AuthWeakPasswordError extends CustomAuthError {\n  /**\n   * Reasons why the password is deemed weak.\n   */\n  reasons: WeakPasswordReasons[]\n\n  constructor(message: string, status: number, reasons: string[]) {\n    super(message, 'AuthWeakPasswordError', status, 'weak_password')\n\n    this.reasons = reasons\n  }\n}\n\nexport function isAuthWeakPasswordError(error: unknown): error is AuthWeakPasswordError {\n  return isAuthError(error) && error.name === 'AuthWeakPasswordError'\n}\n\nexport class AuthInvalidJwtError extends CustomAuthError {\n  constructor(message: string) {\n    super(message, 'AuthInvalidJwtError', 400, 'invalid_jwt')\n  }\n}\n", "/**\n * Avoid modifying this file. It's part of\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\n * that repo!\n */\n\n/**\n * An array of characters that encode 6 bits into a Base64-URL alphabet\n * character.\n */\nconst TO_BASE64URL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split('')\n\n/**\n * An array of characters that can appear in a Base64-URL encoded string but\n * should be ignored.\n */\nconst IGNORE_BASE64URL = ' \\t\\n\\r='.split('')\n\n/**\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\n * used to skip the character, or if -1 used to error out.\n */\nconst FROM_BASE64URL = (() => {\n  const charMap: number[] = new Array(128)\n\n  for (let i = 0; i < charMap.length; i += 1) {\n    charMap[i] = -1\n  }\n\n  for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {\n    charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2\n  }\n\n  for (let i = 0; i < TO_BASE64URL.length; i += 1) {\n    charMap[TO_BASE64URL[i].charCodeAt(0)] = i\n  }\n\n  return charMap\n})()\n\n/**\n * Converts a byte to a Base64-URL string.\n *\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next Base64 character when ready.\n */\nexport function byteToBase64URL(\n  byte: number | null,\n  state: { queue: number; queuedBits: number },\n  emit: (char: string) => void\n) {\n  if (byte !== null) {\n    state.queue = (state.queue << 8) | byte\n    state.queuedBits += 8\n\n    while (state.queuedBits >= 6) {\n      const pos = (state.queue >> (state.queuedBits - 6)) & 63\n      emit(TO_BASE64URL[pos])\n      state.queuedBits -= 6\n    }\n  } else if (state.queuedBits > 0) {\n    state.queue = state.queue << (6 - state.queuedBits)\n    state.queuedBits = 6\n\n    while (state.queuedBits >= 6) {\n      const pos = (state.queue >> (state.queuedBits - 6)) & 63\n      emit(TO_BASE64URL[pos])\n      state.queuedBits -= 6\n    }\n  }\n}\n\n/**\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\n *\n * @param charCode The char code of the JavaScript string.\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next byte.\n */\nexport function byteFromBase64URL(\n  charCode: number,\n  state: { queue: number; queuedBits: number },\n  emit: (byte: number) => void\n) {\n  const bits = FROM_BASE64URL[charCode]\n\n  if (bits > -1) {\n    // valid Base64-URL character\n    state.queue = (state.queue << 6) | bits\n    state.queuedBits += 6\n\n    while (state.queuedBits >= 8) {\n      emit((state.queue >> (state.queuedBits - 8)) & 0xff)\n      state.queuedBits -= 8\n    }\n  } else if (bits === -2) {\n    // ignore spaces, tabs, newlines, =\n    return\n  } else {\n    throw new Error(`Invalid Base64-URL character \"${String.fromCharCode(charCode)}\"`)\n  }\n}\n\n/**\n * Converts a JavaScript string (which may include any valid character) into a\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\n * then encoded as Base64-URL.\n *\n * @param str The string to convert.\n */\nexport function stringToBase64URL(str: string) {\n  const base64: string[] = []\n\n  const emitter = (char: string) => {\n    base64.push(char)\n  }\n\n  const state = { queue: 0, queuedBits: 0 }\n\n  stringToUTF8(str, (byte: number) => {\n    byteToBase64URL(byte, state, emitter)\n  })\n\n  byteToBase64URL(null, state, emitter)\n\n  return base64.join('')\n}\n\n/**\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\n * that the underlying string has been encoded as UTF-8.\n *\n * @param str The Base64-URL encoded string.\n */\nexport function stringFromBase64URL(str: string) {\n  const conv: string[] = []\n\n  const utf8Emit = (codepoint: number) => {\n    conv.push(String.fromCodePoint(codepoint))\n  }\n\n  const utf8State = {\n    utf8seq: 0,\n    codepoint: 0,\n  }\n\n  const b64State = { queue: 0, queuedBits: 0 }\n\n  const byteEmit = (byte: number) => {\n    stringFromUTF8(byte, utf8State, utf8Emit)\n  }\n\n  for (let i = 0; i < str.length; i += 1) {\n    byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit)\n  }\n\n  return conv.join('')\n}\n\n/**\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\n *\n * @param codepoint The Unicode codepoint.\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\n */\nexport function codepointToUTF8(codepoint: number, emit: (byte: number) => void) {\n  if (codepoint <= 0x7f) {\n    emit(codepoint)\n    return\n  } else if (codepoint <= 0x7ff) {\n    emit(0xc0 | (codepoint >> 6))\n    emit(0x80 | (codepoint & 0x3f))\n    return\n  } else if (codepoint <= 0xffff) {\n    emit(0xe0 | (codepoint >> 12))\n    emit(0x80 | ((codepoint >> 6) & 0x3f))\n    emit(0x80 | (codepoint & 0x3f))\n    return\n  } else if (codepoint <= 0x10ffff) {\n    emit(0xf0 | (codepoint >> 18))\n    emit(0x80 | ((codepoint >> 12) & 0x3f))\n    emit(0x80 | ((codepoint >> 6) & 0x3f))\n    emit(0x80 | (codepoint & 0x3f))\n    return\n  }\n\n  throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`)\n}\n\n/**\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\n *\n * @param str  The string to convert to UTF-8.\n * @param emit Function which will be called for each UTF-8 byte of the string.\n */\nexport function stringToUTF8(str: string, emit: (byte: number) => void) {\n  for (let i = 0; i < str.length; i += 1) {\n    let codepoint = str.charCodeAt(i)\n\n    if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\n      // most UTF-16 codepoints are Unicode codepoints, except values in this\n      // range where the next UTF-16 codepoint needs to be combined with the\n      // current one to get the Unicode codepoint\n      const highSurrogate = ((codepoint - 0xd800) * 0x400) & 0xffff\n      const lowSurrogate = (str.charCodeAt(i + 1) - 0xdc00) & 0xffff\n      codepoint = (lowSurrogate | highSurrogate) + 0x10000\n      i += 1\n    }\n\n    codepointToUTF8(codepoint, emit)\n  }\n}\n\n/**\n * Converts a UTF-8 byte to a Unicode codepoint.\n *\n * @param byte  The UTF-8 byte next in the sequence.\n * @param state The shared state between consecutive UTF-8 bytes in the\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\n * @param emit  Function which will be called for each codepoint.\n */\nexport function stringFromUTF8(\n  byte: number,\n  state: { utf8seq: number; codepoint: number },\n  emit: (codepoint: number) => void\n) {\n  if (state.utf8seq === 0) {\n    if (byte <= 0x7f) {\n      emit(byte)\n      return\n    }\n\n    // count the number of 1 leading bits until you reach 0\n    for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {\n      if (((byte >> (7 - leadingBit)) & 1) === 0) {\n        state.utf8seq = leadingBit\n        break\n      }\n    }\n\n    if (state.utf8seq === 2) {\n      state.codepoint = byte & 31\n    } else if (state.utf8seq === 3) {\n      state.codepoint = byte & 15\n    } else if (state.utf8seq === 4) {\n      state.codepoint = byte & 7\n    } else {\n      throw new Error('Invalid UTF-8 sequence')\n    }\n\n    state.utf8seq -= 1\n  } else if (state.utf8seq > 0) {\n    if (byte <= 0x7f) {\n      throw new Error('Invalid UTF-8 sequence')\n    }\n\n    state.codepoint = (state.codepoint << 6) | (byte & 63)\n    state.utf8seq -= 1\n\n    if (state.utf8seq === 0) {\n      emit(state.codepoint)\n    }\n  }\n}\n\n/**\n * Helper functions to convert different types of strings to Uint8Array\n */\n\nexport function base64UrlToUint8Array(str: string): Uint8Array {\n  const result: number[] = []\n  const state = { queue: 0, queuedBits: 0 }\n\n  const onByte = (byte: number) => {\n    result.push(byte)\n  }\n\n  for (let i = 0; i < str.length; i += 1) {\n    byteFromBase64URL(str.charCodeAt(i), state, onByte)\n  }\n\n  return new Uint8Array(result)\n}\n\nexport function stringToUint8Array(str: string): Uint8Array {\n  const result: number[] = []\n  stringToUTF8(str, (byte: number) => result.push(byte))\n  return new Uint8Array(result)\n}\n\nexport function bytesToBase64URL(bytes: Uint8Array) {\n  const result: string[] = []\n  const state = { queue: 0, queuedBits: 0 }\n\n  const onChar = (char: string) => {\n    result.push(char)\n  }\n\n  bytes.forEach((byte) => byteToBase64URL(byte, state, onChar))\n\n  // always call with `null` after processing all bytes\n  byteToBase64URL(null, state, onChar)\n\n  return result.join('')\n}\n", "import { API_VERSIONS, API_VERSION_HEADER_NAME } from './constants'\nimport { expiresAt, looksLikeFetchResponse, parseResponseAPIVersion } from './helpers'\nimport {\n  AuthResponse,\n  AuthResponsePassword,\n  SSOResponse,\n  GenerateLinkProperties,\n  GenerateLinkResponse,\n  User,\n  UserResponse,\n} from './types'\nimport {\n  AuthApiError,\n  AuthRetryableFetchError,\n  AuthWeakPasswordError,\n  AuthUnknownError,\n  AuthSessionMissingError,\n} from './errors'\n\nexport type Fetch = typeof fetch\n\nexport interface FetchOptions {\n  headers?: {\n    [key: string]: string\n  }\n  noResolveJson?: boolean\n}\n\nexport interface FetchParameters {\n  signal?: AbortSignal\n}\n\nexport type RequestMethodType = 'GET' | 'POST' | 'PUT' | 'DELETE'\n\nconst _getErrorMessage = (err: any): string =>\n  err.msg || err.message || err.error_description || err.error || JSON.stringify(err)\n\nconst NETWORK_ERROR_CODES = [502, 503, 504]\n\nexport async function handleError(error: unknown) {\n  if (!looksLikeFetchResponse(error)) {\n    throw new AuthRetryableFetchError(_getErrorMessage(error), 0)\n  }\n\n  if (NETWORK_ERROR_CODES.includes(error.status)) {\n    // status in 500...599 range - server had an error, request might be retryed.\n    throw new AuthRetryableFetchError(_getErrorMessage(error), error.status)\n  }\n\n  let data: any\n  try {\n    data = await error.json()\n  } catch (e: any) {\n    throw new AuthUnknownError(_getErrorMessage(e), e)\n  }\n\n  let errorCode: string | undefined = undefined\n\n  const responseAPIVersion = parseResponseAPIVersion(error)\n  if (\n    responseAPIVersion &&\n    responseAPIVersion.getTime() >= API_VERSIONS['2024-01-01'].timestamp &&\n    typeof data === 'object' &&\n    data &&\n    typeof data.code === 'string'\n  ) {\n    errorCode = data.code\n  } else if (typeof data === 'object' && data && typeof data.error_code === 'string') {\n    errorCode = data.error_code\n  }\n\n  if (!errorCode) {\n    // Legacy support for weak password errors, when there were no error codes\n    if (\n      typeof data === 'object' &&\n      data &&\n      typeof data.weak_password === 'object' &&\n      data.weak_password &&\n      Array.isArray(data.weak_password.reasons) &&\n      data.weak_password.reasons.length &&\n      data.weak_password.reasons.reduce((a: boolean, i: any) => a && typeof i === 'string', true)\n    ) {\n      throw new AuthWeakPasswordError(\n        _getErrorMessage(data),\n        error.status,\n        data.weak_password.reasons\n      )\n    }\n  } else if (errorCode === 'weak_password') {\n    throw new AuthWeakPasswordError(\n      _getErrorMessage(data),\n      error.status,\n      data.weak_password?.reasons || []\n    )\n  } else if (errorCode === 'session_not_found') {\n    // The `session_id` inside the JWT does not correspond to a row in the\n    // `sessions` table. This usually means the user has signed out, has been\n    // deleted, or their session has somehow been terminated.\n    throw new AuthSessionMissingError()\n  }\n\n  throw new AuthApiError(_getErrorMessage(data), error.status || 500, errorCode)\n}\n\nconst _getRequestParams = (\n  method: RequestMethodType,\n  options?: FetchOptions,\n  parameters?: FetchParameters,\n  body?: object\n) => {\n  const params: { [k: string]: any } = { method, headers: options?.headers || {} }\n\n  if (method === 'GET') {\n    return params\n  }\n\n  params.headers = { 'Content-Type': 'application/json;charset=UTF-8', ...options?.headers }\n  params.body = JSON.stringify(body)\n  return { ...params, ...parameters }\n}\n\ninterface GotrueRequestOptions extends FetchOptions {\n  jwt?: string\n  redirectTo?: string\n  body?: object\n  query?: { [key: string]: string }\n  /**\n   * Function that transforms api response from gotrue into a desirable / standardised format\n   */\n  xform?: (data: any) => any\n}\n\nexport async function _request(\n  fetcher: Fetch,\n  method: RequestMethodType,\n  url: string,\n  options?: GotrueRequestOptions\n) {\n  const headers = {\n    ...options?.headers,\n  }\n\n  if (!headers[API_VERSION_HEADER_NAME]) {\n    headers[API_VERSION_HEADER_NAME] = API_VERSIONS['2024-01-01'].name\n  }\n\n  if (options?.jwt) {\n    headers['Authorization'] = `Bearer ${options.jwt}`\n  }\n\n  const qs = options?.query ?? {}\n  if (options?.redirectTo) {\n    qs['redirect_to'] = options.redirectTo\n  }\n\n  const queryString = Object.keys(qs).length ? '?' + new URLSearchParams(qs).toString() : ''\n  const data = await _handleRequest(\n    fetcher,\n    method,\n    url + queryString,\n    {\n      headers,\n      noResolveJson: options?.noResolveJson,\n    },\n    {},\n    options?.body\n  )\n  return options?.xform ? options?.xform(data) : { data: { ...data }, error: null }\n}\n\nasync function _handleRequest(\n  fetcher: Fetch,\n  method: RequestMethodType,\n  url: string,\n  options?: FetchOptions,\n  parameters?: FetchParameters,\n  body?: object\n): Promise<any> {\n  const requestParams = _getRequestParams(method, options, parameters, body)\n\n  let result: any\n\n  try {\n    result = await fetcher(url, {\n      ...requestParams,\n    })\n  } catch (e) {\n    console.error(e)\n\n    // fetch failed, likely due to a network or CORS error\n    throw new AuthRetryableFetchError(_getErrorMessage(e), 0)\n  }\n\n  if (!result.ok) {\n    await handleError(result)\n  }\n\n  if (options?.noResolveJson) {\n    return result\n  }\n\n  try {\n    return await result.json()\n  } catch (e: any) {\n    await handleError(e)\n  }\n}\n\nexport function _sessionResponse(data: any): AuthResponse {\n  let session = null\n  if (hasSession(data)) {\n    session = { ...data }\n\n    if (!data.expires_at) {\n      session.expires_at = expiresAt(data.expires_in)\n    }\n  }\n\n  const user: User = data.user ?? (data as User)\n  return { data: { session, user }, error: null }\n}\n\nexport function _sessionResponsePassword(data: any): AuthResponsePassword {\n  const response = _sessionResponse(data) as AuthResponsePassword\n\n  if (\n    !response.error &&\n    data.weak_password &&\n    typeof data.weak_password === 'object' &&\n    Array.isArray(data.weak_password.reasons) &&\n    data.weak_password.reasons.length &&\n    data.weak_password.message &&\n    typeof data.weak_password.message === 'string' &&\n    data.weak_password.reasons.reduce((a: boolean, i: any) => a && typeof i === 'string', true)\n  ) {\n    response.data.weak_password = data.weak_password\n  }\n\n  return response\n}\n\nexport function _userResponse(data: any): UserResponse {\n  const user: User = data.user ?? (data as User)\n  return { data: { user }, error: null }\n}\n\nexport function _ssoResponse(data: any): SSOResponse {\n  return { data, error: null }\n}\n\nexport function _generateLinkResponse(data: any): GenerateLinkResponse {\n  const { action_link, email_otp, hashed_token, redirect_to, verification_type, ...rest } = data\n\n  const properties: GenerateLinkProperties = {\n    action_link,\n    email_otp,\n    hashed_token,\n    redirect_to,\n    verification_type,\n  }\n\n  const user: User = { ...rest }\n  return {\n    data: {\n      properties,\n      user,\n    },\n    error: null,\n  }\n}\n\nexport function _noResolveJsonResponse(data: any): Response {\n  return data\n}\n\n/**\n * hasSession checks if the response object contains a valid session\n * @param data A response object\n * @returns true if a session is in the response\n */\nfunction hasSession(data: any): boolean {\n  return data.access_token && data.refresh_token && data.expires_in\n}\n", "import { AuthError } from './errors'\nimport { Fetch } from './fetch'\nimport type { SolanaSignInInput, SolanaSignInOutput } from '@solana/wallet-standard-features'\n\n/** One of the providers supported by GoTrue. */\nexport type Provider =\n  | 'apple'\n  | 'azure'\n  | 'bitbucket'\n  | 'discord'\n  | 'facebook'\n  | 'figma'\n  | 'github'\n  | 'gitlab'\n  | 'google'\n  | 'kakao'\n  | 'keycloak'\n  | 'linkedin'\n  | 'linkedin_oidc'\n  | 'notion'\n  | 'slack'\n  | 'slack_oidc'\n  | 'spotify'\n  | 'twitch'\n  | 'twitter'\n  | 'workos'\n  | 'zoom'\n  | 'fly'\n\nexport type AuthChangeEventMFA = 'MFA_CHALLENGE_VERIFIED'\n\nexport type AuthChangeEvent =\n  | 'INITIAL_SESSION'\n  | 'PASSWORD_RECOVERY'\n  | 'SIGNED_IN'\n  | 'SIGNED_OUT'\n  | 'TOKEN_REFRESHED'\n  | 'USER_UPDATED'\n  | AuthChangeEventMFA\n\n/**\n * Provide your own global lock implementation instead of the default\n * implementation. The function should acquire a lock for the duration of the\n * `fn` async function, such that no other client instances will be able to\n * hold it at the same time.\n *\n * @experimental\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout should occur. If positive it\n *                       should throw an Error with an `isAcquireTimeout`\n *                       property set to true if the operation fails to be\n *                       acquired after this much time (ms).\n * @param fn The operation to execute when the lock is acquired.\n */\nexport type LockFunc = <R>(name: string, acquireTimeout: number, fn: () => Promise<R>) => Promise<R>\n\nexport type GoTrueClientOptions = {\n  /* The URL of the GoTrue server. */\n  url?: string\n  /* Any additional headers to send to the GoTrue server. */\n  headers?: { [key: string]: string }\n  /* Optional key name used for storing tokens in local storage. */\n  storageKey?: string\n  /* Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user. */\n  detectSessionInUrl?: boolean\n  /* Set to \"true\" if you want to automatically refresh the token before expiring. */\n  autoRefreshToken?: boolean\n  /* Set to \"true\" if you want to automatically save the user session into local storage. If set to false, session will just be saved in memory. */\n  persistSession?: boolean\n  /* Provide your own local storage implementation to use instead of the browser's local storage. */\n  storage?: SupportedStorage\n  /* A custom fetch implementation. */\n  fetch?: Fetch\n  /* If set to 'pkce' PKCE flow. Defaults to the 'implicit' flow otherwise */\n  flowType?: AuthFlowType\n  /* If debug messages are emitted. Can be used to inspect the behavior of the library. If set to a function, the provided function will be used instead of `console.log()` to perform the logging. */\n  debug?: boolean | ((message: string, ...args: any[]) => void)\n  /**\n   * Provide your own locking mechanism based on the environment. By default no locking is done at this time.\n   *\n   * @experimental\n   */\n  lock?: LockFunc\n  /**\n   * Set to \"true\" if there is a custom authorization header set globally.\n   * @experimental\n   */\n  hasCustomAuthorizationHeader?: boolean\n}\n\nexport type WeakPasswordReasons = 'length' | 'characters' | 'pwned' | (string & {})\nexport type WeakPassword = {\n  reasons: WeakPasswordReasons[]\n  message: string\n}\n\nexport type AuthResponse =\n  | {\n      data: {\n        user: User | null\n        session: Session | null\n      }\n      error: null\n    }\n  | {\n      data: {\n        user: null\n        session: null\n      }\n      error: AuthError\n    }\n\nexport type AuthResponsePassword =\n  | {\n      data: {\n        user: User | null\n        session: Session | null\n        weak_password?: WeakPassword | null\n      }\n      error: null\n    }\n  | {\n      data: {\n        user: null\n        session: null\n      }\n      error: AuthError\n    }\n\n/**\n * AuthOtpResponse is returned when OTP is used.\n *\n * {@see AuthResponse}\n */\nexport type AuthOtpResponse =\n  | {\n      data: { user: null; session: null; messageId?: string | null }\n      error: null\n    }\n  | {\n      data: { user: null; session: null; messageId?: string | null }\n      error: AuthError\n    }\n\nexport type AuthTokenResponse =\n  | {\n      data: {\n        user: User\n        session: Session\n      }\n      error: null\n    }\n  | {\n      data: {\n        user: null\n        session: null\n      }\n      error: AuthError\n    }\n\nexport type AuthTokenResponsePassword =\n  | {\n      data: {\n        user: User\n        session: Session\n        weakPassword?: WeakPassword\n      }\n      error: null\n    }\n  | {\n      data: {\n        user: null\n        session: null\n        weakPassword?: null\n      }\n      error: AuthError\n    }\n\nexport type OAuthResponse =\n  | {\n      data: {\n        provider: Provider\n        url: string\n      }\n      error: null\n    }\n  | {\n      data: {\n        provider: Provider\n        url: null\n      }\n      error: AuthError\n    }\n\nexport type SSOResponse =\n  | {\n      data: {\n        /**\n         * URL to open in a browser which will complete the sign-in flow by\n         * taking the user to the identity provider's authentication flow.\n         *\n         * On browsers you can set the URL to `window.location.href` to take\n         * the user to the authentication flow.\n         */\n        url: string\n      }\n      error: null\n    }\n  | {\n      data: null\n      error: AuthError\n    }\n\nexport type UserResponse =\n  | {\n      data: {\n        user: User\n      }\n      error: null\n    }\n  | {\n      data: {\n        user: null\n      }\n      error: AuthError\n    }\n\nexport interface Session {\n  /**\n   * The oauth provider token. If present, this can be used to make external API requests to the oauth provider used.\n   */\n  provider_token?: string | null\n  /**\n   * The oauth provider refresh token. If present, this can be used to refresh the provider_token via the oauth provider's API.\n   * Not all oauth providers return a provider refresh token. If the provider_refresh_token is missing, please refer to the oauth provider's documentation for information on how to obtain the provider refresh token.\n   */\n  provider_refresh_token?: string | null\n  /**\n   * The access token jwt. It is recommended to set the JWT_EXPIRY to a shorter expiry value.\n   */\n  access_token: string\n  /**\n   * A one-time used refresh token that never expires.\n   */\n  refresh_token: string\n  /**\n   * The number of seconds until the token expires (since it was issued). Returned when a login is confirmed.\n   */\n  expires_in: number\n  /**\n   * A timestamp of when the token will expire. Returned when a login is confirmed.\n   */\n  expires_at?: number\n  token_type: string\n  user: User\n}\n\n/**\n * An authentication methord reference (AMR) entry.\n *\n * An entry designates what method was used by the user to verify their\n * identity and at what time.\n *\n * @see {@link GoTrueMFAApi#getAuthenticatorAssuranceLevel}.\n */\nexport interface AMREntry {\n  /** Authentication method name. */\n  method: 'password' | 'otp' | 'oauth' | 'mfa/totp' | (string & {})\n\n  /**\n   * Timestamp when the method was successfully used. Represents number of\n   * seconds since 1st January 1970 (UNIX epoch) in UTC.\n   */\n  timestamp: number\n}\n\nexport interface UserIdentity {\n  id: string\n  user_id: string\n  identity_data?: {\n    [key: string]: any\n  }\n  identity_id: string\n  provider: string\n  created_at?: string\n  last_sign_in_at?: string\n  updated_at?: string\n}\n\n/**\n * A MFA factor.\n *\n * @see {@link GoTrueMFAApi#enroll}\n * @see {@link GoTrueMFAApi#listFactors}\n * @see {@link GoTrueMFAAdminApi#listFactors}\n */\nexport interface Factor {\n  /** ID of the factor. */\n  id: string\n\n  /** Friendly name of the factor, useful to disambiguate between multiple factors. */\n  friendly_name?: string\n\n  /**\n   * Type of factor. `totp` and `phone` supported with this version\n   */\n  factor_type: 'totp' | 'phone' | (string & {})\n\n  /** Factor's status. */\n  status: 'verified' | 'unverified'\n\n  created_at: string\n  updated_at: string\n}\n\nexport interface UserAppMetadata {\n  provider?: string\n  [key: string]: any\n}\n\nexport interface UserMetadata {\n  [key: string]: any\n}\n\nexport interface User {\n  id: string\n  app_metadata: UserAppMetadata\n  user_metadata: UserMetadata\n  aud: string\n  confirmation_sent_at?: string\n  recovery_sent_at?: string\n  email_change_sent_at?: string\n  new_email?: string\n  new_phone?: string\n  invited_at?: string\n  action_link?: string\n  email?: string\n  phone?: string\n  created_at: string\n  confirmed_at?: string\n  email_confirmed_at?: string\n  phone_confirmed_at?: string\n  last_sign_in_at?: string\n  role?: string\n  updated_at?: string\n  identities?: UserIdentity[]\n  is_anonymous?: boolean\n  is_sso_user?: boolean\n  factors?: Factor[]\n  deleted_at?: string\n}\n\nexport interface UserAttributes {\n  /**\n   * The user's email.\n   */\n  email?: string\n\n  /**\n   * The user's phone.\n   */\n  phone?: string\n\n  /**\n   * The user's password.\n   */\n  password?: string\n\n  /**\n   * The nonce sent for reauthentication if the user's password is to be updated.\n   *\n   * Call reauthenticate() to obtain the nonce first.\n   */\n  nonce?: string\n\n  /**\n   * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\n   *\n   * The `data` should be a JSON object that includes user-specific info, such as their first and last name.\n   *\n   */\n  data?: object\n}\n\nexport interface AdminUserAttributes extends Omit<UserAttributes, 'data'> {\n  /**\n   * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\n   *\n   *\n   * The `user_metadata` should be a JSON object that includes user-specific info, such as their first and last name.\n   *\n   * Note: When using the GoTrueAdminApi and wanting to modify a user's metadata,\n   * this attribute is used instead of UserAttributes data.\n   *\n   */\n  user_metadata?: object\n\n  /**\n   * A custom data object to store the user's application specific metadata. This maps to the `auth.users.app_metadata` column.\n   *\n   * Only a service role can modify.\n   *\n   * The `app_metadata` should be a JSON object that includes app-specific info, such as identity providers, roles, and other\n   * access control information.\n   */\n  app_metadata?: object\n\n  /**\n   * Confirms the user's email address if set to true.\n   *\n   * Only a service role can modify.\n   */\n  email_confirm?: boolean\n\n  /**\n   * Confirms the user's phone number if set to true.\n   *\n   * Only a service role can modify.\n   */\n  phone_confirm?: boolean\n\n  /**\n   * Determines how long a user is banned for.\n   *\n   * The format for the ban duration follows a strict sequence of decimal numbers with a unit suffix.\n   * Valid time units are \"ns\", \"us\" (or \"\u00B5s\"), \"ms\", \"s\", \"m\", \"h\".\n   *\n   * For example, some possible durations include: '300ms', '2h45m'.\n   *\n   * Setting the ban duration to 'none' lifts the ban on the user.\n   */\n  ban_duration?: string | 'none'\n\n  /**\n   * The `role` claim set in the user's access token JWT.\n   *\n   * When a user signs up, this role is set to `authenticated` by default. You should only modify the `role` if you need to provision several levels of admin access that have different permissions on individual columns in your database.\n   *\n   * Setting this role to `service_role` is not recommended as it grants the user admin privileges.\n   */\n  role?: string\n\n  /**\n   * The `password_hash` for the user's password.\n   *\n   * Allows you to specify a password hash for the user. This is useful for migrating a user's password hash from another service.\n   *\n   * Supports bcrypt, scrypt (firebase), and argon2 password hashes.\n   */\n  password_hash?: string\n\n  /**\n   * The `id` for the user.\n   *\n   * Allows you to overwrite the default `id` set for the user.\n   */\n  id?: string\n}\n\nexport interface Subscription {\n  /**\n   * The subscriber UUID. This will be set by the client.\n   */\n  id: string\n  /**\n   * The function to call every time there is an event. eg: (eventName) => {}\n   */\n  callback: (event: AuthChangeEvent, session: Session | null) => void\n  /**\n   * Call this to remove the listener.\n   */\n  unsubscribe: () => void\n}\n\nexport type SignInAnonymouslyCredentials = {\n  options?: {\n    /**\n     * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\n     *\n     * The `data` should be a JSON object that includes user-specific info, such as their first and last name.\n     */\n    data?: object\n    /** Verification token received when the user completes the captcha on the site. */\n    captchaToken?: string\n  }\n}\n\nexport type SignUpWithPasswordCredentials =\n  | {\n      /** The user's email address. */\n      email: string\n      /** The user's password. */\n      password: string\n      options?: {\n        /** The redirect url embedded in the email link */\n        emailRedirectTo?: string\n        /**\n         * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\n         *\n         * The `data` should be a JSON object that includes user-specific info, such as their first and last name.\n         */\n        data?: object\n        /** Verification token received when the user completes the captcha on the site. */\n        captchaToken?: string\n      }\n    }\n  | {\n      /** The user's phone number. */\n      phone: string\n      /** The user's password. */\n      password: string\n      options?: {\n        /**\n         * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\n         *\n         * The `data` should be a JSON object that includes user-specific info, such as their first and last name.\n         */\n        data?: object\n        /** Verification token received when the user completes the captcha on the site. Requires a configured WhatsApp sender on Twilio */\n        captchaToken?: string\n        /** Messaging channel to use (e.g. whatsapp or sms) */\n        channel?: 'sms' | 'whatsapp'\n      }\n    }\n\nexport type SignInWithPasswordCredentials =\n  | {\n      /** The user's email address. */\n      email: string\n      /** The user's password. */\n      password: string\n      options?: {\n        /** Verification token received when the user completes the captcha on the site. */\n        captchaToken?: string\n      }\n    }\n  | {\n      /** The user's phone number. */\n      phone: string\n      /** The user's password. */\n      password: string\n      options?: {\n        /** Verification token received when the user completes the captcha on the site. */\n        captchaToken?: string\n      }\n    }\n\nexport type SignInWithPasswordlessCredentials =\n  | {\n      /** The user's email address. */\n      email: string\n      options?: {\n        /** The redirect url embedded in the email link */\n        emailRedirectTo?: string\n        /** If set to false, this method will not create a new user. Defaults to true. */\n        shouldCreateUser?: boolean\n        /**\n         * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\n         *\n         * The `data` should be a JSON object that includes user-specific info, such as their first and last name.\n         */\n        data?: object\n        /** Verification token received when the user completes the captcha on the site. */\n        captchaToken?: string\n      }\n    }\n  | {\n      /** The user's phone number. */\n      phone: string\n      options?: {\n        /** If set to false, this method will not create a new user. Defaults to true. */\n        shouldCreateUser?: boolean\n        /**\n         * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\n         *\n         * The `data` should be a JSON object that includes user-specific info, such as their first and last name.\n         */\n        data?: object\n        /** Verification token received when the user completes the captcha on the site. */\n        captchaToken?: string\n        /** Messaging channel to use (e.g. whatsapp or sms) */\n        channel?: 'sms' | 'whatsapp'\n      }\n    }\n\nexport type AuthFlowType = 'implicit' | 'pkce'\nexport type SignInWithOAuthCredentials = {\n  /** One of the providers supported by GoTrue. */\n  provider: Provider\n  options?: {\n    /** A URL to send the user to after they are confirmed. */\n    redirectTo?: string\n    /** A space-separated list of scopes granted to the OAuth application. */\n    scopes?: string\n    /** An object of query params */\n    queryParams?: { [key: string]: string }\n    /** If set to true does not immediately redirect the current browser context to visit the OAuth authorization page for the provider. */\n    skipBrowserRedirect?: boolean\n  }\n}\n\nexport type SignInWithIdTokenCredentials = {\n  /** Provider name or OIDC `iss` value identifying which provider should be used to verify the provided token. Supported names: `google`, `apple`, `azure`, `facebook`, `kakao`, `keycloak` (deprecated). */\n  provider: 'google' | 'apple' | 'azure' | 'facebook' | 'kakao' | (string & {})\n  /** OIDC ID token issued by the specified provider. The `iss` claim in the ID token must match the supplied provider. Some ID tokens contain an `at_hash` which require that you provide an `access_token` value to be accepted properly. If the token contains a `nonce` claim you must supply the nonce used to obtain the ID token. */\n  token: string\n  /** If the ID token contains an `at_hash` claim, then the hash of this value is compared to the value in the ID token. */\n  access_token?: string\n  /** If the ID token contains a `nonce` claim, then the hash of this value is compared to the value in the ID token. */\n  nonce?: string\n  options?: {\n    /** Verification token received when the user completes the captcha on the site. */\n    captchaToken?: string\n  }\n}\n\nexport type SolanaWallet = {\n  signIn?: (...inputs: SolanaSignInInput[]) => Promise<SolanaSignInOutput | SolanaSignInOutput[]>\n  publicKey?: {\n    toBase58: () => string\n  } | null\n\n  signMessage?: (message: Uint8Array, encoding?: 'utf8' | string) => Promise<Uint8Array> | undefined\n}\n\nexport type SolanaWeb3Credentials =\n  | {\n      chain: 'solana'\n\n      /** Wallet interface to use. If not specified will default to `window.solana`. */\n      wallet?: SolanaWallet\n\n      /** Optional statement to include in the Sign in with Solana message. Must not include new line characters. Most wallets like Phantom **require specifying a statement!** */\n      statement?: string\n\n      options?: {\n        /** URL to use with the wallet interface. Some wallets do not allow signing a message for URLs different from the current page. */\n        url?: string\n\n        /** Verification token received when the user completes the captcha on the site. */\n        captchaToken?: string\n\n        signInWithSolana?: Partial<\n          Omit<SolanaSignInInput, 'version' | 'chain' | 'domain' | 'uri' | 'statement'>\n        >\n      }\n    }\n  | {\n      chain: 'solana'\n\n      /** Sign in with Solana compatible message. Must include `Issued At`, `URI` and `Version`. */\n      message: string\n\n      /** Ed25519 signature of the message. */\n      signature: Uint8Array\n\n      options?: {\n        /** Verification token received when the user completes the captcha on the site. */\n        captchaToken?: string\n      }\n    }\n\nexport type Web3Credentials = SolanaWeb3Credentials\n\nexport type VerifyOtpParams = VerifyMobileOtpParams | VerifyEmailOtpParams | VerifyTokenHashParams\nexport interface VerifyMobileOtpParams {\n  /** The user's phone number. */\n  phone: string\n  /** The otp sent to the user's phone number. */\n  token: string\n  /** The user's verification type. */\n  type: MobileOtpType\n  options?: {\n    /** A URL to send the user to after they are confirmed. */\n    redirectTo?: string\n\n    /**\n     * Verification token received when the user completes the captcha on the site.\n     *\n     * @deprecated\n     */\n    captchaToken?: string\n  }\n}\nexport interface VerifyEmailOtpParams {\n  /** The user's email address. */\n  email: string\n  /** The otp sent to the user's email address. */\n  token: string\n  /** The user's verification type. */\n  type: EmailOtpType\n  options?: {\n    /** A URL to send the user to after they are confirmed. */\n    redirectTo?: string\n\n    /** Verification token received when the user completes the captcha on the site.\n     *\n     * @deprecated\n     */\n    captchaToken?: string\n  }\n}\n\nexport interface VerifyTokenHashParams {\n  /** The token hash used in an email link */\n  token_hash: string\n\n  /** The user's verification type. */\n  type: EmailOtpType\n}\n\nexport type MobileOtpType = 'sms' | 'phone_change'\nexport type EmailOtpType = 'signup' | 'invite' | 'magiclink' | 'recovery' | 'email_change' | 'email'\n\nexport type ResendParams =\n  | {\n      type: Extract<EmailOtpType, 'signup' | 'email_change'>\n      email: string\n      options?: {\n        /** A URL to send the user to after they have signed-in. */\n        emailRedirectTo?: string\n        /** Verification token received when the user completes the captcha on the site. */\n        captchaToken?: string\n      }\n    }\n  | {\n      type: Extract<MobileOtpType, 'sms' | 'phone_change'>\n      phone: string\n      options?: {\n        /** Verification token received when the user completes the captcha on the site. */\n        captchaToken?: string\n      }\n    }\n\nexport type SignInWithSSO =\n  | {\n      /** UUID of the SSO provider to invoke single-sign on to. */\n      providerId: string\n\n      options?: {\n        /** A URL to send the user to after they have signed-in. */\n        redirectTo?: string\n        /** Verification token received when the user completes the captcha on the site. */\n        captchaToken?: string\n      }\n    }\n  | {\n      /** Domain name of the organization for which to invoke single-sign on. */\n      domain: string\n\n      options?: {\n        /** A URL to send the user to after they have signed-in. */\n        redirectTo?: string\n        /** Verification token received when the user completes the captcha on the site. */\n        captchaToken?: string\n      }\n    }\n\nexport type GenerateSignupLinkParams = {\n  type: 'signup'\n  email: string\n  password: string\n  options?: Pick<GenerateLinkOptions, 'data' | 'redirectTo'>\n}\n\nexport type GenerateInviteOrMagiclinkParams = {\n  type: 'invite' | 'magiclink'\n  /** The user's email */\n  email: string\n  options?: Pick<GenerateLinkOptions, 'data' | 'redirectTo'>\n}\n\nexport type GenerateRecoveryLinkParams = {\n  type: 'recovery'\n  /** The user's email */\n  email: string\n  options?: Pick<GenerateLinkOptions, 'redirectTo'>\n}\n\nexport type GenerateEmailChangeLinkParams = {\n  type: 'email_change_current' | 'email_change_new'\n  /** The user's email */\n  email: string\n  /**\n   * The user's new email. Only required if type is 'email_change_current' or 'email_change_new'.\n   */\n  newEmail: string\n  options?: Pick<GenerateLinkOptions, 'redirectTo'>\n}\n\nexport interface GenerateLinkOptions {\n  /**\n   * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\n   *\n   * The `data` should be a JSON object that includes user-specific info, such as their first and last name.\n   */\n  data?: object\n  /** The URL which will be appended to the email link generated. */\n  redirectTo?: string\n}\n\nexport type GenerateLinkParams =\n  | GenerateSignupLinkParams\n  | GenerateInviteOrMagiclinkParams\n  | GenerateRecoveryLinkParams\n  | GenerateEmailChangeLinkParams\n\nexport type GenerateLinkResponse =\n  | {\n      data: {\n        properties: GenerateLinkProperties\n        user: User\n      }\n      error: null\n    }\n  | {\n      data: {\n        properties: null\n        user: null\n      }\n      error: AuthError\n    }\n\n/** The properties related to the email link generated  */\nexport type GenerateLinkProperties = {\n  /**\n   * The email link to send to the user.\n   * The action_link follows the following format: auth/v1/verify?type={verification_type}&token={hashed_token}&redirect_to={redirect_to}\n   * */\n  action_link: string\n  /**\n   * The raw email OTP.\n   * You should send this in the email if you want your users to verify using an OTP instead of the action link.\n   * */\n  email_otp: string\n  /**\n   * The hashed token appended to the action link.\n   * */\n  hashed_token: string\n  /** The URL appended to the action link. */\n  redirect_to: string\n  /** The verification type that the email link is associated to. */\n  verification_type: GenerateLinkType\n}\n\nexport type GenerateLinkType =\n  | 'signup'\n  | 'invite'\n  | 'magiclink'\n  | 'recovery'\n  | 'email_change_current'\n  | 'email_change_new'\n\nexport type MFAEnrollParams = MFAEnrollTOTPParams | MFAEnrollPhoneParams\n\nexport type MFAUnenrollParams = {\n  /** ID of the factor being unenrolled. */\n  factorId: string\n}\n\nexport type MFAVerifyParams = {\n  /** ID of the factor being verified. Returned in enroll(). */\n  factorId: string\n\n  /** ID of the challenge being verified. Returned in challenge(). */\n  challengeId: string\n\n  /** Verification code provided by the user. */\n  code: string\n}\n\nexport type MFAChallengeParams = {\n  /** ID of the factor to be challenged. Returned in enroll(). */\n  factorId: string\n  /** Messaging channel to use (e.g. whatsapp or sms). Only relevant for phone factors */\n  channel?: 'sms' | 'whatsapp'\n}\n\nexport type MFAChallengeAndVerifyParams = {\n  /** ID of the factor being verified. Returned in enroll(). */\n  factorId: string\n  /** Verification code provided by the user. */\n  code: string\n}\n\nexport type AuthMFAVerifyResponse =\n  | {\n      data: {\n        /** New access token (JWT) after successful verification. */\n        access_token: string\n\n        /** Type of token, typically `Bearer`. */\n        token_type: string\n\n        /** Number of seconds in which the access token will expire. */\n        expires_in: number\n\n        /** Refresh token you can use to obtain new access tokens when expired. */\n        refresh_token: string\n\n        /** Updated user profile. */\n        user: User\n      }\n      error: null\n    }\n  | {\n      data: null\n      error: AuthError\n    }\n\nexport type AuthMFAEnrollResponse = AuthMFAEnrollTOTPResponse | AuthMFAEnrollPhoneResponse\n\nexport type AuthMFAUnenrollResponse =\n  | {\n      data: {\n        /** ID of the factor that was successfully unenrolled. */\n        id: string\n      }\n      error: null\n    }\n  | { data: null; error: AuthError }\n\nexport type AuthMFAChallengeResponse =\n  | {\n      data: {\n        /** ID of the newly created challenge. */\n        id: string\n\n        /** Factor Type which generated the challenge */\n        type: 'totp' | 'phone'\n\n        /** Timestamp in UNIX seconds when this challenge will no longer be usable. */\n        expires_at: number\n      }\n      error: null\n    }\n  | { data: null; error: AuthError }\n\nexport type AuthMFAListFactorsResponse =\n  | {\n      data: {\n        /** All available factors (verified and unverified). */\n        all: Factor[]\n\n        /** Only verified TOTP factors. (A subset of `all`.) */\n        totp: Factor[]\n        /** Only verified Phone factors. (A subset of `all`.) */\n        phone: Factor[]\n      }\n      error: null\n    }\n  | { data: null; error: AuthError }\n\nexport type AuthenticatorAssuranceLevels = 'aal1' | 'aal2'\n\nexport type AuthMFAGetAuthenticatorAssuranceLevelResponse =\n  | {\n      data: {\n        /** Current AAL level of the session. */\n        currentLevel: AuthenticatorAssuranceLevels | null\n\n        /**\n         * Next possible AAL level for the session. If the next level is higher\n         * than the current one, the user should go through MFA.\n         *\n         * @see {@link GoTrueMFAApi#challenge}\n         */\n        nextLevel: AuthenticatorAssuranceLevels | null\n\n        /**\n         * A list of all authentication methods attached to this session. Use\n         * the information here to detect the last time a user verified a\n         * factor, for example if implementing a step-up scenario.\n         */\n        currentAuthenticationMethods: AMREntry[]\n      }\n      error: null\n    }\n  | { data: null; error: AuthError }\n\n/**\n * Contains the full multi-factor authentication API.\n *\n */\nexport interface GoTrueMFAApi {\n  /**\n   * Starts the enrollment process for a new Multi-Factor Authentication (MFA)\n   * factor. This method creates a new `unverified` factor.\n   * To verify a factor, present the QR code or secret to the user and ask them to add it to their\n   * authenticator app.\n   * The user has to enter the code from their authenticator app to verify it.\n   *\n   * Upon verifying a factor, all other sessions are logged out and the current session's authenticator level is promoted to `aal2`.\n   *\n   */\n  enroll(params: MFAEnrollTOTPParams): Promise<AuthMFAEnrollTOTPResponse>\n  enroll(params: MFAEnrollPhoneParams): Promise<AuthMFAEnrollPhoneResponse>\n  enroll(params: MFAEnrollParams): Promise<AuthMFAEnrollResponse>\n\n  /**\n   * Prepares a challenge used to verify that a user has access to a MFA\n   * factor.\n   */\n  challenge(params: MFAChallengeParams): Promise<AuthMFAChallengeResponse>\n\n  /**\n   * Verifies a code against a challenge. The verification code is\n   * provided by the user by entering a code seen in their authenticator app.\n   */\n  verify(params: MFAVerifyParams): Promise<AuthMFAVerifyResponse>\n\n  /**\n   * Unenroll removes a MFA factor.\n   * A user has to have an `aal2` authenticator level in order to unenroll a `verified` factor.\n   */\n  unenroll(params: MFAUnenrollParams): Promise<AuthMFAUnenrollResponse>\n\n  /**\n   * Helper method which creates a challenge and immediately uses the given code to verify against it thereafter. The verification code is\n   * provided by the user by entering a code seen in their authenticator app.\n   */\n  challengeAndVerify(params: MFAChallengeAndVerifyParams): Promise<AuthMFAVerifyResponse>\n\n  /**\n   * Returns the list of MFA factors enabled for this user.\n   *\n   * @see {@link GoTrueMFAApi#enroll}\n   * @see {@link GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n   * @see {@link GoTrueClient#getUser}\n   *\n   */\n  listFactors(): Promise<AuthMFAListFactorsResponse>\n\n  /**\n   * Returns the Authenticator Assurance Level (AAL) for the active session.\n   *\n   * - `aal1` (or `null`) means that the user's identity has been verified only\n   * with a conventional login (email+password, OTP, magic link, social login,\n   * etc.).\n   * - `aal2` means that the user's identity has been verified both with a conventional login and at least one MFA factor.\n   *\n   * Although this method returns a promise, it's fairly quick (microseconds)\n   * and rarely uses the network. You can use this to check whether the current\n   * user needs to be shown a screen to verify their MFA factors.\n   *\n   */\n  getAuthenticatorAssuranceLevel(): Promise<AuthMFAGetAuthenticatorAssuranceLevelResponse>\n}\n\n/**\n * @expermental\n */\nexport type AuthMFAAdminDeleteFactorResponse =\n  | {\n      data: {\n        /** ID of the factor that was successfully deleted. */\n        id: string\n      }\n      error: null\n    }\n  | { data: null; error: AuthError }\n\n/**\n * @expermental\n */\nexport type AuthMFAAdminDeleteFactorParams = {\n  /** ID of the MFA factor to delete. */\n  id: string\n\n  /** ID of the user whose factor is being deleted. */\n  userId: string\n}\n\n/**\n * @expermental\n */\nexport type AuthMFAAdminListFactorsResponse =\n  | {\n      data: {\n        /** All factors attached to the user. */\n        factors: Factor[]\n      }\n      error: null\n    }\n  | { data: null; error: AuthError }\n\n/**\n * @expermental\n */\nexport type AuthMFAAdminListFactorsParams = {\n  /** ID of the user. */\n  userId: string\n}\n\n/**\n * Contains the full multi-factor authentication administration API.\n *\n * @expermental\n */\nexport interface GoTrueAdminMFAApi {\n  /**\n   * Lists all factors associated to a user.\n   *\n   */\n  listFactors(params: AuthMFAAdminListFactorsParams): Promise<AuthMFAAdminListFactorsResponse>\n\n  /**\n   * Deletes a factor on a user. This will log the user out of all active\n   * sessions if the deleted factor was verified.\n   *\n   * @see {@link GoTrueMFAApi#unenroll}\n   *\n   * @expermental\n   */\n  deleteFactor(params: AuthMFAAdminDeleteFactorParams): Promise<AuthMFAAdminDeleteFactorResponse>\n}\n\ntype AnyFunction = (...args: any[]) => any\ntype MaybePromisify<T> = T | Promise<T>\n\ntype PromisifyMethods<T> = {\n  [K in keyof T]: T[K] extends AnyFunction\n    ? (...args: Parameters<T[K]>) => MaybePromisify<ReturnType<T[K]>>\n    : T[K]\n}\n\nexport type SupportedStorage = PromisifyMethods<\n  Pick<Storage, 'getItem' | 'setItem' | 'removeItem'>\n> & {\n  /**\n   * If set to `true` signals to the library that the storage medium is used\n   * on a server and the values may not be authentic, such as reading from\n   * request cookies. Implementations should not set this to true if the client\n   * is used on a server that reads storage information from authenticated\n   * sources, such as a secure database or file.\n   */\n  isServer?: boolean\n}\n\nexport type InitializeResult = { error: AuthError | null }\n\nexport type CallRefreshTokenResult =\n  | {\n      session: Session\n      error: null\n    }\n  | {\n      session: null\n      error: AuthError\n    }\n\nexport type Pagination = {\n  [key: string]: any\n  nextPage: number | null\n  lastPage: number\n  total: number\n}\n\nexport type PageParams = {\n  /** The page number */\n  page?: number\n  /** Number of items returned per page */\n  perPage?: number\n}\n\nexport type SignOut = {\n  /**\n   * Determines which sessions should be\n   * logged out. Global means all\n   * sessions by this account. Local\n   * means only this session. Others\n   * means all other sessions except the\n   * current one. When using others,\n   * there is no sign-out event fired on\n   * the current session!\n   */\n  scope?: 'global' | 'local' | 'others'\n}\n\nexport type MFAEnrollTOTPParams = {\n  /** The type of factor being enrolled. */\n  factorType: 'totp'\n  /** Domain which the user is enrolled with. */\n  issuer?: string\n  /** Human readable name assigned to the factor. */\n  friendlyName?: string\n}\nexport type MFAEnrollPhoneParams = {\n  /** The type of factor being enrolled. */\n  factorType: 'phone'\n  /** Human readable name assigned to the factor. */\n  friendlyName?: string\n  /** Phone number associated with a factor. Number should conform to E.164 format */\n  phone: string\n}\n\nexport type AuthMFAEnrollTOTPResponse =\n  | {\n      data: {\n        /** ID of the factor that was just enrolled (in an unverified state). */\n        id: string\n\n        /** Type of MFA factor.*/\n        type: 'totp'\n\n        /** TOTP enrollment information. */\n        totp: {\n          /** Contains a QR code encoding the authenticator URI. You can\n           * convert it to a URL by prepending `data:image/svg+xml;utf-8,` to\n           * the value. Avoid logging this value to the console. */\n          qr_code: string\n\n          /** The TOTP secret (also encoded in the QR code). Show this secret\n           * in a password-style field to the user, in case they are unable to\n           * scan the QR code. Avoid logging this value to the console. */\n          secret: string\n\n          /** The authenticator URI encoded within the QR code, should you need\n           * to use it. Avoid loggin this value to the console. */\n          uri: string\n        }\n        /** Friendly name of the factor, useful for distinguishing between factors **/\n        friendly_name?: string\n      }\n      error: null\n    }\n  | {\n      data: null\n      error: AuthError\n    }\n\nexport type AuthMFAEnrollPhoneResponse =\n  | {\n      data: {\n        /** ID of the factor that was just enrolled (in an unverified state). */\n        id: string\n\n        /** Type of MFA factor. */\n        type: 'phone'\n\n        /** Friendly name of the factor, useful for distinguishing between factors **/\n        friendly_name?: string\n\n        /** Phone number of the MFA factor in E.164 format. Used to send messages  */\n        phone: string\n      }\n      error: null\n    }\n  | {\n      data: null\n      error: AuthError\n    }\n\nexport type JwtHeader = {\n  alg: 'RS256' | 'ES256' | 'HS256'\n  kid: string\n  typ: string\n}\n\nexport type RequiredClaims = {\n  iss: string\n  sub: string\n  aud: string | string[]\n  exp: number\n  iat: number\n  role: string\n  aal: AuthenticatorAssuranceLevels\n  session_id: string\n}\n\nexport type JwtPayload = RequiredClaims & {\n  [key: string]: any\n}\n\nexport interface JWK {\n  kty: 'RSA' | 'EC' | 'oct'\n  key_ops: string[]\n  alg?: string\n  kid?: string\n  [key: string]: any\n}\n\nexport const SIGN_OUT_SCOPES = ['global', 'local', 'others'] as const\nexport type SignOutScope = typeof SIGN_OUT_SCOPES[number]\n", "import {\n  Fetch,\n  _generateLinkResponse,\n  _noResolveJsonResponse,\n  _request,\n  _userResponse,\n} from './lib/fetch'\nimport { resolveFetch, validateUUID } from './lib/helpers'\nimport {\n  AdminUserAttributes,\n  GenerateLinkParams,\n  GenerateLinkResponse,\n  Pagination,\n  User,\n  UserResponse,\n  GoTrueAdminMFAApi,\n  AuthMFAAdminDeleteFactorParams,\n  AuthMFAAdminDeleteFactorResponse,\n  AuthMFAAdminListFactorsParams,\n  AuthMFAAdminListFactorsResponse,\n  PageParams,\n  SIGN_OUT_SCOPES,\n  SignOutScope,\n} from './lib/types'\nimport { AuthError, isAuthError } from './lib/errors'\n\nexport default class GoTrueAdminApi {\n  /** Contains all MFA administration methods. */\n  mfa: GoTrueAdminMFAApi\n\n  protected url: string\n  protected headers: {\n    [key: string]: string\n  }\n  protected fetch: Fetch\n\n  constructor({\n    url = '',\n    headers = {},\n    fetch,\n  }: {\n    url: string\n    headers?: {\n      [key: string]: string\n    }\n    fetch?: Fetch\n  }) {\n    this.url = url\n    this.headers = headers\n    this.fetch = resolveFetch(fetch)\n    this.mfa = {\n      listFactors: this._listFactors.bind(this),\n      deleteFactor: this._deleteFactor.bind(this),\n    }\n  }\n\n  /**\n   * Removes a logged-in session.\n   * @param jwt A valid, logged-in JWT.\n   * @param scope The logout sope.\n   */\n  async signOut(\n    jwt: string,\n    scope: SignOutScope = SIGN_OUT_SCOPES[0]\n  ): Promise<{ data: null; error: AuthError | null }> {\n    if (SIGN_OUT_SCOPES.indexOf(scope) < 0) {\n      throw new Error(\n        `@supabase/auth-js: Parameter scope must be one of ${SIGN_OUT_SCOPES.join(', ')}`\n      )\n    }\n\n    try {\n      await _request(this.fetch, 'POST', `${this.url}/logout?scope=${scope}`, {\n        headers: this.headers,\n        jwt,\n        noResolveJson: true,\n      })\n      return { data: null, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Sends an invite link to an email address.\n   * @param email The email address of the user.\n   * @param options Additional options to be included when inviting.\n   */\n  async inviteUserByEmail(\n    email: string,\n    options: {\n      /** A custom data object to store additional metadata about the user. This maps to the `auth.users.user_metadata` column. */\n      data?: object\n\n      /** The URL which will be appended to the email link sent to the user's email address. Once clicked the user will end up on this URL. */\n      redirectTo?: string\n    } = {}\n  ): Promise<UserResponse> {\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/invite`, {\n        body: { email, data: options.data },\n        headers: this.headers,\n        redirectTo: options.redirectTo,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Generates email links and OTPs to be sent via a custom email provider.\n   * @param email The user's email.\n   * @param options.password User password. For signup only.\n   * @param options.data Optional user metadata. For signup only.\n   * @param options.redirectTo The redirect url which should be appended to the generated link\n   */\n  async generateLink(params: GenerateLinkParams): Promise<GenerateLinkResponse> {\n    try {\n      const { options, ...rest } = params\n      const body: any = { ...rest, ...options }\n      if ('newEmail' in rest) {\n        // replace newEmail with new_email in request body\n        body.new_email = rest?.newEmail\n        delete body['newEmail']\n      }\n      return await _request(this.fetch, 'POST', `${this.url}/admin/generate_link`, {\n        body: body,\n        headers: this.headers,\n        xform: _generateLinkResponse,\n        redirectTo: options?.redirectTo,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: {\n            properties: null,\n            user: null,\n          },\n          error,\n        }\n      }\n      throw error\n    }\n  }\n\n  // User Admin API\n  /**\n   * Creates a new user.\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async createUser(attributes: AdminUserAttributes): Promise<UserResponse> {\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/admin/users`, {\n        body: attributes,\n        headers: this.headers,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Get a list of users.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.\n   */\n  async listUsers(\n    params?: PageParams\n  ): Promise<\n    | { data: { users: User[]; aud: string } & Pagination; error: null }\n    | { data: { users: [] }; error: AuthError }\n  > {\n    try {\n      const pagination: Pagination = { nextPage: null, lastPage: 0, total: 0 }\n      const response = await _request(this.fetch, 'GET', `${this.url}/admin/users`, {\n        headers: this.headers,\n        noResolveJson: true,\n        query: {\n          page: params?.page?.toString() ?? '',\n          per_page: params?.perPage?.toString() ?? '',\n        },\n        xform: _noResolveJsonResponse,\n      })\n      if (response.error) throw response.error\n\n      const users = await response.json()\n      const total = response.headers.get('x-total-count') ?? 0\n      const links = response.headers.get('link')?.split(',') ?? []\n      if (links.length > 0) {\n        links.forEach((link: string) => {\n          const page = parseInt(link.split(';')[0].split('=')[1].substring(0, 1))\n          const rel = JSON.parse(link.split(';')[1].split('=')[1])\n          pagination[`${rel}Page`] = page\n        })\n\n        pagination.total = parseInt(total)\n      }\n      return { data: { ...users, ...pagination }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { users: [] }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Get user by id.\n   *\n   * @param uid The user's unique identifier\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async getUserById(uid: string): Promise<UserResponse> {\n    validateUUID(uid)\n\n    try {\n      return await _request(this.fetch, 'GET', `${this.url}/admin/users/${uid}`, {\n        headers: this.headers,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Updates the user data.\n   *\n   * @param attributes The data you want to update.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async updateUserById(uid: string, attributes: AdminUserAttributes): Promise<UserResponse> {\n    validateUUID(uid)\n\n    try {\n      return await _request(this.fetch, 'PUT', `${this.url}/admin/users/${uid}`, {\n        body: attributes,\n        headers: this.headers,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Delete a user. Requires a `service_role` key.\n   *\n   * @param id The user id you want to remove.\n   * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.\n   * Defaults to false for backward compatibility.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async deleteUser(id: string, shouldSoftDelete = false): Promise<UserResponse> {\n    validateUUID(id)\n\n    try {\n      return await _request(this.fetch, 'DELETE', `${this.url}/admin/users/${id}`, {\n        headers: this.headers,\n        body: {\n          should_soft_delete: shouldSoftDelete,\n        },\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  private async _listFactors(\n    params: AuthMFAAdminListFactorsParams\n  ): Promise<AuthMFAAdminListFactorsResponse> {\n    validateUUID(params.userId)\n\n    try {\n      const { data, error } = await _request(\n        this.fetch,\n        'GET',\n        `${this.url}/admin/users/${params.userId}/factors`,\n        {\n          headers: this.headers,\n          xform: (factors: any) => {\n            return { data: { factors }, error: null }\n          },\n        }\n      )\n      return { data, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  private async _deleteFactor(\n    params: AuthMFAAdminDeleteFactorParams\n  ): Promise<AuthMFAAdminDeleteFactorResponse> {\n    validateUUID(params.userId)\n    validateUUID(params.id)\n\n    try {\n      const data = await _request(\n        this.fetch,\n        'DELETE',\n        `${this.url}/admin/users/${params.userId}/factors/${params.id}`,\n        {\n          headers: this.headers,\n        }\n      )\n\n      return { data, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n}\n", "import GoTrueAdminApi from './GoTrueAdminApi'\nimport {\n  DEFAULT_HEADERS,\n  EXPIRY_MARGIN_MS,\n  AUTO_REFRESH_TICK_DURATION_MS,\n  AUTO_REFRESH_TICK_THRESHOLD,\n  GOTRUE_URL,\n  STORAGE_KEY,\n  JWKS_TTL,\n} from './lib/constants'\nimport {\n  AuthError,\n  AuthImplicitGrantRedirectError,\n  AuthPKCEGrantCodeExchangeError,\n  AuthInvalidCredentialsError,\n  AuthSessionMissingError,\n  AuthInvalidTokenResponseError,\n  AuthUnknownError,\n  isAuthApiError,\n  isAuthError,\n  isAuthRetryableFetchError,\n  isAuthSessionMissingError,\n  isAuthImplicitGrantRedirectError,\n  AuthInvalidJwtError,\n} from './lib/errors'\nimport {\n  Fetch,\n  _request,\n  _sessionResponse,\n  _sessionResponsePassword,\n  _userResponse,\n  _ssoResponse,\n} from './lib/fetch'\nimport {\n  Deferred,\n  getItemAsync,\n  isBrowser,\n  removeItemAsync,\n  resolveFetch,\n  setItemAsync,\n  uuid,\n  retryable,\n  sleep,\n  supportsLocalStorage,\n  parseParametersFromURL,\n  getCodeChallengeAndMethod,\n  getAlgorithm,\n  validateExp,\n  decodeJWT,\n} from './lib/helpers'\nimport { localStorageAdapter, memoryLocalStorageAdapter } from './lib/local-storage'\nimport { polyfillGlobalThis } from './lib/polyfills'\nimport { version } from './lib/version'\nimport { LockAcquireTimeoutError, navigatorLock } from './lib/locks'\n\nimport type {\n  AuthChangeEvent,\n  AuthResponse,\n  AuthResponsePassword,\n  AuthTokenResponse,\n  AuthTokenResponsePassword,\n  AuthOtpResponse,\n  CallRefreshTokenResult,\n  GoTrueClientOptions,\n  InitializeResult,\n  OAuthResponse,\n  SSOResponse,\n  Provider,\n  Session,\n  SignInWithIdTokenCredentials,\n  SignInWithOAuthCredentials,\n  SignInWithPasswordCredentials,\n  SignInWithPasswordlessCredentials,\n  SignUpWithPasswordCredentials,\n  SignInWithSSO,\n  SignOut,\n  Subscription,\n  SupportedStorage,\n  User,\n  UserAttributes,\n  UserResponse,\n  VerifyOtpParams,\n  GoTrueMFAApi,\n  MFAEnrollParams,\n  AuthMFAEnrollResponse,\n  MFAChallengeParams,\n  AuthMFAChallengeResponse,\n  MFAUnenrollParams,\n  AuthMFAUnenrollResponse,\n  MFAVerifyParams,\n  AuthMFAVerifyResponse,\n  AuthMFAListFactorsResponse,\n  AuthMFAGetAuthenticatorAssuranceLevelResponse,\n  AuthenticatorAssuranceLevels,\n  Factor,\n  MFAChallengeAndVerifyParams,\n  ResendParams,\n  AuthFlowType,\n  LockFunc,\n  UserIdentity,\n  SignInAnonymouslyCredentials,\n  MFAEnrollTOTPParams,\n  MFAEnrollPhoneParams,\n  AuthMFAEnrollTOTPResponse,\n  AuthMFAEnrollPhoneResponse,\n  JWK,\n  JwtPayload,\n  JwtHeader,\n  SolanaWeb3Credentials,\n  SolanaWallet,\n  Web3Credentials,\n} from './lib/types'\nimport { stringToUint8Array, bytesToBase64URL } from './lib/base64url'\n\npolyfillGlobalThis() // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS: Omit<Required<GoTrueClientOptions>, 'fetch' | 'storage' | 'lock'> = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS,\n  flowType: 'implicit',\n  debug: false,\n  hasCustomAuthorizationHeader: false,\n}\n\nasync function lockNoOp<R>(name: string, acquireTimeout: number, fn: () => Promise<R>): Promise<R> {\n  return await fn()\n}\n\nexport default class GoTrueClient {\n  private static nextInstanceID = 0\n\n  private instanceID: number\n\n  /**\n   * Namespace for the GoTrue admin methods.\n   * These methods should only be used in a trusted server-side environment.\n   */\n  admin: GoTrueAdminApi\n  /**\n   * Namespace for the MFA methods.\n   */\n  mfa: GoTrueMFAApi\n  /**\n   * The storage key used to identify the values saved in localStorage\n   */\n  protected storageKey: string\n\n  protected flowType: AuthFlowType\n  /**\n   * The JWKS used for verifying asymmetric JWTs\n   */\n  protected jwks: { keys: JWK[] }\n  protected jwks_cached_at: number\n  protected autoRefreshToken: boolean\n  protected persistSession: boolean\n  protected storage: SupportedStorage\n  protected memoryStorage: { [key: string]: string } | null = null\n  protected stateChangeEmitters: Map<string, Subscription> = new Map()\n  protected autoRefreshTicker: ReturnType<typeof setInterval> | null = null\n  protected visibilityChangedCallback: (() => Promise<any>) | null = null\n  protected refreshingDeferred: Deferred<CallRefreshTokenResult> | null = null\n  /**\n   * Keeps track of the async client initialization.\n   * When null or not yet resolved the auth state is `unknown`\n   * Once resolved the the auth state is known and it's save to call any further client methods.\n   * Keep extra care to never reject or throw uncaught errors\n   */\n  protected initializePromise: Promise<InitializeResult> | null = null\n  protected detectSessionInUrl = true\n  protected url: string\n  protected headers: {\n    [key: string]: string\n  }\n  protected hasCustomAuthorizationHeader = false\n  protected suppressGetSessionWarning = false\n  protected fetch: Fetch\n  protected lock: LockFunc\n  protected lockAcquired = false\n  protected pendingInLock: Promise<any>[] = []\n\n  /**\n   * Used to broadcast state change events to other tabs listening.\n   */\n  protected broadcastChannel: BroadcastChannel | null = null\n\n  protected logDebugMessages: boolean\n  protected logger: (message: string, ...args: any[]) => void = console.log\n\n  /**\n   * Create a new client for use in the browser.\n   */\n  constructor(options: GoTrueClientOptions) {\n    this.instanceID = GoTrueClient.nextInstanceID\n    GoTrueClient.nextInstanceID += 1\n\n    if (this.instanceID > 0 && isBrowser()) {\n      console.warn(\n        'Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.'\n      )\n    }\n\n    const settings = { ...DEFAULT_OPTIONS, ...options }\n\n    this.logDebugMessages = !!settings.debug\n    if (typeof settings.debug === 'function') {\n      this.logger = settings.debug\n    }\n\n    this.persistSession = settings.persistSession\n    this.storageKey = settings.storageKey\n    this.autoRefreshToken = settings.autoRefreshToken\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch,\n    })\n\n    this.url = settings.url\n    this.headers = settings.headers\n    this.fetch = resolveFetch(settings.fetch)\n    this.lock = settings.lock || lockNoOp\n    this.detectSessionInUrl = settings.detectSessionInUrl\n    this.flowType = settings.flowType\n    this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader\n\n    if (settings.lock) {\n      this.lock = settings.lock\n    } else if (isBrowser() && globalThis?.navigator?.locks) {\n      this.lock = navigatorLock\n    } else {\n      this.lock = lockNoOp\n    }\n    this.jwks = { keys: [] }\n    this.jwks_cached_at = Number.MIN_SAFE_INTEGER\n    this.mfa = {\n      verify: this._verify.bind(this),\n      enroll: this._enroll.bind(this),\n      unenroll: this._unenroll.bind(this),\n      challenge: this._challenge.bind(this),\n      listFactors: this._listFactors.bind(this),\n      challengeAndVerify: this._challengeAndVerify.bind(this),\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\n    }\n\n    if (this.persistSession) {\n      if (settings.storage) {\n        this.storage = settings.storage\n      } else {\n        if (supportsLocalStorage()) {\n          this.storage = localStorageAdapter\n        } else {\n          this.memoryStorage = {}\n          this.storage = memoryLocalStorageAdapter(this.memoryStorage)\n        }\n      }\n    } else {\n      this.memoryStorage = {}\n      this.storage = memoryLocalStorageAdapter(this.memoryStorage)\n    }\n\n    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n      try {\n        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey)\n      } catch (e: any) {\n        console.error(\n          'Failed to create a new BroadcastChannel, multi-tab state changes will not be available',\n          e\n        )\n      }\n\n      this.broadcastChannel?.addEventListener('message', async (event) => {\n        this._debug('received broadcast notification from other tab or client', event)\n\n        await this._notifyAllSubscribers(event.data.event, event.data.session, false) // broadcast = false so we don't get an endless loop of messages\n      })\n    }\n\n    this.initialize()\n  }\n\n  private _debug(...args: any[]): GoTrueClient {\n    if (this.logDebugMessages) {\n      this.logger(\n        `GoTrueClient@${this.instanceID} (${version}) ${new Date().toISOString()}`,\n        ...args\n      )\n    }\n\n    return this\n  }\n\n  /**\n   * Initializes the client session either from the url or from storage.\n   * This method is automatically called when instantiating the client, but should also be called\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n   */\n  async initialize(): Promise<InitializeResult> {\n    if (this.initializePromise) {\n      return await this.initializePromise\n    }\n\n    this.initializePromise = (async () => {\n      return await this._acquireLock(-1, async () => {\n        return await this._initialize()\n      })\n    })()\n\n    return await this.initializePromise\n  }\n\n  /**\n   * IMPORTANT:\n   * 1. Never throw in this method, as it is called from the constructor\n   * 2. Never return a session from this method as it would be cached over\n   *    the whole lifetime of the client\n   */\n  private async _initialize(): Promise<InitializeResult> {\n    try {\n      const params = parseParametersFromURL(window.location.href)\n      let callbackUrlType = 'none'\n      if (this._isImplicitGrantCallback(params)) {\n        callbackUrlType = 'implicit'\n      } else if (await this._isPKCECallback(params)) {\n        callbackUrlType = 'pkce'\n      }\n\n      /**\n       * Attempt to get the session from the URL only if these conditions are fulfilled\n       *\n       * Note: If the URL isn't one of the callback url types (implicit or pkce),\n       * then there could be an existing session so we don't want to prematurely remove it\n       */\n      if (isBrowser() && this.detectSessionInUrl && callbackUrlType !== 'none') {\n        const { data, error } = await this._getSessionFromURL(params, callbackUrlType)\n        if (error) {\n          this._debug('#_initialize()', 'error detecting session from URL', error)\n\n          if (isAuthImplicitGrantRedirectError(error)) {\n            const errorCode = error.details?.code\n            if (\n              errorCode === 'identity_already_exists' ||\n              errorCode === 'identity_not_found' ||\n              errorCode === 'single_identity_not_deletable'\n            ) {\n              return { error }\n            }\n          }\n\n          // failed login attempt via url,\n          // remove old session as in verifyOtp, signUp and signInWith*\n          await this._removeSession()\n\n          return { error }\n        }\n\n        const { session, redirectType } = data\n\n        this._debug(\n          '#_initialize()',\n          'detected session in URL',\n          session,\n          'redirect type',\n          redirectType\n        )\n\n        await this._saveSession(session)\n\n        setTimeout(async () => {\n          if (redirectType === 'recovery') {\n            await this._notifyAllSubscribers('PASSWORD_RECOVERY', session)\n          } else {\n            await this._notifyAllSubscribers('SIGNED_IN', session)\n          }\n        }, 0)\n\n        return { error: null }\n      }\n      // no login attempt via callback url try to recover session from storage\n      await this._recoverAndRefresh()\n      return { error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { error }\n      }\n\n      return {\n        error: new AuthUnknownError('Unexpected error during initialization', error),\n      }\n    } finally {\n      await this._handleVisibilityChange()\n      this._debug('#_initialize()', 'end')\n    }\n  }\n\n  /**\n   * Creates a new anonymous user.\n   *\n   * @returns A session where the is_anonymous claim in the access token JWT set to true\n   */\n  async signInAnonymously(credentials?: SignInAnonymouslyCredentials): Promise<AuthResponse> {\n    try {\n      const res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\n        headers: this.headers,\n        body: {\n          data: credentials?.options?.data ?? {},\n          gotrue_meta_security: { captcha_token: credentials?.options?.captchaToken },\n        },\n        xform: _sessionResponse,\n      })\n      const { data, error } = res\n\n      if (error || !data) {\n        return { data: { user: null, session: null }, error: error }\n      }\n      const session: Session | null = data.session\n      const user: User | null = data.user\n\n      if (data.session) {\n        await this._saveSession(data.session)\n        await this._notifyAllSubscribers('SIGNED_IN', session)\n      }\n\n      return { data: { user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates a new user.\n   *\n   * Be aware that if a user account exists in the system you may get back an\n   * error message that attempts to hide this information from the user.\n   * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.\n   *\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n  async signUp(credentials: SignUpWithPasswordCredentials): Promise<AuthResponse> {\n    try {\n      let res: AuthResponse\n      if ('email' in credentials) {\n        const { email, password, options } = credentials\n        let codeChallenge: string | null = null\n        let codeChallengeMethod: string | null = null\n        if (this.flowType === 'pkce') {\n          ;[codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(\n            this.storage,\n            this.storageKey\n          )\n        }\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\n          headers: this.headers,\n          redirectTo: options?.emailRedirectTo,\n          body: {\n            email,\n            password,\n            data: options?.data ?? {},\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n            code_challenge: codeChallenge,\n            code_challenge_method: codeChallengeMethod,\n          },\n          xform: _sessionResponse,\n        })\n      } else if ('phone' in credentials) {\n        const { phone, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\n          headers: this.headers,\n          body: {\n            phone,\n            password,\n            data: options?.data ?? {},\n            channel: options?.channel ?? 'sms',\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else {\n        throw new AuthInvalidCredentialsError(\n          'You must provide either an email or phone number and a password'\n        )\n      }\n\n      const { data, error } = res\n\n      if (error || !data) {\n        return { data: { user: null, session: null }, error: error }\n      }\n\n      const session: Session | null = data.session\n      const user: User | null = data.user\n\n      if (data.session) {\n        await this._saveSession(data.session)\n        await this._notifyAllSubscribers('SIGNED_IN', session)\n      }\n\n      return { data: { user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Log in an existing user with an email and password or phone and password.\n   *\n   * Be aware that you may get back an error message that will not distinguish\n   * between the cases where the account does not exist or that the\n   * email/phone and password combination is wrong or that the account can only\n   * be accessed via social login.\n   */\n  async signInWithPassword(\n    credentials: SignInWithPasswordCredentials\n  ): Promise<AuthTokenResponsePassword> {\n    try {\n      let res: AuthResponsePassword\n      if ('email' in credentials) {\n        const { email, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n          headers: this.headers,\n          body: {\n            email,\n            password,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponsePassword,\n        })\n      } else if ('phone' in credentials) {\n        const { phone, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n          headers: this.headers,\n          body: {\n            phone,\n            password,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponsePassword,\n        })\n      } else {\n        throw new AuthInvalidCredentialsError(\n          'You must provide either an email or phone number and a password'\n        )\n      }\n      const { data, error } = res\n\n      if (error) {\n        return { data: { user: null, session: null }, error }\n      } else if (!data || !data.session || !data.user) {\n        return { data: { user: null, session: null }, error: new AuthInvalidTokenResponseError() }\n      }\n      if (data.session) {\n        await this._saveSession(data.session)\n        await this._notifyAllSubscribers('SIGNED_IN', data.session)\n      }\n      return {\n        data: {\n          user: data.user,\n          session: data.session,\n          ...(data.weak_password ? { weakPassword: data.weak_password } : null),\n        },\n        error,\n      }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Log in an existing user via a third-party provider.\n   * This method supports the PKCE flow.\n   */\n  async signInWithOAuth(credentials: SignInWithOAuthCredentials): Promise<OAuthResponse> {\n    return await this._handleProviderSignIn(credentials.provider, {\n      redirectTo: credentials.options?.redirectTo,\n      scopes: credentials.options?.scopes,\n      queryParams: credentials.options?.queryParams,\n      skipBrowserRedirect: credentials.options?.skipBrowserRedirect,\n    })\n  }\n\n  /**\n   * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.\n   */\n  async exchangeCodeForSession(authCode: string): Promise<AuthTokenResponse> {\n    await this.initializePromise\n\n    return this._acquireLock(-1, async () => {\n      return this._exchangeCodeForSession(authCode)\n    })\n  }\n\n  /**\n   * Signs in a user by verifying a message signed by the user's private key.\n   * Only Solana supported at this time, using the Sign in with Solana standard.\n   */\n  async signInWithWeb3(credentials: Web3Credentials): Promise<\n    | {\n        data: { session: Session; user: User }\n        error: null\n      }\n    | { data: { session: null; user: null }; error: AuthError }\n  > {\n    const { chain } = credentials\n\n    if (chain === 'solana') {\n      return await this.signInWithSolana(credentials)\n    }\n\n    throw new Error(`@supabase/auth-js: Unsupported chain \"${chain}\"`)\n  }\n\n  private async signInWithSolana(credentials: SolanaWeb3Credentials) {\n    let message: string\n    let signature: Uint8Array\n\n    if ('message' in credentials) {\n      message = credentials.message\n      signature = credentials.signature\n    } else {\n      const { chain, wallet, statement, options } = credentials\n\n      let resolvedWallet: SolanaWallet\n\n      if (!isBrowser()) {\n        if (typeof wallet !== 'object' || !options?.url) {\n          throw new Error(\n            '@supabase/auth-js: Both wallet and url must be specified in non-browser environments.'\n          )\n        }\n\n        resolvedWallet = wallet\n      } else if (typeof wallet === 'object') {\n        resolvedWallet = wallet\n      } else {\n        const windowAny = window as any\n\n        if (\n          'solana' in windowAny &&\n          typeof windowAny.solana === 'object' &&\n          (('signIn' in windowAny.solana && typeof windowAny.solana.signIn === 'function') ||\n            ('signMessage' in windowAny.solana &&\n              typeof windowAny.solana.signMessage === 'function'))\n        ) {\n          resolvedWallet = windowAny.solana\n        } else {\n          throw new Error(\n            `@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.`\n          )\n        }\n      }\n\n      const url = new URL(options?.url ?? window.location.href)\n\n      if ('signIn' in resolvedWallet && resolvedWallet.signIn) {\n        const output = await resolvedWallet.signIn({\n          issuedAt: new Date().toISOString(),\n\n          ...options?.signInWithSolana,\n\n          // non-overridable properties\n          version: '1',\n          domain: url.host,\n          uri: url.href,\n\n          ...(statement ? { statement } : null),\n        })\n\n        let outputToProcess: any\n\n        if (Array.isArray(output) && output[0] && typeof output[0] === 'object') {\n          outputToProcess = output[0]\n        } else if (\n          output &&\n          typeof output === 'object' &&\n          'signedMessage' in output &&\n          'signature' in output\n        ) {\n          outputToProcess = output\n        } else {\n          throw new Error('@supabase/auth-js: Wallet method signIn() returned unrecognized value')\n        }\n\n        if (\n          'signedMessage' in outputToProcess &&\n          'signature' in outputToProcess &&\n          (typeof outputToProcess.signedMessage === 'string' ||\n            outputToProcess.signedMessage instanceof Uint8Array) &&\n          outputToProcess.signature instanceof Uint8Array\n        ) {\n          message =\n            typeof outputToProcess.signedMessage === 'string'\n              ? outputToProcess.signedMessage\n              : new TextDecoder().decode(outputToProcess.signedMessage)\n          signature = outputToProcess.signature\n        } else {\n          throw new Error(\n            '@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields'\n          )\n        }\n      } else {\n        if (\n          !('signMessage' in resolvedWallet) ||\n          typeof resolvedWallet.signMessage !== 'function' ||\n          !('publicKey' in resolvedWallet) ||\n          typeof resolvedWallet !== 'object' ||\n          !resolvedWallet.publicKey ||\n          !('toBase58' in resolvedWallet.publicKey) ||\n          typeof resolvedWallet.publicKey.toBase58 !== 'function'\n        ) {\n          throw new Error(\n            '@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API'\n          )\n        }\n\n        message = [\n          `${url.host} wants you to sign in with your Solana account:`,\n          resolvedWallet.publicKey.toBase58(),\n          ...(statement ? ['', statement, ''] : ['']),\n          'Version: 1',\n          `URI: ${url.href}`,\n          `Issued At: ${options?.signInWithSolana?.issuedAt ?? new Date().toISOString()}`,\n          ...(options?.signInWithSolana?.notBefore\n            ? [`Not Before: ${options.signInWithSolana.notBefore}`]\n            : []),\n          ...(options?.signInWithSolana?.expirationTime\n            ? [`Expiration Time: ${options.signInWithSolana.expirationTime}`]\n            : []),\n          ...(options?.signInWithSolana?.chainId\n            ? [`Chain ID: ${options.signInWithSolana.chainId}`]\n            : []),\n          ...(options?.signInWithSolana?.nonce ? [`Nonce: ${options.signInWithSolana.nonce}`] : []),\n          ...(options?.signInWithSolana?.requestId\n            ? [`Request ID: ${options.signInWithSolana.requestId}`]\n            : []),\n          ...(options?.signInWithSolana?.resources?.length\n            ? [\n                'Resources',\n                ...options.signInWithSolana.resources.map((resource) => `- ${resource}`),\n              ]\n            : []),\n        ].join('\\n')\n\n        const maybeSignature = await resolvedWallet.signMessage(\n          new TextEncoder().encode(message),\n          'utf8'\n        )\n\n        if (!maybeSignature || !(maybeSignature instanceof Uint8Array)) {\n          throw new Error(\n            '@supabase/auth-js: Wallet signMessage() API returned an recognized value'\n          )\n        }\n\n        signature = maybeSignature\n      }\n    }\n\n    try {\n      const { data, error } = await _request(\n        this.fetch,\n        'POST',\n        `${this.url}/token?grant_type=web3`,\n        {\n          headers: this.headers,\n          body: {\n            chain: 'solana',\n            message,\n            signature: bytesToBase64URL(signature),\n\n            ...(credentials.options?.captchaToken\n              ? { gotrue_meta_security: { captcha_token: credentials.options?.captchaToken } }\n              : null),\n          },\n          xform: _sessionResponse,\n        }\n      )\n      if (error) {\n        throw error\n      }\n      if (!data || !data.session || !data.user) {\n        return {\n          data: { user: null, session: null },\n          error: new AuthInvalidTokenResponseError(),\n        }\n      }\n      if (data.session) {\n        await this._saveSession(data.session)\n        await this._notifyAllSubscribers('SIGNED_IN', data.session)\n      }\n      return { data: { ...data }, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  private async _exchangeCodeForSession(authCode: string): Promise<\n    | {\n        data: { session: Session; user: User; redirectType: string | null }\n        error: null\n      }\n    | { data: { session: null; user: null; redirectType: null }; error: AuthError }\n  > {\n    const storageItem = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`)\n    const [codeVerifier, redirectType] = ((storageItem ?? '') as string).split('/')\n\n    try {\n      const { data, error } = await _request(\n        this.fetch,\n        'POST',\n        `${this.url}/token?grant_type=pkce`,\n        {\n          headers: this.headers,\n          body: {\n            auth_code: authCode,\n            code_verifier: codeVerifier,\n          },\n          xform: _sessionResponse,\n        }\n      )\n      await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`)\n      if (error) {\n        throw error\n      }\n      if (!data || !data.session || !data.user) {\n        return {\n          data: { user: null, session: null, redirectType: null },\n          error: new AuthInvalidTokenResponseError(),\n        }\n      }\n      if (data.session) {\n        await this._saveSession(data.session)\n        await this._notifyAllSubscribers('SIGNED_IN', data.session)\n      }\n      return { data: { ...data, redirectType: redirectType ?? null }, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null, redirectType: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Allows signing in with an OIDC ID token. The authentication provider used\n   * should be enabled and configured.\n   */\n  async signInWithIdToken(credentials: SignInWithIdTokenCredentials): Promise<AuthTokenResponse> {\n    try {\n      const { options, provider, token, access_token, nonce } = credentials\n\n      const res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=id_token`, {\n        headers: this.headers,\n        body: {\n          provider,\n          id_token: token,\n          access_token,\n          nonce,\n          gotrue_meta_security: { captcha_token: options?.captchaToken },\n        },\n        xform: _sessionResponse,\n      })\n\n      const { data, error } = res\n      if (error) {\n        return { data: { user: null, session: null }, error }\n      } else if (!data || !data.session || !data.user) {\n        return {\n          data: { user: null, session: null },\n          error: new AuthInvalidTokenResponseError(),\n        }\n      }\n      if (data.session) {\n        await this._saveSession(data.session)\n        await this._notifyAllSubscribers('SIGNED_IN', data.session)\n      }\n      return { data, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Log in a user using magiclink or a one-time password (OTP).\n   *\n   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n   *\n   * Be aware that you may get back an error message that will not distinguish\n   * between the cases where the account does not exist or, that the account\n   * can only be accessed via social login.\n   *\n   * Do note that you will need to configure a Whatsapp sender on Twilio\n   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\n   * channel is not supported on other providers\n   * at this time.\n   * This method supports PKCE when an email is passed.\n   */\n  async signInWithOtp(credentials: SignInWithPasswordlessCredentials): Promise<AuthOtpResponse> {\n    try {\n      if ('email' in credentials) {\n        const { email, options } = credentials\n        let codeChallenge: string | null = null\n        let codeChallengeMethod: string | null = null\n        if (this.flowType === 'pkce') {\n          ;[codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(\n            this.storage,\n            this.storageKey\n          )\n        }\n        const { error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\n          headers: this.headers,\n          body: {\n            email,\n            data: options?.data ?? {},\n            create_user: options?.shouldCreateUser ?? true,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n            code_challenge: codeChallenge,\n            code_challenge_method: codeChallengeMethod,\n          },\n          redirectTo: options?.emailRedirectTo,\n        })\n        return { data: { user: null, session: null }, error }\n      }\n      if ('phone' in credentials) {\n        const { phone, options } = credentials\n        const { data, error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\n          headers: this.headers,\n          body: {\n            phone,\n            data: options?.data ?? {},\n            create_user: options?.shouldCreateUser ?? true,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n            channel: options?.channel ?? 'sms',\n          },\n        })\n        return { data: { user: null, session: null, messageId: data?.message_id }, error }\n      }\n      throw new AuthInvalidCredentialsError('You must provide either an email or phone number.')\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Log in a user given a User supplied OTP or TokenHash received through mobile or email.\n   */\n  async verifyOtp(params: VerifyOtpParams): Promise<AuthResponse> {\n    try {\n      let redirectTo: string | undefined = undefined\n      let captchaToken: string | undefined = undefined\n      if ('options' in params) {\n        redirectTo = params.options?.redirectTo\n        captchaToken = params.options?.captchaToken\n      }\n      const { data, error } = await _request(this.fetch, 'POST', `${this.url}/verify`, {\n        headers: this.headers,\n        body: {\n          ...params,\n          gotrue_meta_security: { captcha_token: captchaToken },\n        },\n        redirectTo,\n        xform: _sessionResponse,\n      })\n\n      if (error) {\n        throw error\n      }\n\n      if (!data) {\n        throw new Error('An error occurred on token verification.')\n      }\n\n      const session: Session | null = data.session\n      const user: User = data.user\n\n      if (session?.access_token) {\n        await this._saveSession(session as Session)\n        await this._notifyAllSubscribers(\n          params.type == 'recovery' ? 'PASSWORD_RECOVERY' : 'SIGNED_IN',\n          session\n        )\n      }\n\n      return { data: { user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Attempts a single-sign on using an enterprise Identity Provider. A\n   * successful SSO attempt will redirect the current page to the identity\n   * provider authorization page. The redirect URL is implementation and SSO\n   * protocol specific.\n   *\n   * You can use it by providing a SSO domain. Typically you can extract this\n   * domain by asking users for their email address. If this domain is\n   * registered on the Auth instance the redirect will use that organization's\n   * currently active SSO Identity Provider for the login.\n   *\n   * If you have built an organization-specific login page, you can use the\n   * organization's SSO Identity Provider UUID directly instead.\n   */\n  async signInWithSSO(params: SignInWithSSO): Promise<SSOResponse> {\n    try {\n      let codeChallenge: string | null = null\n      let codeChallengeMethod: string | null = null\n      if (this.flowType === 'pkce') {\n        ;[codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(\n          this.storage,\n          this.storageKey\n        )\n      }\n\n      return await _request(this.fetch, 'POST', `${this.url}/sso`, {\n        body: {\n          ...('providerId' in params ? { provider_id: params.providerId } : null),\n          ...('domain' in params ? { domain: params.domain } : null),\n          redirect_to: params.options?.redirectTo ?? undefined,\n          ...(params?.options?.captchaToken\n            ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } }\n            : null),\n          skip_http_redirect: true, // fetch does not handle redirects\n          code_challenge: codeChallenge,\n          code_challenge_method: codeChallengeMethod,\n        },\n        headers: this.headers,\n        xform: _ssoResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Sends a reauthentication OTP to the user's email or phone number.\n   * Requires the user to be signed-in.\n   */\n  async reauthenticate(): Promise<AuthResponse> {\n    await this.initializePromise\n\n    return await this._acquireLock(-1, async () => {\n      return await this._reauthenticate()\n    })\n  }\n\n  private async _reauthenticate(): Promise<AuthResponse> {\n    try {\n      return await this._useSession(async (result) => {\n        const {\n          data: { session },\n          error: sessionError,\n        } = result\n        if (sessionError) throw sessionError\n        if (!session) throw new AuthSessionMissingError()\n\n        const { error } = await _request(this.fetch, 'GET', `${this.url}/reauthenticate`, {\n          headers: this.headers,\n          jwt: session.access_token,\n        })\n        return { data: { user: null, session: null }, error }\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.\n   */\n  async resend(credentials: ResendParams): Promise<AuthOtpResponse> {\n    try {\n      const endpoint = `${this.url}/resend`\n      if ('email' in credentials) {\n        const { email, type, options } = credentials\n        const { error } = await _request(this.fetch, 'POST', endpoint, {\n          headers: this.headers,\n          body: {\n            email,\n            type,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          redirectTo: options?.emailRedirectTo,\n        })\n        return { data: { user: null, session: null }, error }\n      } else if ('phone' in credentials) {\n        const { phone, type, options } = credentials\n        const { data, error } = await _request(this.fetch, 'POST', endpoint, {\n          headers: this.headers,\n          body: {\n            phone,\n            type,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n        })\n        return { data: { user: null, session: null, messageId: data?.message_id }, error }\n      }\n      throw new AuthInvalidCredentialsError(\n        'You must provide either an email or phone number and a type'\n      )\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Returns the session, refreshing it if necessary.\n   *\n   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n   *\n   * **IMPORTANT:** This method loads values directly from the storage attached\n   * to the client. If that storage is based on request cookies for example,\n   * the values in it may not be authentic and therefore it's strongly advised\n   * against using this method and its results in such circumstances. A warning\n   * will be emitted if this is detected. Use {@link #getUser()} instead.\n   */\n  async getSession() {\n    await this.initializePromise\n\n    const result = await this._acquireLock(-1, async () => {\n      return this._useSession(async (result) => {\n        return result\n      })\n    })\n\n    return result\n  }\n\n  /**\n   * Acquires a global lock based on the storage key.\n   */\n  private async _acquireLock<R>(acquireTimeout: number, fn: () => Promise<R>): Promise<R> {\n    this._debug('#_acquireLock', 'begin', acquireTimeout)\n\n    try {\n      if (this.lockAcquired) {\n        const last = this.pendingInLock.length\n          ? this.pendingInLock[this.pendingInLock.length - 1]\n          : Promise.resolve()\n\n        const result = (async () => {\n          await last\n          return await fn()\n        })()\n\n        this.pendingInLock.push(\n          (async () => {\n            try {\n              await result\n            } catch (e: any) {\n              // we just care if it finished\n            }\n          })()\n        )\n\n        return result\n      }\n\n      return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async () => {\n        this._debug('#_acquireLock', 'lock acquired for storage key', this.storageKey)\n\n        try {\n          this.lockAcquired = true\n\n          const result = fn()\n\n          this.pendingInLock.push(\n            (async () => {\n              try {\n                await result\n              } catch (e: any) {\n                // we just care if it finished\n              }\n            })()\n          )\n\n          await result\n\n          // keep draining the queue until there's nothing to wait on\n          while (this.pendingInLock.length) {\n            const waitOn = [...this.pendingInLock]\n\n            await Promise.all(waitOn)\n\n            this.pendingInLock.splice(0, waitOn.length)\n          }\n\n          return await result\n        } finally {\n          this._debug('#_acquireLock', 'lock released for storage key', this.storageKey)\n\n          this.lockAcquired = false\n        }\n      })\n    } finally {\n      this._debug('#_acquireLock', 'end')\n    }\n  }\n\n  /**\n   * Use instead of {@link #getSession} inside the library. It is\n   * semantically usually what you want, as getting a session involves some\n   * processing afterwards that requires only one client operating on the\n   * session at once across multiple tabs or processes.\n   */\n  private async _useSession<R>(\n    fn: (\n      result:\n        | {\n            data: {\n              session: Session\n            }\n            error: null\n          }\n        | {\n            data: {\n              session: null\n            }\n            error: AuthError\n          }\n        | {\n            data: {\n              session: null\n            }\n            error: null\n          }\n    ) => Promise<R>\n  ): Promise<R> {\n    this._debug('#_useSession', 'begin')\n\n    try {\n      // the use of __loadSession here is the only correct use of the function!\n      const result = await this.__loadSession()\n\n      return await fn(result)\n    } finally {\n      this._debug('#_useSession', 'end')\n    }\n  }\n\n  /**\n   * NEVER USE DIRECTLY!\n   *\n   * Always use {@link #_useSession}.\n   */\n  private async __loadSession(): Promise<\n    | {\n        data: {\n          session: Session\n        }\n        error: null\n      }\n    | {\n        data: {\n          session: null\n        }\n        error: AuthError\n      }\n    | {\n        data: {\n          session: null\n        }\n        error: null\n      }\n  > {\n    this._debug('#__loadSession()', 'begin')\n\n    if (!this.lockAcquired) {\n      this._debug('#__loadSession()', 'used outside of an acquired lock!', new Error().stack)\n    }\n\n    try {\n      let currentSession: Session | null = null\n\n      const maybeSession = await getItemAsync(this.storage, this.storageKey)\n\n      this._debug('#getSession()', 'session from storage', maybeSession)\n\n      if (maybeSession !== null) {\n        if (this._isValidSession(maybeSession)) {\n          currentSession = maybeSession\n        } else {\n          this._debug('#getSession()', 'session from storage is not valid')\n          await this._removeSession()\n        }\n      }\n\n      if (!currentSession) {\n        return { data: { session: null }, error: null }\n      }\n\n      // A session is considered expired before the access token _actually_\n      // expires. When the autoRefreshToken option is off (or when the tab is\n      // in the background), very eager users of getSession() -- like\n      // realtime-js -- might send a valid JWT which will expire by the time it\n      // reaches the server.\n      const hasExpired = currentSession.expires_at\n        ? currentSession.expires_at * 1000 - Date.now() < EXPIRY_MARGIN_MS\n        : false\n\n      this._debug(\n        '#__loadSession()',\n        `session has${hasExpired ? '' : ' not'} expired`,\n        'expires_at',\n        currentSession.expires_at\n      )\n\n      if (!hasExpired) {\n        if (this.storage.isServer) {\n          let suppressWarning = this.suppressGetSessionWarning\n          const proxySession: Session = new Proxy(currentSession, {\n            get: (target: any, prop: string, receiver: any) => {\n              if (!suppressWarning && prop === 'user') {\n                // only show warning when the user object is being accessed from the server\n                console.warn(\n                  'Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.'\n                )\n                suppressWarning = true // keeps this proxy instance from logging additional warnings\n                this.suppressGetSessionWarning = true // keeps this client's future proxy instances from warning\n              }\n              return Reflect.get(target, prop, receiver)\n            },\n          })\n          currentSession = proxySession\n        }\n\n        return { data: { session: currentSession }, error: null }\n      }\n\n      const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\n      if (error) {\n        return { data: { session: null }, error }\n      }\n\n      return { data: { session }, error: null }\n    } finally {\n      this._debug('#__loadSession()', 'end')\n    }\n  }\n\n  /**\n   * Gets the current user details if there is an existing session. This method\n   * performs a network request to the Supabase Auth server, so the returned\n   * value is authentic and can be used to base authorization rules on.\n   *\n   * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.\n   */\n  async getUser(jwt?: string): Promise<UserResponse> {\n    if (jwt) {\n      return await this._getUser(jwt)\n    }\n\n    await this.initializePromise\n\n    const result = await this._acquireLock(-1, async () => {\n      return await this._getUser()\n    })\n\n    return result\n  }\n\n  private async _getUser(jwt?: string): Promise<UserResponse> {\n    try {\n      if (jwt) {\n        return await _request(this.fetch, 'GET', `${this.url}/user`, {\n          headers: this.headers,\n          jwt: jwt,\n          xform: _userResponse,\n        })\n      }\n\n      return await this._useSession(async (result) => {\n        const { data, error } = result\n        if (error) {\n          throw error\n        }\n\n        // returns an error if there is no access_token or custom authorization header\n        if (!data.session?.access_token && !this.hasCustomAuthorizationHeader) {\n          return { data: { user: null }, error: new AuthSessionMissingError() }\n        }\n\n        return await _request(this.fetch, 'GET', `${this.url}/user`, {\n          headers: this.headers,\n          jwt: data.session?.access_token ?? undefined,\n          xform: _userResponse,\n        })\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        if (isAuthSessionMissingError(error)) {\n          // JWT contains a `session_id` which does not correspond to an active\n          // session in the database, indicating the user is signed out.\n\n          await this._removeSession()\n          await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`)\n        }\n\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Updates user data for a logged in user.\n   */\n  async updateUser(\n    attributes: UserAttributes,\n    options: {\n      emailRedirectTo?: string | undefined\n    } = {}\n  ): Promise<UserResponse> {\n    await this.initializePromise\n\n    return await this._acquireLock(-1, async () => {\n      return await this._updateUser(attributes, options)\n    })\n  }\n\n  protected async _updateUser(\n    attributes: UserAttributes,\n    options: {\n      emailRedirectTo?: string | undefined\n    } = {}\n  ): Promise<UserResponse> {\n    try {\n      return await this._useSession(async (result) => {\n        const { data: sessionData, error: sessionError } = result\n        if (sessionError) {\n          throw sessionError\n        }\n        if (!sessionData.session) {\n          throw new AuthSessionMissingError()\n        }\n        const session: Session = sessionData.session\n        let codeChallenge: string | null = null\n        let codeChallengeMethod: string | null = null\n        if (this.flowType === 'pkce' && attributes.email != null) {\n          ;[codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(\n            this.storage,\n            this.storageKey\n          )\n        }\n\n        const { data, error: userError } = await _request(this.fetch, 'PUT', `${this.url}/user`, {\n          headers: this.headers,\n          redirectTo: options?.emailRedirectTo,\n          body: {\n            ...attributes,\n            code_challenge: codeChallenge,\n            code_challenge_method: codeChallengeMethod,\n          },\n          jwt: session.access_token,\n          xform: _userResponse,\n        })\n        if (userError) throw userError\n        session.user = data.user as User\n        await this._saveSession(session)\n        await this._notifyAllSubscribers('USER_UPDATED', session)\n        return { data: { user: session.user }, error: null }\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n   * If the refresh token or access token in the current session is invalid, an error will be thrown.\n   * @param currentSession The current session that minimally contains an access token and refresh token.\n   */\n  async setSession(currentSession: {\n    access_token: string\n    refresh_token: string\n  }): Promise<AuthResponse> {\n    await this.initializePromise\n\n    return await this._acquireLock(-1, async () => {\n      return await this._setSession(currentSession)\n    })\n  }\n\n  protected async _setSession(currentSession: {\n    access_token: string\n    refresh_token: string\n  }): Promise<AuthResponse> {\n    try {\n      if (!currentSession.access_token || !currentSession.refresh_token) {\n        throw new AuthSessionMissingError()\n      }\n\n      const timeNow = Date.now() / 1000\n      let expiresAt = timeNow\n      let hasExpired = true\n      let session: Session | null = null\n      const { payload } = decodeJWT(currentSession.access_token)\n      if (payload.exp) {\n        expiresAt = payload.exp\n        hasExpired = expiresAt <= timeNow\n      }\n\n      if (hasExpired) {\n        const { session: refreshedSession, error } = await this._callRefreshToken(\n          currentSession.refresh_token\n        )\n        if (error) {\n          return { data: { user: null, session: null }, error: error }\n        }\n\n        if (!refreshedSession) {\n          return { data: { user: null, session: null }, error: null }\n        }\n        session = refreshedSession\n      } else {\n        const { data, error } = await this._getUser(currentSession.access_token)\n        if (error) {\n          throw error\n        }\n        session = {\n          access_token: currentSession.access_token,\n          refresh_token: currentSession.refresh_token,\n          user: data.user,\n          token_type: 'bearer',\n          expires_in: expiresAt - timeNow,\n          expires_at: expiresAt,\n        }\n        await this._saveSession(session)\n        await this._notifyAllSubscribers('SIGNED_IN', session)\n      }\n\n      return { data: { user: session.user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Returns a new session, regardless of expiry status.\n   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n   * If the current session's refresh token is invalid, an error will be thrown.\n   * @param currentSession The current session. If passed in, it must contain a refresh token.\n   */\n  async refreshSession(currentSession?: { refresh_token: string }): Promise<AuthResponse> {\n    await this.initializePromise\n\n    return await this._acquireLock(-1, async () => {\n      return await this._refreshSession(currentSession)\n    })\n  }\n\n  protected async _refreshSession(currentSession?: {\n    refresh_token: string\n  }): Promise<AuthResponse> {\n    try {\n      return await this._useSession(async (result) => {\n        if (!currentSession) {\n          const { data, error } = result\n          if (error) {\n            throw error\n          }\n\n          currentSession = data.session ?? undefined\n        }\n\n        if (!currentSession?.refresh_token) {\n          throw new AuthSessionMissingError()\n        }\n\n        const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\n        if (error) {\n          return { data: { user: null, session: null }, error: error }\n        }\n\n        if (!session) {\n          return { data: { user: null, session: null }, error: null }\n        }\n\n        return { data: { user: session.user, session }, error: null }\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Gets the session data from a URL string\n   */\n  private async _getSessionFromURL(\n    params: { [parameter: string]: string },\n    callbackUrlType: string\n  ): Promise<\n    | {\n        data: { session: Session; redirectType: string | null }\n        error: null\n      }\n    | { data: { session: null; redirectType: null }; error: AuthError }\n  > {\n    try {\n      if (!isBrowser()) throw new AuthImplicitGrantRedirectError('No browser detected.')\n\n      // If there's an error in the URL, it doesn't matter what flow it is, we just return the error.\n      if (params.error || params.error_description || params.error_code) {\n        // The error class returned implies that the redirect is from an implicit grant flow\n        // but it could also be from a redirect error from a PKCE flow.\n        throw new AuthImplicitGrantRedirectError(\n          params.error_description || 'Error in URL with unspecified error_description',\n          {\n            error: params.error || 'unspecified_error',\n            code: params.error_code || 'unspecified_code',\n          }\n        )\n      }\n\n      // Checks for mismatches between the flowType initialised in the client and the URL parameters\n      switch (callbackUrlType) {\n        case 'implicit':\n          if (this.flowType === 'pkce') {\n            throw new AuthPKCEGrantCodeExchangeError('Not a valid PKCE flow url.')\n          }\n          break\n        case 'pkce':\n          if (this.flowType === 'implicit') {\n            throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.')\n          }\n          break\n        default:\n        // there's no mismatch so we continue\n      }\n\n      // Since this is a redirect for PKCE, we attempt to retrieve the code from the URL for the code exchange\n      if (callbackUrlType === 'pkce') {\n        this._debug('#_initialize()', 'begin', 'is PKCE flow', true)\n        if (!params.code) throw new AuthPKCEGrantCodeExchangeError('No code detected.')\n        const { data, error } = await this._exchangeCodeForSession(params.code)\n        if (error) throw error\n\n        const url = new URL(window.location.href)\n        url.searchParams.delete('code')\n\n        window.history.replaceState(window.history.state, '', url.toString())\n\n        return { data: { session: data.session, redirectType: null }, error: null }\n      }\n\n      const {\n        provider_token,\n        provider_refresh_token,\n        access_token,\n        refresh_token,\n        expires_in,\n        expires_at,\n        token_type,\n      } = params\n\n      if (!access_token || !expires_in || !refresh_token || !token_type) {\n        throw new AuthImplicitGrantRedirectError('No session defined in URL')\n      }\n\n      const timeNow = Math.round(Date.now() / 1000)\n      const expiresIn = parseInt(expires_in)\n      let expiresAt = timeNow + expiresIn\n\n      if (expires_at) {\n        expiresAt = parseInt(expires_at)\n      }\n\n      const actuallyExpiresIn = expiresAt - timeNow\n      if (actuallyExpiresIn * 1000 <= AUTO_REFRESH_TICK_DURATION_MS) {\n        console.warn(\n          `@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`\n        )\n      }\n\n      const issuedAt = expiresAt - expiresIn\n      if (timeNow - issuedAt >= 120) {\n        console.warn(\n          '@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale',\n          issuedAt,\n          expiresAt,\n          timeNow\n        )\n      } else if (timeNow - issuedAt < 0) {\n        console.warn(\n          '@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew',\n          issuedAt,\n          expiresAt,\n          timeNow\n        )\n      }\n\n      const { data, error } = await this._getUser(access_token)\n      if (error) throw error\n\n      const session: Session = {\n        provider_token,\n        provider_refresh_token,\n        access_token,\n        expires_in: expiresIn,\n        expires_at: expiresAt,\n        refresh_token,\n        token_type,\n        user: data.user,\n      }\n\n      // Remove tokens from URL\n      window.location.hash = ''\n      this._debug('#_getSessionFromURL()', 'clearing window.location.hash')\n\n      return { data: { session, redirectType: params.type }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, redirectType: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n   */\n  private _isImplicitGrantCallback(params: { [parameter: string]: string }): boolean {\n    return Boolean(params.access_token || params.error_description)\n  }\n\n  /**\n   * Checks if the current URL and backing storage contain parameters given by a PKCE flow\n   */\n  private async _isPKCECallback(params: { [parameter: string]: string }): Promise<boolean> {\n    const currentStorageContent = await getItemAsync(\n      this.storage,\n      `${this.storageKey}-code-verifier`\n    )\n\n    return !!(params.code && currentStorageContent)\n  }\n\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n   *\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n   *\n   * If using `others` scope, no `SIGNED_OUT` event is fired!\n   */\n  async signOut(options: SignOut = { scope: 'global' }): Promise<{ error: AuthError | null }> {\n    await this.initializePromise\n\n    return await this._acquireLock(-1, async () => {\n      return await this._signOut(options)\n    })\n  }\n\n  protected async _signOut(\n    { scope }: SignOut = { scope: 'global' }\n  ): Promise<{ error: AuthError | null }> {\n    return await this._useSession(async (result) => {\n      const { data, error: sessionError } = result\n      if (sessionError) {\n        return { error: sessionError }\n      }\n      const accessToken = data.session?.access_token\n      if (accessToken) {\n        const { error } = await this.admin.signOut(accessToken, scope)\n        if (error) {\n          // ignore 404s since user might not exist anymore\n          // ignore 401s since an invalid or expired JWT should sign out the current session\n          if (\n            !(\n              isAuthApiError(error) &&\n              (error.status === 404 || error.status === 401 || error.status === 403)\n            )\n          ) {\n            return { error }\n          }\n        }\n      }\n      if (scope !== 'others') {\n        await this._removeSession()\n        await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`)\n      }\n      return { error: null }\n    })\n  }\n\n  /**\n   * Receive a notification every time an auth event happens.\n   * @param callback A callback function to be invoked when an auth event happens.\n   */\n  onAuthStateChange(\n    callback: (event: AuthChangeEvent, session: Session | null) => void | Promise<void>\n  ): {\n    data: { subscription: Subscription }\n  } {\n    const id: string = uuid()\n    const subscription: Subscription = {\n      id,\n      callback,\n      unsubscribe: () => {\n        this._debug('#unsubscribe()', 'state change callback with id removed', id)\n\n        this.stateChangeEmitters.delete(id)\n      },\n    }\n\n    this._debug('#onAuthStateChange()', 'registered callback with id', id)\n\n    this.stateChangeEmitters.set(id, subscription)\n    ;(async () => {\n      await this.initializePromise\n\n      await this._acquireLock(-1, async () => {\n        this._emitInitialSession(id)\n      })\n    })()\n\n    return { data: { subscription } }\n  }\n\n  private async _emitInitialSession(id: string): Promise<void> {\n    return await this._useSession(async (result) => {\n      try {\n        const {\n          data: { session },\n          error,\n        } = result\n        if (error) throw error\n\n        await this.stateChangeEmitters.get(id)?.callback('INITIAL_SESSION', session)\n        this._debug('INITIAL_SESSION', 'callback id', id, 'session', session)\n      } catch (err) {\n        await this.stateChangeEmitters.get(id)?.callback('INITIAL_SESSION', null)\n        this._debug('INITIAL_SESSION', 'callback id', id, 'error', err)\n        console.error(err)\n      }\n    })\n  }\n\n  /**\n   * Sends a password reset request to an email address. This method supports the PKCE flow.\n   *\n   * @param email The email address of the user.\n   * @param options.redirectTo The URL to send the user to after they click the password reset link.\n   * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n   */\n  async resetPasswordForEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ): Promise<\n    | {\n        data: {}\n        error: null\n      }\n    | { data: null; error: AuthError }\n  > {\n    let codeChallenge: string | null = null\n    let codeChallengeMethod: string | null = null\n\n    if (this.flowType === 'pkce') {\n      ;[codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(\n        this.storage,\n        this.storageKey,\n        true // isPasswordRecovery\n      )\n    }\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/recover`, {\n        body: {\n          email,\n          code_challenge: codeChallenge,\n          code_challenge_method: codeChallengeMethod,\n          gotrue_meta_security: { captcha_token: options.captchaToken },\n        },\n        headers: this.headers,\n        redirectTo: options.redirectTo,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Gets all the identities linked to a user.\n   */\n  async getUserIdentities(): Promise<\n    | {\n        data: {\n          identities: UserIdentity[]\n        }\n        error: null\n      }\n    | { data: null; error: AuthError }\n  > {\n    try {\n      const { data, error } = await this.getUser()\n      if (error) throw error\n      return { data: { identities: data.user.identities ?? [] }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n  /**\n   * Links an oauth identity to an existing user.\n   * This method supports the PKCE flow.\n   */\n  async linkIdentity(credentials: SignInWithOAuthCredentials): Promise<OAuthResponse> {\n    try {\n      const { data, error } = await this._useSession(async (result) => {\n        const { data, error } = result\n        if (error) throw error\n        const url: string = await this._getUrlForProvider(\n          `${this.url}/user/identities/authorize`,\n          credentials.provider,\n          {\n            redirectTo: credentials.options?.redirectTo,\n            scopes: credentials.options?.scopes,\n            queryParams: credentials.options?.queryParams,\n            skipBrowserRedirect: true,\n          }\n        )\n        return await _request(this.fetch, 'GET', url, {\n          headers: this.headers,\n          jwt: data.session?.access_token ?? undefined,\n        })\n      })\n      if (error) throw error\n      if (isBrowser() && !credentials.options?.skipBrowserRedirect) {\n        window.location.assign(data?.url)\n      }\n      return { data: { provider: credentials.provider, url: data?.url }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { provider: credentials.provider, url: null }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.\n   */\n  async unlinkIdentity(identity: UserIdentity): Promise<\n    | {\n        data: {}\n        error: null\n      }\n    | { data: null; error: AuthError }\n  > {\n    try {\n      return await this._useSession(async (result) => {\n        const { data, error } = result\n        if (error) {\n          throw error\n        }\n        return await _request(\n          this.fetch,\n          'DELETE',\n          `${this.url}/user/identities/${identity.identity_id}`,\n          {\n            headers: this.headers,\n            jwt: data.session?.access_token ?? undefined,\n          }\n        )\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n  private async _refreshAccessToken(refreshToken: string): Promise<AuthResponse> {\n    const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`\n    this._debug(debugName, 'begin')\n\n    try {\n      const startedAt = Date.now()\n\n      // will attempt to refresh the token with exponential backoff\n      return await retryable(\n        async (attempt) => {\n          if (attempt > 0) {\n            await sleep(200 * Math.pow(2, attempt - 1)) // 200, 400, 800, ...\n          }\n\n          this._debug(debugName, 'refreshing attempt', attempt)\n\n          return await _request(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\n            body: { refresh_token: refreshToken },\n            headers: this.headers,\n            xform: _sessionResponse,\n          })\n        },\n        (attempt, error) => {\n          const nextBackOffInterval = 200 * Math.pow(2, attempt)\n          return (\n            error &&\n            isAuthRetryableFetchError(error) &&\n            // retryable only if the request can be sent before the backoff overflows the tick duration\n            Date.now() + nextBackOffInterval - startedAt < AUTO_REFRESH_TICK_DURATION_MS\n          )\n        }\n      )\n    } catch (error) {\n      this._debug(debugName, 'error', error)\n\n      if (isAuthError(error)) {\n        return { data: { session: null, user: null }, error }\n      }\n      throw error\n    } finally {\n      this._debug(debugName, 'end')\n    }\n  }\n\n  private _isValidSession(maybeSession: unknown): maybeSession is Session {\n    const isValidSession =\n      typeof maybeSession === 'object' &&\n      maybeSession !== null &&\n      'access_token' in maybeSession &&\n      'refresh_token' in maybeSession &&\n      'expires_at' in maybeSession\n\n    return isValidSession\n  }\n\n  private async _handleProviderSignIn(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n      skipBrowserRedirect?: boolean\n    }\n  ) {\n    const url: string = await this._getUrlForProvider(`${this.url}/authorize`, provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes,\n      queryParams: options.queryParams,\n    })\n\n    this._debug('#_handleProviderSignIn()', 'provider', provider, 'options', options, 'url', url)\n\n    // try to open on the browser\n    if (isBrowser() && !options.skipBrowserRedirect) {\n      window.location.assign(url)\n    }\n\n    return { data: { provider, url }, error: null }\n  }\n\n  /**\n   * Recovers the session from LocalStorage and refreshes the token\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n  private async _recoverAndRefresh() {\n    const debugName = '#_recoverAndRefresh()'\n    this._debug(debugName, 'begin')\n\n    try {\n      const currentSession = await getItemAsync(this.storage, this.storageKey)\n      this._debug(debugName, 'session from storage', currentSession)\n\n      if (!this._isValidSession(currentSession)) {\n        this._debug(debugName, 'session is not valid')\n        if (currentSession !== null) {\n          await this._removeSession()\n        }\n\n        return\n      }\n\n      const expiresWithMargin =\n        (currentSession.expires_at ?? Infinity) * 1000 - Date.now() < EXPIRY_MARGIN_MS\n\n      this._debug(\n        debugName,\n        `session has${expiresWithMargin ? '' : ' not'} expired with margin of ${EXPIRY_MARGIN_MS}s`\n      )\n\n      if (expiresWithMargin) {\n        if (this.autoRefreshToken && currentSession.refresh_token) {\n          const { error } = await this._callRefreshToken(currentSession.refresh_token)\n\n          if (error) {\n            console.error(error)\n\n            if (!isAuthRetryableFetchError(error)) {\n              this._debug(\n                debugName,\n                'refresh failed with a non-retryable error, removing the session',\n                error\n              )\n              await this._removeSession()\n            }\n          }\n        }\n      } else {\n        // no need to persist currentSession again, as we just loaded it from\n        // local storage; persisting it again may overwrite a value saved by\n        // another client with access to the same local storage\n        await this._notifyAllSubscribers('SIGNED_IN', currentSession)\n      }\n    } catch (err) {\n      this._debug(debugName, 'error', err)\n\n      console.error(err)\n      return\n    } finally {\n      this._debug(debugName, 'end')\n    }\n  }\n\n  private async _callRefreshToken(refreshToken: string): Promise<CallRefreshTokenResult> {\n    if (!refreshToken) {\n      throw new AuthSessionMissingError()\n    }\n\n    // refreshing is already in progress\n    if (this.refreshingDeferred) {\n      return this.refreshingDeferred.promise\n    }\n\n    const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`\n\n    this._debug(debugName, 'begin')\n\n    try {\n      this.refreshingDeferred = new Deferred<CallRefreshTokenResult>()\n\n      const { data, error } = await this._refreshAccessToken(refreshToken)\n      if (error) throw error\n      if (!data.session) throw new AuthSessionMissingError()\n\n      await this._saveSession(data.session)\n      await this._notifyAllSubscribers('TOKEN_REFRESHED', data.session)\n\n      const result = { session: data.session, error: null }\n\n      this.refreshingDeferred.resolve(result)\n\n      return result\n    } catch (error) {\n      this._debug(debugName, 'error', error)\n\n      if (isAuthError(error)) {\n        const result = { session: null, error }\n\n        if (!isAuthRetryableFetchError(error)) {\n          await this._removeSession()\n        }\n\n        this.refreshingDeferred?.resolve(result)\n\n        return result\n      }\n\n      this.refreshingDeferred?.reject(error)\n      throw error\n    } finally {\n      this.refreshingDeferred = null\n      this._debug(debugName, 'end')\n    }\n  }\n\n  private async _notifyAllSubscribers(\n    event: AuthChangeEvent,\n    session: Session | null,\n    broadcast = true\n  ) {\n    const debugName = `#_notifyAllSubscribers(${event})`\n    this._debug(debugName, 'begin', session, `broadcast = ${broadcast}`)\n\n    try {\n      if (this.broadcastChannel && broadcast) {\n        this.broadcastChannel.postMessage({ event, session })\n      }\n\n      const errors: any[] = []\n      const promises = Array.from(this.stateChangeEmitters.values()).map(async (x) => {\n        try {\n          await x.callback(event, session)\n        } catch (e: any) {\n          errors.push(e)\n        }\n      })\n\n      await Promise.all(promises)\n\n      if (errors.length > 0) {\n        for (let i = 0; i < errors.length; i += 1) {\n          console.error(errors[i])\n        }\n\n        throw errors[0]\n      }\n    } finally {\n      this._debug(debugName, 'end')\n    }\n  }\n\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n  private async _saveSession(session: Session) {\n    this._debug('#_saveSession()', session)\n    // _saveSession is always called whenever a new session has been acquired\n    // so we can safely suppress the warning returned by future getSession calls\n    this.suppressGetSessionWarning = true\n    await setItemAsync(this.storage, this.storageKey, session)\n  }\n\n  private async _removeSession() {\n    this._debug('#_removeSession()')\n\n    await removeItemAsync(this.storage, this.storageKey)\n    await this._notifyAllSubscribers('SIGNED_OUT', null)\n  }\n\n  /**\n   * Removes any registered visibilitychange callback.\n   *\n   * {@see #startAutoRefresh}\n   * {@see #stopAutoRefresh}\n   */\n  private _removeVisibilityChangedCallback() {\n    this._debug('#_removeVisibilityChangedCallback()')\n\n    const callback = this.visibilityChangedCallback\n    this.visibilityChangedCallback = null\n\n    try {\n      if (callback && isBrowser() && window?.removeEventListener) {\n        window.removeEventListener('visibilitychange', callback)\n      }\n    } catch (e) {\n      console.error('removing visibilitychange callback failed', e)\n    }\n  }\n\n  /**\n   * This is the private implementation of {@link #startAutoRefresh}. Use this\n   * within the library.\n   */\n  private async _startAutoRefresh() {\n    await this._stopAutoRefresh()\n\n    this._debug('#_startAutoRefresh()')\n\n    const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION_MS)\n    this.autoRefreshTicker = ticker\n\n    if (ticker && typeof ticker === 'object' && typeof ticker.unref === 'function') {\n      // ticker is a NodeJS Timeout object that has an `unref` method\n      // https://nodejs.org/api/timers.html#timeoutunref\n      // When auto refresh is used in NodeJS (like for testing) the\n      // `setInterval` is preventing the process from being marked as\n      // finished and tests run endlessly. This can be prevented by calling\n      // `unref()` on the returned object.\n      ticker.unref()\n      // @ts-expect-error TS has no context of Deno\n    } else if (typeof Deno !== 'undefined' && typeof Deno.unrefTimer === 'function') {\n      // similar like for NodeJS, but with the Deno API\n      // https://deno.land/api@latest?unstable&s=Deno.unrefTimer\n      // @ts-expect-error TS has no context of Deno\n      Deno.unrefTimer(ticker)\n    }\n\n    // run the tick immediately, but in the next pass of the event loop so that\n    // #_initialize can be allowed to complete without recursively waiting on\n    // itself\n    setTimeout(async () => {\n      await this.initializePromise\n      await this._autoRefreshTokenTick()\n    }, 0)\n  }\n\n  /**\n   * This is the private implementation of {@link #stopAutoRefresh}. Use this\n   * within the library.\n   */\n  private async _stopAutoRefresh() {\n    this._debug('#_stopAutoRefresh()')\n\n    const ticker = this.autoRefreshTicker\n    this.autoRefreshTicker = null\n\n    if (ticker) {\n      clearInterval(ticker)\n    }\n  }\n\n  /**\n   * Starts an auto-refresh process in the background. The session is checked\n   * every few seconds. Close to the time of expiration a process is started to\n   * refresh the session. If refreshing fails it will be retried for as long as\n   * necessary.\n   *\n   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\n   * to call this function, it will be called for you.\n   *\n   * On browsers the refresh process works only when the tab/window is in the\n   * foreground to conserve resources as well as prevent race conditions and\n   * flooding auth with requests. If you call this method any managed\n   * visibility change callback will be removed and you must manage visibility\n   * changes on your own.\n   *\n   * On non-browser platforms the refresh process works *continuously* in the\n   * background, which may not be desirable. You should hook into your\n   * platform's foreground indication mechanism and call these methods\n   * appropriately to conserve resources.\n   *\n   * {@see #stopAutoRefresh}\n   */\n  async startAutoRefresh() {\n    this._removeVisibilityChangedCallback()\n    await this._startAutoRefresh()\n  }\n\n  /**\n   * Stops an active auto refresh process running in the background (if any).\n   *\n   * If you call this method any managed visibility change callback will be\n   * removed and you must manage visibility changes on your own.\n   *\n   * See {@link #startAutoRefresh} for more details.\n   */\n  async stopAutoRefresh() {\n    this._removeVisibilityChangedCallback()\n    await this._stopAutoRefresh()\n  }\n\n  /**\n   * Runs the auto refresh token tick.\n   */\n  private async _autoRefreshTokenTick() {\n    this._debug('#_autoRefreshTokenTick()', 'begin')\n\n    try {\n      await this._acquireLock(0, async () => {\n        try {\n          const now = Date.now()\n\n          try {\n            return await this._useSession(async (result) => {\n              const {\n                data: { session },\n              } = result\n\n              if (!session || !session.refresh_token || !session.expires_at) {\n                this._debug('#_autoRefreshTokenTick()', 'no session')\n                return\n              }\n\n              // session will expire in this many ticks (or has already expired if <= 0)\n              const expiresInTicks = Math.floor(\n                (session.expires_at * 1000 - now) / AUTO_REFRESH_TICK_DURATION_MS\n              )\n\n              this._debug(\n                '#_autoRefreshTokenTick()',\n                `access token expires in ${expiresInTicks} ticks, a tick lasts ${AUTO_REFRESH_TICK_DURATION_MS}ms, refresh threshold is ${AUTO_REFRESH_TICK_THRESHOLD} ticks`\n              )\n\n              if (expiresInTicks <= AUTO_REFRESH_TICK_THRESHOLD) {\n                await this._callRefreshToken(session.refresh_token)\n              }\n            })\n          } catch (e: any) {\n            console.error(\n              'Auto refresh tick failed with error. This is likely a transient error.',\n              e\n            )\n          }\n        } finally {\n          this._debug('#_autoRefreshTokenTick()', 'end')\n        }\n      })\n    } catch (e: any) {\n      if (e.isAcquireTimeout || e instanceof LockAcquireTimeoutError) {\n        this._debug('auto refresh token tick lock not available')\n      } else {\n        throw e\n      }\n    }\n  }\n\n  /**\n   * Registers callbacks on the browser / platform, which in-turn run\n   * algorithms when the browser window/tab are in foreground. On non-browser\n   * platforms it assumes always foreground.\n   */\n  private async _handleVisibilityChange() {\n    this._debug('#_handleVisibilityChange()')\n\n    if (!isBrowser() || !window?.addEventListener) {\n      if (this.autoRefreshToken) {\n        // in non-browser environments the refresh token ticker runs always\n        this.startAutoRefresh()\n      }\n\n      return false\n    }\n\n    try {\n      this.visibilityChangedCallback = async () => await this._onVisibilityChanged(false)\n\n      window?.addEventListener('visibilitychange', this.visibilityChangedCallback)\n\n      // now immediately call the visbility changed callback to setup with the\n      // current visbility state\n      await this._onVisibilityChanged(true) // initial call\n    } catch (error) {\n      console.error('_handleVisibilityChange', error)\n    }\n  }\n\n  /**\n   * Callback registered with `window.addEventListener('visibilitychange')`.\n   */\n  private async _onVisibilityChanged(calledFromInitialize: boolean) {\n    const methodName = `#_onVisibilityChanged(${calledFromInitialize})`\n    this._debug(methodName, 'visibilityState', document.visibilityState)\n\n    if (document.visibilityState === 'visible') {\n      if (this.autoRefreshToken) {\n        // in browser environments the refresh token ticker runs only on focused tabs\n        // which prevents race conditions\n        this._startAutoRefresh()\n      }\n\n      if (!calledFromInitialize) {\n        // called when the visibility has changed, i.e. the browser\n        // transitioned from hidden -> visible so we need to see if the session\n        // should be recovered immediately... but to do that we need to acquire\n        // the lock first asynchronously\n        await this.initializePromise\n\n        await this._acquireLock(-1, async () => {\n          if (document.visibilityState !== 'visible') {\n            this._debug(\n              methodName,\n              'acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting'\n            )\n\n            // visibility has changed while waiting for the lock, abort\n            return\n          }\n\n          // recover the session\n          await this._recoverAndRefresh()\n        })\n      }\n    } else if (document.visibilityState === 'hidden') {\n      if (this.autoRefreshToken) {\n        this._stopAutoRefresh()\n      }\n    }\n  }\n\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n   */\n  private async _getUrlForProvider(\n    url: string,\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n      skipBrowserRedirect?: boolean\n    }\n  ) {\n    const urlParams: string[] = [`provider=${encodeURIComponent(provider)}`]\n    if (options?.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`)\n    }\n    if (options?.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`)\n    }\n    if (this.flowType === 'pkce') {\n      const [codeChallenge, codeChallengeMethod] = await getCodeChallengeAndMethod(\n        this.storage,\n        this.storageKey\n      )\n\n      const flowParams = new URLSearchParams({\n        code_challenge: `${encodeURIComponent(codeChallenge)}`,\n        code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`,\n      })\n      urlParams.push(flowParams.toString())\n    }\n    if (options?.queryParams) {\n      const query = new URLSearchParams(options.queryParams)\n      urlParams.push(query.toString())\n    }\n    if (options?.skipBrowserRedirect) {\n      urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`)\n    }\n\n    return `${url}?${urlParams.join('&')}`\n  }\n\n  private async _unenroll(params: MFAUnenrollParams): Promise<AuthMFAUnenrollResponse> {\n    try {\n      return await this._useSession(async (result) => {\n        const { data: sessionData, error: sessionError } = result\n        if (sessionError) {\n          return { data: null, error: sessionError }\n        }\n\n        return await _request(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\n          headers: this.headers,\n          jwt: sessionData?.session?.access_token,\n        })\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#enroll}\n   */\n  private async _enroll(params: MFAEnrollTOTPParams): Promise<AuthMFAEnrollTOTPResponse>\n  private async _enroll(params: MFAEnrollPhoneParams): Promise<AuthMFAEnrollPhoneResponse>\n  private async _enroll(params: MFAEnrollParams): Promise<AuthMFAEnrollResponse> {\n    try {\n      return await this._useSession(async (result) => {\n        const { data: sessionData, error: sessionError } = result\n        if (sessionError) {\n          return { data: null, error: sessionError }\n        }\n\n        const body = {\n          friendly_name: params.friendlyName,\n          factor_type: params.factorType,\n          ...(params.factorType === 'phone' ? { phone: params.phone } : { issuer: params.issuer }),\n        }\n\n        const { data, error } = await _request(this.fetch, 'POST', `${this.url}/factors`, {\n          body,\n          headers: this.headers,\n          jwt: sessionData?.session?.access_token,\n        })\n\n        if (error) {\n          return { data: null, error }\n        }\n\n        if (params.factorType === 'totp' && data?.totp?.qr_code) {\n          data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`\n        }\n\n        return { data, error: null }\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#verify}\n   */\n  private async _verify(params: MFAVerifyParams): Promise<AuthMFAVerifyResponse> {\n    return this._acquireLock(-1, async () => {\n      try {\n        return await this._useSession(async (result) => {\n          const { data: sessionData, error: sessionError } = result\n          if (sessionError) {\n            return { data: null, error: sessionError }\n          }\n\n          const { data, error } = await _request(\n            this.fetch,\n            'POST',\n            `${this.url}/factors/${params.factorId}/verify`,\n            {\n              body: { code: params.code, challenge_id: params.challengeId },\n              headers: this.headers,\n              jwt: sessionData?.session?.access_token,\n            }\n          )\n          if (error) {\n            return { data: null, error }\n          }\n\n          await this._saveSession({\n            expires_at: Math.round(Date.now() / 1000) + data.expires_in,\n            ...data,\n          })\n          await this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data)\n\n          return { data, error }\n        })\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: null, error }\n        }\n        throw error\n      }\n    })\n  }\n\n  /**\n   * {@see GoTrueMFAApi#challenge}\n   */\n  private async _challenge(params: MFAChallengeParams): Promise<AuthMFAChallengeResponse> {\n    return this._acquireLock(-1, async () => {\n      try {\n        return await this._useSession(async (result) => {\n          const { data: sessionData, error: sessionError } = result\n          if (sessionError) {\n            return { data: null, error: sessionError }\n          }\n\n          return await _request(\n            this.fetch,\n            'POST',\n            `${this.url}/factors/${params.factorId}/challenge`,\n            {\n              body: { channel: params.channel },\n              headers: this.headers,\n              jwt: sessionData?.session?.access_token,\n            }\n          )\n        })\n      } catch (error) {\n        if (isAuthError(error)) {\n          return { data: null, error }\n        }\n        throw error\n      }\n    })\n  }\n\n  /**\n   * {@see GoTrueMFAApi#challengeAndVerify}\n   */\n  private async _challengeAndVerify(\n    params: MFAChallengeAndVerifyParams\n  ): Promise<AuthMFAVerifyResponse> {\n    // both _challenge and _verify independently acquire the lock, so no need\n    // to acquire it here\n\n    const { data: challengeData, error: challengeError } = await this._challenge({\n      factorId: params.factorId,\n    })\n    if (challengeError) {\n      return { data: null, error: challengeError }\n    }\n\n    return await this._verify({\n      factorId: params.factorId,\n      challengeId: challengeData.id,\n      code: params.code,\n    })\n  }\n\n  /**\n   * {@see GoTrueMFAApi#listFactors}\n   */\n  private async _listFactors(): Promise<AuthMFAListFactorsResponse> {\n    // use #getUser instead of #_getUser as the former acquires a lock\n    const {\n      data: { user },\n      error: userError,\n    } = await this.getUser()\n    if (userError) {\n      return { data: null, error: userError }\n    }\n\n    const factors = user?.factors || []\n    const totp = factors.filter(\n      (factor) => factor.factor_type === 'totp' && factor.status === 'verified'\n    )\n    const phone = factors.filter(\n      (factor) => factor.factor_type === 'phone' && factor.status === 'verified'\n    )\n\n    return {\n      data: {\n        all: factors,\n        totp,\n        phone,\n      },\n      error: null,\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n   */\n  private async _getAuthenticatorAssuranceLevel(): Promise<AuthMFAGetAuthenticatorAssuranceLevelResponse> {\n    return this._acquireLock(-1, async () => {\n      return await this._useSession(async (result) => {\n        const {\n          data: { session },\n          error: sessionError,\n        } = result\n        if (sessionError) {\n          return { data: null, error: sessionError }\n        }\n        if (!session) {\n          return {\n            data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },\n            error: null,\n          }\n        }\n\n        const { payload } = decodeJWT(session.access_token)\n\n        let currentLevel: AuthenticatorAssuranceLevels | null = null\n\n        if (payload.aal) {\n          currentLevel = payload.aal\n        }\n\n        let nextLevel: AuthenticatorAssuranceLevels | null = currentLevel\n\n        const verifiedFactors =\n          session.user.factors?.filter((factor: Factor) => factor.status === 'verified') ?? []\n\n        if (verifiedFactors.length > 0) {\n          nextLevel = 'aal2'\n        }\n\n        const currentAuthenticationMethods = payload.amr || []\n\n        return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null }\n      })\n    })\n  }\n\n  private async fetchJwk(kid: string, jwks: { keys: JWK[] } = { keys: [] }): Promise<JWK> {\n    // try fetching from the supplied jwks\n    let jwk = jwks.keys.find((key) => key.kid === kid)\n    if (jwk) {\n      return jwk\n    }\n\n    // try fetching from cache\n    jwk = this.jwks.keys.find((key) => key.kid === kid)\n\n    // jwk exists and jwks isn't stale\n    if (jwk && this.jwks_cached_at + JWKS_TTL > Date.now()) {\n      return jwk\n    }\n    // jwk isn't cached in memory so we need to fetch it from the well-known endpoint\n    const { data, error } = await _request(this.fetch, 'GET', `${this.url}/.well-known/jwks.json`, {\n      headers: this.headers,\n    })\n    if (error) {\n      throw error\n    }\n    if (!data.keys || data.keys.length === 0) {\n      throw new AuthInvalidJwtError('JWKS is empty')\n    }\n    this.jwks = data\n    this.jwks_cached_at = Date.now()\n    // Find the signing key\n    jwk = data.keys.find((key: any) => key.kid === kid)\n    if (!jwk) {\n      throw new AuthInvalidJwtError('No matching signing key found in JWKS')\n    }\n    return jwk\n  }\n\n  /**\n   * @experimental This method may change in future versions.\n   * @description Gets the claims from a JWT. If the JWT is symmetric JWTs, it will call getUser() to verify against the server. If the JWT is asymmetric, it will be verified against the JWKS using the WebCrypto API.\n   */\n  async getClaims(\n    jwt?: string,\n    jwks: { keys: JWK[] } = { keys: [] }\n  ): Promise<\n    | {\n        data: { claims: JwtPayload; header: JwtHeader; signature: Uint8Array }\n        error: null\n      }\n    | { data: null; error: AuthError }\n    | { data: null; error: null }\n  > {\n    try {\n      let token = jwt\n      if (!token) {\n        const { data, error } = await this.getSession()\n        if (error || !data.session) {\n          return { data: null, error }\n        }\n        token = data.session.access_token\n      }\n\n      const {\n        header,\n        payload,\n        signature,\n        raw: { header: rawHeader, payload: rawPayload },\n      } = decodeJWT(token)\n\n      // Reject expired JWTs\n      validateExp(payload.exp)\n\n      // If symmetric algorithm or WebCrypto API is unavailable, fallback to getUser()\n      if (\n        !header.kid ||\n        header.alg === 'HS256' ||\n        !('crypto' in globalThis && 'subtle' in globalThis.crypto)\n      ) {\n        const { error } = await this.getUser(token)\n        if (error) {\n          throw error\n        }\n        // getUser succeeds so the claims in the JWT can be trusted\n        return {\n          data: {\n            claims: payload,\n            header,\n            signature,\n          },\n          error: null,\n        }\n      }\n\n      const algorithm = getAlgorithm(header.alg)\n      const signingKey = await this.fetchJwk(header.kid, jwks)\n\n      // Convert JWK to CryptoKey\n      const publicKey = await crypto.subtle.importKey('jwk', signingKey, algorithm, true, [\n        'verify',\n      ])\n\n      // Verify the signature\n      const isValid = await crypto.subtle.verify(\n        algorithm,\n        publicKey,\n        signature,\n        stringToUint8Array(`${rawHeader}.${rawPayload}`)\n      )\n\n      if (!isValid) {\n        throw new AuthInvalidJwtError('Invalid JWT signature')\n      }\n\n      // If verification succeeds, decode and return claims\n      return {\n        data: {\n          claims: payload,\n          header,\n          signature,\n        },\n        error: null,\n      }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n}\n", "import { supportsLocalStorage } from './helpers'\nimport { SupportedStorage } from './types'\n\n/**\n * Provides safe access to the globalThis.localStorage property.\n */\nexport const localStorageAdapter: SupportedStorage = {\n  getItem: (key) => {\n    if (!supportsLocalStorage()) {\n      return null\n    }\n\n    return globalThis.localStorage.getItem(key)\n  },\n  setItem: (key, value) => {\n    if (!supportsLocalStorage()) {\n      return\n    }\n\n    globalThis.localStorage.setItem(key, value)\n  },\n  removeItem: (key) => {\n    if (!supportsLocalStorage()) {\n      return\n    }\n\n    globalThis.localStorage.removeItem(key)\n  },\n}\n\n/**\n * Returns a localStorage-like object that stores the key-value pairs in\n * memory.\n */\nexport function memoryLocalStorageAdapter(store: { [key: string]: string } = {}): SupportedStorage {\n  return {\n    getItem: (key) => {\n      return store[key] || null\n    },\n\n    setItem: (key, value) => {\n      store[key] = value\n    },\n\n    removeItem: (key) => {\n      delete store[key]\n    },\n  }\n}\n", "/**\n * https://mathiasbynens.be/notes/globalthis\n */\nexport function polyfillGlobalThis() {\n  if (typeof globalThis === 'object') return\n  try {\n    Object.defineProperty(Object.prototype, '__magic__', {\n      get: function () {\n        return this\n      },\n      configurable: true,\n    })\n    // @ts-expect-error 'Allow access to magic'\n    __magic__.globalThis = __magic__\n    // @ts-expect-error 'Allow access to magic'\n    delete Object.prototype.__magic__\n  } catch (e) {\n    if (typeof self !== 'undefined') {\n      // @ts-expect-error 'Allow access to globals'\n      self.globalThis = self\n    }\n  }\n}\n", "import { supportsLocalStorage } from './helpers'\n\n/**\n * @experimental\n */\nexport const internals = {\n  /**\n   * @experimental\n   */\n  debug: !!(\n    globalThis &&\n    supportsLocalStorage() &&\n    globalThis.localStorage &&\n    globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true'\n  ),\n}\n\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n */\nexport abstract class LockAcquireTimeoutError extends Error {\n  public readonly isAcquireTimeout = true\n\n  constructor(message: string) {\n    super(message)\n  }\n}\n\nexport class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {}\nexport class ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {}\n\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nexport async function navigatorLock<R>(\n  name: string,\n  acquireTimeout: number,\n  fn: () => Promise<R>\n): Promise<R> {\n  if (internals.debug) {\n    console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout)\n  }\n\n  const abortController = new globalThis.AbortController()\n\n  if (acquireTimeout > 0) {\n    setTimeout(() => {\n      abortController.abort()\n      if (internals.debug) {\n        console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name)\n      }\n    }, acquireTimeout)\n  }\n\n  // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n\n  // Wrapping navigator.locks.request() with a plain Promise is done as some\n  // libraries like zone.js patch the Promise object to track the execution\n  // context. However, it appears that most browsers use an internal promise\n  // implementation when using the navigator.locks.request() API causing them\n  // to lose context and emit confusing log messages or break certain features.\n  // This wrapping is believed to help zone.js track the execution context\n  // better.\n  return await Promise.resolve().then(() =>\n    globalThis.navigator.locks.request(\n      name,\n      acquireTimeout === 0\n        ? {\n            mode: 'exclusive',\n            ifAvailable: true,\n          }\n        : {\n            mode: 'exclusive',\n            signal: abortController.signal,\n          },\n      async (lock) => {\n        if (lock) {\n          if (internals.debug) {\n            console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name)\n          }\n\n          try {\n            return await fn()\n          } finally {\n            if (internals.debug) {\n              console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name)\n            }\n          }\n        } else {\n          if (acquireTimeout === 0) {\n            if (internals.debug) {\n              console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name)\n            }\n\n            throw new NavigatorLockAcquireTimeoutError(\n              `Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`\n            )\n          } else {\n            if (internals.debug) {\n              try {\n                const result = await globalThis.navigator.locks.query()\n\n                console.log(\n                  '@supabase/gotrue-js: Navigator LockManager state',\n                  JSON.stringify(result, null, '  ')\n                )\n              } catch (e: any) {\n                console.warn(\n                  '@supabase/gotrue-js: Error when querying Navigator LockManager state',\n                  e\n                )\n              }\n            }\n\n            // Browser is not following the Navigator LockManager spec, it\n            // returned a null lock when we didn't use ifAvailable. So we can\n            // pretend the lock is acquired in the name of backward compatibility\n            // and user experience and just run the function.\n            console.warn(\n              '@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request'\n            )\n\n            return await fn()\n          }\n        }\n      }\n    )\n  )\n}\n\nconst PROCESS_LOCKS: { [name: string]: Promise<any> } = {}\n\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nexport async function processLock<R>(\n  name: string,\n  acquireTimeout: number,\n  fn: () => Promise<R>\n): Promise<R> {\n  const previousOperation = PROCESS_LOCKS[name] ?? Promise.resolve()\n\n  const currentOperation = Promise.race(\n    [\n      previousOperation.catch(() => {\n        // ignore error of previous operation that we're waiting to finish\n        return null\n      }),\n      acquireTimeout >= 0\n        ? new Promise((_, reject) => {\n            setTimeout(() => {\n              reject(\n                new ProcessLockAcquireTimeoutError(\n                  `Acquring process lock with name \"${name}\" timed out`\n                )\n              )\n            }, acquireTimeout)\n          })\n        : null,\n    ].filter((x) => x)\n  )\n    .catch((e: any) => {\n      if (e && e.isAcquireTimeout) {\n        throw e\n      }\n\n      return null\n    })\n    .then(async () => {\n      // previous operations finished and we didn't get a race on the acquire\n      // timeout, so the current operation can finally start\n      return await fn()\n    })\n\n  PROCESS_LOCKS[name] = currentOperation.catch(async (e: any) => {\n    if (e && e.isAcquireTimeout) {\n      // if the current operation timed out, it doesn't mean that the previous\n      // operation finished, so we need contnue waiting for it to finish\n      await previousOperation\n\n      return null\n    }\n\n    throw e\n  })\n\n  // finally wait for the current operation to finish successfully, with an\n  // error or with an acquire timeout error\n  return await currentOperation\n}\n", "import GoTrueAdminApi from './GoTrueAdminApi'\n\nconst AuthAdminApi = GoTrueAdminApi\n\nexport default AuthAdminApi\n", "import GoTrueClient from './GoTrueClient'\n\nconst AuthClient = GoTrueClient\n\nexport default AuthClient\n", "import { FunctionsClient } from '@supabase/functions-js'\nimport { AuthChangeEvent } from '@supabase/auth-js'\nimport {\n  PostgrestClient,\n  PostgrestFilterBuilder,\n  PostgrestQueryBuilder,\n} from '@supabase/postgrest-js'\nimport {\n  RealtimeChannel,\n  RealtimeChannelOptions,\n  RealtimeClient,\n  RealtimeClientOptions,\n} from '@supabase/realtime-js'\nimport { StorageClient as SupabaseStorageClient } from '@supabase/storage-js'\nimport {\n  DEFAULT_GLOBAL_OPTIONS,\n  DEFAULT_DB_OPTIONS,\n  DEFAULT_AUTH_OPTIONS,\n  DEFAULT_REALTIME_OPTIONS,\n} from './lib/constants'\nimport { fetchWithAuth } from './lib/fetch'\nimport { ensureTrailingSlash, applySettingDefaults } from './lib/helpers'\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient'\nimport { Fetch, GenericSchema, SupabaseClientOptions, SupabaseAuthClientOptions } from './lib/types'\n\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */\nexport default class SupabaseClient<\n  Database = any,\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\n    ? 'public'\n    : string & keyof Database,\n  Schema extends GenericSchema = Database[SchemaName] extends GenericSchema\n    ? Database[SchemaName]\n    : any\n> {\n  /**\n   * Supabase Auth allows you to create and manage user sessions for access to data that is secured by access policies.\n   */\n  auth: SupabaseAuthClient\n  realtime: RealtimeClient\n\n  protected realtimeUrl: URL\n  protected authUrl: URL\n  protected storageUrl: URL\n  protected functionsUrl: URL\n  protected rest: PostgrestClient<Database, SchemaName, Schema>\n  protected storageKey: string\n  protected fetch?: Fetch\n  protected changedAccessToken?: string\n  protected accessToken?: () => Promise<string | null>\n\n  protected headers: Record<string, string>\n\n  /**\n   * Create a new client for use in the browser.\n   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n   * @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.realtime Options passed along to realtime-js constructor.\n   * @param options.global.fetch A custom fetch implementation.\n   * @param options.global.headers Any additional headers to send with each network request.\n   */\n  constructor(\n    protected supabaseUrl: string,\n    protected supabaseKey: string,\n    options?: SupabaseClientOptions<SchemaName>\n  ) {\n    if (!supabaseUrl) throw new Error('supabaseUrl is required.')\n    if (!supabaseKey) throw new Error('supabaseKey is required.')\n\n    const _supabaseUrl = ensureTrailingSlash(supabaseUrl)\n    const baseUrl = new URL(_supabaseUrl)\n\n    this.realtimeUrl = new URL('realtime/v1', baseUrl)\n    this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace('http', 'ws')\n    this.authUrl = new URL('auth/v1', baseUrl)\n    this.storageUrl = new URL('storage/v1', baseUrl)\n    this.functionsUrl = new URL('functions/v1', baseUrl)\n\n    // default storage key uses the supabase project ref as a namespace\n    const defaultStorageKey = `sb-${baseUrl.hostname.split('.')[0]}-auth-token`\n    const DEFAULTS = {\n      db: DEFAULT_DB_OPTIONS,\n      realtime: DEFAULT_REALTIME_OPTIONS,\n      auth: { ...DEFAULT_AUTH_OPTIONS, storageKey: defaultStorageKey },\n      global: DEFAULT_GLOBAL_OPTIONS,\n    }\n\n    const settings = applySettingDefaults(options ?? {}, DEFAULTS)\n\n    this.storageKey = settings.auth.storageKey ?? ''\n    this.headers = settings.global.headers ?? {}\n\n    if (!settings.accessToken) {\n      this.auth = this._initSupabaseAuthClient(\n        settings.auth ?? {},\n        this.headers,\n        settings.global.fetch\n      )\n    } else {\n      this.accessToken = settings.accessToken\n\n      this.auth = new Proxy<SupabaseAuthClient>({} as any, {\n        get: (_, prop) => {\n          throw new Error(\n            `@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(\n              prop\n            )} is not possible`\n          )\n        },\n      })\n    }\n\n    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch)\n    this.realtime = this._initRealtimeClient({\n      headers: this.headers,\n      accessToken: this._getAccessToken.bind(this),\n      ...settings.realtime,\n    })\n    this.rest = new PostgrestClient(new URL('rest/v1', baseUrl).href, {\n      headers: this.headers,\n      schema: settings.db.schema,\n      fetch: this.fetch,\n    })\n\n    if (!settings.accessToken) {\n      this._listenForAuthEvents()\n    }\n  }\n\n  /**\n   * Supabase Functions allows you to deploy and invoke edge functions.\n   */\n  get functions(): FunctionsClient {\n    return new FunctionsClient(this.functionsUrl.href, {\n      headers: this.headers,\n      customFetch: this.fetch,\n    })\n  }\n\n  /**\n   * Supabase Storage allows you to manage user-generated content, such as photos or videos.\n   */\n  get storage(): SupabaseStorageClient {\n    return new SupabaseStorageClient(this.storageUrl.href, this.headers, this.fetch)\n  }\n\n  // NOTE: signatures must be kept in sync with PostgrestClient.from\n  from<\n    TableName extends string & keyof Schema['Tables'],\n    Table extends Schema['Tables'][TableName]\n  >(relation: TableName): PostgrestQueryBuilder<Schema, Table, TableName>\n  from<ViewName extends string & keyof Schema['Views'], View extends Schema['Views'][ViewName]>(\n    relation: ViewName\n  ): PostgrestQueryBuilder<Schema, View, ViewName>\n  /**\n   * Perform a query on a table or a view.\n   *\n   * @param relation - The table or view name to query\n   */\n  from(relation: string): PostgrestQueryBuilder<Schema, any, any> {\n    return this.rest.from(relation)\n  }\n\n  // NOTE: signatures must be kept in sync with PostgrestClient.schema\n  /**\n   * Select a schema to query or perform an function (rpc) call.\n   *\n   * The schema needs to be on the list of exposed schemas inside Supabase.\n   *\n   * @param schema - The schema to query\n   */\n  schema<DynamicSchema extends string & keyof Database>(\n    schema: DynamicSchema\n  ): PostgrestClient<\n    Database,\n    DynamicSchema,\n    Database[DynamicSchema] extends GenericSchema ? Database[DynamicSchema] : any\n  > {\n    return this.rest.schema<DynamicSchema>(schema)\n  }\n\n  // NOTE: signatures must be kept in sync with PostgrestClient.rpc\n  /**\n   * Perform a function call.\n   *\n   * @param fn - The function name to call\n   * @param args - The arguments to pass to the function call\n   * @param options - Named parameters\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   * @param options.get - When set to `true`, the function will be called with\n   * read-only access mode.\n   * @param options.count - Count algorithm to use to count rows returned by the\n   * function. Only applicable for [set-returning\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  rpc<FnName extends string & keyof Schema['Functions'], Fn extends Schema['Functions'][FnName]>(\n    fn: FnName,\n    args: Fn['Args'] = {},\n    options: {\n      head?: boolean\n      get?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<\n    Schema,\n    Fn['Returns'] extends any[]\n      ? Fn['Returns'][number] extends Record<string, unknown>\n        ? Fn['Returns'][number]\n        : never\n      : never,\n    Fn['Returns'],\n    FnName,\n    null\n  > {\n    return this.rest.rpc(fn, args, options)\n  }\n\n  /**\n   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\n   *\n   * @param {string} name - The name of the Realtime channel.\n   * @param {Object} opts - The options to pass to the Realtime channel.\n   *\n   */\n  channel(name: string, opts: RealtimeChannelOptions = { config: {} }): RealtimeChannel {\n    return this.realtime.channel(name, opts)\n  }\n\n  /**\n   * Returns all Realtime channels.\n   */\n  getChannels(): RealtimeChannel[] {\n    return this.realtime.getChannels()\n  }\n\n  /**\n   * Unsubscribes and removes Realtime channel from Realtime client.\n   *\n   * @param {RealtimeChannel} channel - The name of the Realtime channel.\n   *\n   */\n  removeChannel(channel: RealtimeChannel): Promise<'ok' | 'timed out' | 'error'> {\n    return this.realtime.removeChannel(channel)\n  }\n\n  /**\n   * Unsubscribes and removes all Realtime channels from Realtime client.\n   */\n  removeAllChannels(): Promise<('ok' | 'timed out' | 'error')[]> {\n    return this.realtime.removeAllChannels()\n  }\n\n  private async _getAccessToken() {\n    if (this.accessToken) {\n      return await this.accessToken()\n    }\n\n    const { data } = await this.auth.getSession()\n\n    return data.session?.access_token ?? null\n  }\n\n  private _initSupabaseAuthClient(\n    {\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      storageKey,\n      flowType,\n      lock,\n      debug,\n    }: SupabaseAuthClientOptions,\n    headers?: Record<string, string>,\n    fetch?: Fetch\n  ) {\n    const authHeaders = {\n      Authorization: `Bearer ${this.supabaseKey}`,\n      apikey: `${this.supabaseKey}`,\n    }\n    return new SupabaseAuthClient({\n      url: this.authUrl.href,\n      headers: { ...authHeaders, ...headers },\n      storageKey: storageKey,\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      flowType,\n      lock,\n      debug,\n      fetch,\n      // auth checks if there is a custom authorizaiton header using this flag\n      // so it knows whether to return an error when getUser is called with no session\n      hasCustomAuthorizationHeader: 'Authorization' in this.headers,\n    })\n  }\n\n  private _initRealtimeClient(options: RealtimeClientOptions) {\n    return new RealtimeClient(this.realtimeUrl.href, {\n      ...options,\n      params: { ...{ apikey: this.supabaseKey }, ...options?.params },\n    })\n  }\n\n  private _listenForAuthEvents() {\n    let data = this.auth.onAuthStateChange((event, session) => {\n      this._handleTokenChanged(event, 'CLIENT', session?.access_token)\n    })\n    return data\n  }\n\n  private _handleTokenChanged(\n    event: AuthChangeEvent,\n    source: 'CLIENT' | 'STORAGE',\n    token?: string\n  ) {\n    if (\n      (event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') &&\n      this.changedAccessToken !== token\n    ) {\n      this.changedAccessToken = token\n    } else if (event === 'SIGNED_OUT') {\n      this.realtime.setAuth()\n      if (source == 'STORAGE') this.auth.signOut()\n      this.changedAccessToken = undefined\n    }\n  }\n}\n", "import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\n\nexport function register_secret(server: McpServer) {\n  server.tool(\"get_secret\", {}, async () => {\n    console.log(\"returning secret password\");\n    return {\n      content: [{ type: \"text\", text: \"wolfyabc\" }],\n    };\n  });\n} ", "import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { SupabaseClient } from \"@supabase/supabase-js\";\n\nexport function register_layer(server: McpServer, supabase: SupabaseClient) {\n  server.tool(\"get_layer\", {}, async () => {\n    const { data: layer, error } = await supabase\n      .from(\"layer\")\n      .select(\"*\");\n\n    if (error) {\n      return {\n        content: [\n          { type: \"text\", text: `Error fetching layer: ${error.message}` },\n        ],\n      };\n    }\n\n    console.log(\"data\", layer);\n\n    return {\n      content: [{ type: \"text\", text: JSON.stringify(layer, null, 2) }],\n    };\n  });\n} ", "import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { SupabaseClient } from \"@supabase/supabase-js\";\nimport { z } from \"zod\";\n\n\nexport function register_get_outfit_details(server: McpServer, supabase: SupabaseClient) {\n  server.tool(\"get_outfit_details\", { outfit_id: z.string() },  async ({outfit_id}) => {\n    const { data, error } = await supabase.rpc(\"get_outfit_details\", {\n        outfit_uuid: outfit_id,\n    });\n\n    if (error) {\n      return {\n        content: [\n          { type: \"text\", text: `Error getting outfit details: ${error.message}` },\n        ],\n      };\n    }\n\n    console.log(\"data\", data);\n\n    return {\n      content: [{ type: \"text\", text: JSON.stringify(data, null, 2) }],\n    };\n  });\n} ", "import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { SupabaseClient } from \"@supabase/supabase-js\";\nimport { z } from \"zod\";\n\n\nexport function register_calculate_outfit_warmth(server: McpServer, supabase: SupabaseClient) {\n  server.tool(\"calculate_outfit_warmth\", { outfit_id: z.string() }, async ({outfit_id}) => {\n    const { data, error } = await supabase.rpc(\"calculate_outfit_warmth\", {\n        outfit_uuid: outfit_id,\n    });\n\n    if (error) {\n      return {\n        content: [\n          { type: \"text\", text: `Error getting outfit details: ${error.message}` },\n        ],\n      };\n    }\n\n    console.log(\"data\", data);\n\n    return {\n      content: [{ type: \"text\", text: JSON.stringify(data, null, 2) }],\n    };\n  });\n} ", "import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { SupabaseClient } from \"@supabase/supabase-js\";\nimport { z } from \"zod\";\n\nexport function register_logs(server: McpServer, supabase: SupabaseClient) {\n  server.tool(\n    \"get_logs_by_date\",\n    { date: z.string() },\n    async ({ date }) => {\n      const { data, error } = await supabase.rpc(\"get_logs_by_date\", { \n        log_date: date  // \u2705 Fixed: Use log_date parameter name\n      });\n      if (error) {\n        return {\n          content: [\n            { type: \"text\", text: `Error getting logs by date: ${error.message}` },\n          ],\n        };\n      }\n      return {\n        content: [{ type: \"text\", text: JSON.stringify(data, null, 2) }],\n      };\n    }\n  );\n\n  server.tool(\n    \"get_logs_date_range\",\n    { start_date: z.string(), end_date: z.string() },\n    async ({ start_date, end_date }) => {\n      const { data, error } = await supabase.rpc(\"get_logs_date_range\", { \n        start_date,   // \u2705 These match the function parameters\n        end_date \n      });\n      if (error) {\n        return {\n          content: [\n            { type: \"text\", text: `Error getting logs by date range: ${error.message}` },\n          ],\n        };\n      }\n      return {\n        content: [{ type: \"text\", text: JSON.stringify(data, null, 2) }],\n      };\n    }\n  );\n\n  server.tool(\n    \"get_logs_by_outfit\",\n    { outfit_id: z.string() },\n    async ({ outfit_id }) => {\n      const { data, error } = await supabase.rpc(\"get_logs_by_outfit\", { \n        outfit_uuid: outfit_id  // \u2705 This was already correct\n      });\n      if (error) {\n        return {\n          content: [\n            { type: \"text\", text: `Error getting logs by outfit: ${error.message}` },\n          ],\n        };\n      }\n      return {\n        content: [{ type: \"text\", text: JSON.stringify(data, null, 2) }],\n      };\n    }\n  );\n}", "import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { SupabaseClient } from \"@supabase/supabase-js\";\nimport { z } from \"zod\";\n\n\nexport function register_get_weather(server: McpServer, supabase: SupabaseClient) {\n  server.tool(\"get_weather\", { lat: z.number(), long: z.number(), date: z.string() },  async ({lat, long, date}) => {\n    const { data, error } = await supabase.functions.invoke(\"get_weather\", {\n        body: { \n          latitude: lat,\n          longitude: long,\n          date: date,\n          unitGroup: \"us\"\n        }\n      });\n\n    if (error) {\n      return {\n        content: [\n          { type: \"text\", text: `Error getting weather: ${error.message}` },\n        ],\n      };\n    }\n\n    console.log(\"data\", data);\n\n    return {\n      content: [{ type: \"text\", text: JSON.stringify(data, null, 2) }],\n    };\n  });\n} ", "import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\n\nexport function register_schema(server: McpServer) {\n  server.resource(\n    \"schema\",\n    \"schema://database-schema\",\n    async (uri) => {\n      const schema = `-- WARNING: This schema is for context only and is not meant to be run.\n-- Table order and constraints may not be valid for execution.\n\nCREATE TABLE public.layer (\n  id uuid NOT NULL DEFAULT gen_random_uuid(),\n  created_at timestamp with time zone NOT NULL DEFAULT now(),\n  name text,\n  description text,\n  warmth smallint,\n  top boolean,\n  bottom boolean,\n  CONSTRAINT layer_pkey PRIMARY KEY (id)\n);\n\nCREATE TABLE public.log (\n  id uuid NOT NULL DEFAULT gen_random_uuid(),\n  created_at timestamp with time zone NOT NULL DEFAULT now(),\n  outfit_id uuid DEFAULT gen_random_uuid(),\n  date date,\n  comfort_level smallint,\n  feedback text,\n  was_too_hot boolean,\n  was_too_cold boolean,\n  weather_id uuid,\n  CONSTRAINT log_pkey PRIMARY KEY (id),\n  CONSTRAINT outfit_log_outfit_id_fkey FOREIGN KEY (outfit_id) REFERENCES public.outfit(id),\n  CONSTRAINT outfit_log_weather_id_fkey FOREIGN KEY (weather_id) REFERENCES public.weather(id)\n);\n\nCREATE TABLE public.outfit (\n  id uuid NOT NULL DEFAULT gen_random_uuid(),\n  created_at timestamp with time zone NOT NULL DEFAULT now(),\n  name text,\n  total_warmth smallint,\n  CONSTRAINT outfit_pkey PRIMARY KEY (id)\n);\n\nCREATE TABLE public.outfit_layer (\n  id uuid NOT NULL DEFAULT gen_random_uuid(),\n  created_at timestamp with time zone NOT NULL DEFAULT now(),\n  outfit_id uuid DEFAULT gen_random_uuid(),\n  layer_id uuid DEFAULT gen_random_uuid(),\n  CONSTRAINT outfit_layer_pkey PRIMARY KEY (id),\n  CONSTRAINT outfit_layer_layer_id_fkey FOREIGN KEY (layer_id) REFERENCES public.layer(id),\n  CONSTRAINT outfit_layer_outfit_id_fkey FOREIGN KEY (outfit_id) REFERENCES public.outfit(id)\n);\n\nCREATE TABLE public.weather (\n  id uuid NOT NULL DEFAULT gen_random_uuid(),\n  created_at timestamp with time zone NOT NULL DEFAULT now(),\n  latitude double precision,\n  longitude double precision,\n  date date,\n  weather_data jsonb,\n  CONSTRAINT weather_pkey PRIMARY KEY (id)\n);`;\n\n      return {\n        contents: [{\n          uri: uri.href,\n          text: schema\n        }]\n      };\n    }\n  );\n}", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n"],
  "mappings": "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AAAA,MACX,QAAQ;AAAA,MACR,iBAAiB;AAAA,IAClB;AAAA;AAAA;;;AC7NA,IAEM,eACO,kBACE,MAAM,UAAU,UAGzB,cAMJ,OACA,aACA,6BACA,qCACA,qCACA,aACA,mBACA,MACA,MACA,OACA,OACA,QACA,WACA,mBACA,iBACA,UACA,KACA,WACA,QACA,YACA,MACA,aACA,KACA,YACA,UACA,UACA,cACA,UACA,wBACA,iBACAC,SACA,MACA,WACA,eACA,aACA,IACA,KACA,MACA,KACA,MACA,iBACA,qBACA,cACA,SACA,oBACA,gBACA,QACA,eACA,iBACA,sBACA,QACA,OACA,QACA,OACA,kBACA,kBACA,OACA,QACA,SACA,UACA,QACA,YACA,gBACA,YACA,WACAC,SACA,SACA,MACA,UACA,SACA,SACA,SACA,QACA,WACA,QACA,SACA,SACA,QACA,WACA,QACA,YACA,YACA,SACA,cACA,UACA,eACA,WACA,eACA,iBACA,mBACA,oBACA,OACA,kBACA,WACA,4BACA,2BACA,eACA,aACA,cACA,iBACA,UACA,OACA,gBAEI,UA8GC;AAnOP,IAAAC,gBAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAC;AAAA;AACA;AACA,IAAM,gBAAgB,WAAW,SAAS;AACnC,IAAM,mBAAmB,cAAc;AACvC,KAAM,EAAE,MAAM,UAAU,aAAa;AAAA,MAC1C;AAAA,IACF;AACA,IAAM,eAAe,IAAI,QAAa;AAAA,MACpC,KAAK,cAAc;AAAA,MACnB;AAAA,MACA;AAAA,IACF,CAAC;AACM,KAAM;AAAA,MACX;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAAH;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAAC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,QACE;AACJ,IAAM,WAAW;AAAA,MACf;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAAD;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAA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",
  "names": ["name", "init_performance", "performance", "init_performance", "name", "PerformanceMark", "init_performance", "init_performance", "performance", "init_performance", "init_performance", "clear", "count", "countReset", "createTask", "debug", "dir", "dirxml", "error", "group", "groupCollapsed", "groupEnd", "info", "log", "profile", "profileEnd", "table", "time", "timeEnd", "timeLog", "timeStamp", "trace", "warn", "init_console", "init_performance", "init_console", "init_performance", "hrtime", "init_performance", "dir", "env", "count", "init_performance", "init_performance", "init_performance", "init_performance", "cwd", "hrtime", "assert", "init_process", "init_performance", "init_process", "init_performance", "merge", "sets", "length", "slice", "xl", "x", "join", "subexp", "str", "typeOf", "o", "undefined", "Object", "prototype", "toString", "call", "split", "pop", "shift", "toLowerCase", "toUpperCase", "toArray", "obj", "Array", "setInterval", "assign", "target", "source", "key", "buildExps", "isIRI", "ALPHA$$", "CR$", "DIGIT$$", "DQUOTE$$", "HEXDIG$$", "SP$$", "PCT_ENCODED$", "SUB_DELIMS$$", "RESERVED$$", "GEN_DELIMS$$", "UCSCHAR$$", "SCHEME$", "USERINFO$", "UNRESERVED$$", "DEC_OCTET$", "DEC_OCTET_RELAXED$", "H16$", "LS32$", "IPV4ADDRESS$", "IPV6ADDRESS1$", "IPV6ADDRESS2$", "IPV6ADDRESS3$", "IPV6ADDRESS4$", "IPV6ADDRESS5$", "IPV6ADDRESS6$", "IPV6ADDRESS7$", "IPV6ADDRESS8$", "IPV6ADDRESS9$", "ZONEID$", "IPV6ADDRESS$", "IP_LITERAL$", "IPV6ADDRZ_RELAXED$", "IPVFUTURE$", "HOST$", "REG_NAME$", "PORT$", "AUTHORITY$", "PCHAR$", "SEGMENT$", "SEGMENT_NZ$", "SEGMENT_NZ_NC$", "PATH_ABEMPTY$", "PATH_ABSOLUTE$", "PATH$", "PATH_NOSCHEME$", "PATH_ROOTLESS$", "PATH_EMPTY$", "QUERY$", "IPRIVATE$$", "FRAGMENT$", "HIER_PART$", "URI$", "RELATIVE_PART$", "RELATIVE$", "URI_REFERENCE$", "ABSOLUTE_URI$", "GENERIC_REF$", "RELATIVE_REF$", "ABSOLUTE_REF$", "SAMEDOC_REF$", "AUTHORITY_REF$", "RegExp", "maxInt", "base", "tMin", "tMax", "skew", "damp", "initialBias", "initialN", "delimiter", "regexPunycode", "regexNonASCII", "regexSeparators", "errors", "baseMinusTMin", "floor", "Math", "stringFromCharCode", "String", "fromCharCode", "error", "type", "RangeError", "map", "array", "fn", "result", "mapDomain", "string", "parts", "replace", "labels", "encoded", "ucs2decode", "output", "counter", "value", "charCodeAt", "extra", "push", "ucs2encode", "fromCodePoint", "basicToDigit", "codePoint", "digitToBasic", "digit", "flag", "adapt", "delta", "numPoints", "firstTime", "k", "decode", "input", "inputLength", "i", "n", "bias", "basic", "lastIndexOf", "j", "index", "oldi", "w", "t", "baseMinusT", "out", "splice", "encode", "currentValue", "basicLength", "handledCPCount", "m", "handledCPCountPlusOne", "q", "qMinusT", "toUnicode", "test", "toASCII", "punycode", "SCHEMES", "pctEncChar", "chr", "c", "e", "pctDecChars", "newStr", "il", "parseInt", "substr", "c2", "c3", "_normalizeComponentEncoding", "components", "protocol", "decodeUnreserved", "decStr", "match", "UNRESERVED", "scheme", "PCT_ENCODED", "NOT_SCHEME", "userinfo", "NOT_USERINFO", "host", "NOT_HOST", "path", "NOT_PATH", "NOT_PATH_NOSCHEME", "query", "NOT_QUERY", "fragment", "NOT_FRAGMENT", "_stripLeadingZeros", "_normalizeIPv4", "matches", "IPV4ADDRESS", "address", "_normalizeIPv6", "IPV6ADDRESS", "zone", "reverse", "last", "first", "firstFields", "lastFields", "isLastFieldIPv4Address", "fieldCount", "lastFieldsStart", "fields", "allZeroFields", "reduce", "acc", "field", "lastLongest", "longestZeroFields", "sort", "a", "b", "newHost", "newFirst", "newLast", "URI_PARSE", "NO_MATCH_IS_UNDEFINED", "parse", "uriString", "options", "iri", "IRI_PROTOCOL", "URI_PROTOCOL", "reference", "port", "isNaN", "indexOf", "schemeHandler", "unicodeSupport", "domainHost", "_recomposeAuthority", "uriTokens", "_", "$1", "$2", "RDS1", "RDS2", "RDS3", "RDS5", "removeDotSegments", "im", "s", "Error", "serialize", "authority", "charAt", "absolutePath", "resolveComponents", "relative", "skipNormalization", "tolerant", "resolve", "baseURI", "relativeURI", "schemelessOptions", "normalize", "uri", "equal", "uriA", "uriB", "escapeComponent", "ESCAPE", "unescapeComponent", "handler", "secure", "http", "isSecure", "wsComponents", "resourceName", "ws", "O", "ATEXT$$", "QTEXT$$", "VCHAR$$", "SOME_DELIMS$$", "NOT_LOCAL_PART", "NOT_HFNAME", "NOT_HFVALUE", "mailtoComponents", "to", "unknownHeaders", "headers", "hfields", "hfield", "toAddrs", "subject", "body", "addr", "toAddr", "atIdx", "localPart", "domain", "name", "URN_PARSE", "urnComponents", "nid", "nss", "urnScheme", "uriComponents", "UUID", "uuidComponents", "uuid", "https", "wss", "mailto", "urn", "init_performance", "init_performance", "init_performance", "OK", "init_performance", "util", "init_performance", "post", "init_performance", "util", "count", "self", "init_performance", "init_performance", "init_performance", "$rulesGroup", "$rule", "init_performance", "util", "self", "localRefs", "baseId", "v", "refVal", "index", "schema", "compile", "init_performance", "Cache", "init_performance", "util", "URL", "time", "init_performance", "init_performance", "init_performance", "$sch", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "group", "init_performance", "init_performance", "self", "ref", "init_performance", "init_performance", "init_performance", "keyword", "dataType", "definition", "i", "require_data", "init_performance", "util", "Ajv", "addFormat", "self", "text", "name", "noop", "init_performance", "text", "Headers", "Request", "Response", "fetch", "init_performance", "PostgrestError", "context", "PostgrestBuilder", "name", "_fetch", "res", "error", "count", "_a", "PostgrestTransformBuilder", "count", "_a", "PostgrestFilterBuilder", "config", "PostgrestQueryBuilder", "fetch", "head", "count", "PostgrestClient", "fetch", "head", "get", "count", "name", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "_a", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "util", "object", "objectUtil", "error", "init_performance", "init_performance", "init_performance", "init_performance", "errorUtil", "error", "errorMap", "version", "ctx", "result", "index", "issues", "elements", "processed", "result", "r", "ZodFirstPartyTypeKind", "ErrorCode", "init_performance", "init_performance", "crypto", "init_performance", "error", "codeVerifier", "tokens", "_a", "error", "_a", "text", "init_performance", "init_performance", "_request", "info", "error", "_a", "_b", "_a", "Ajv", "error", "validator", "isValid", "_AISDKError", "name", "error", "marker", "symbol", "_a", "_a", "symbol", "name", "marker", "_a", "symbol", "error", "name", "marker", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "text", "error", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "_TypeValidationError", "error", "_a", "symbol", "init_performance", "error", "zodSchema", "validator", "error", "text", "SecureJSON", "error", "btoa", "atob", "init_performance", "init_performance", "init_performance", "name", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "emojiRegex", "init_performance", "object", "init_performance", "init_performance", "init_performance", "init_performance", "types", "x", "base", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "jsonSchema", "index", "init_performance", "init_performance", "name", "schema", "title", "textStreamPart", "errorStreamPart", "validCodes", "NEWLINE", "zodSchema", "_a", "jsonSchema", "name", "marker", "symbol", "_a", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "symbol", "_a", "_a", "symbol", "name", "marker", "symbol", "_a", "AISDKError", "text", "error", "_a", "symbol", "name", "marker", "symbol", "_a", "_a", "symbol", "name", "marker", "symbol", "_a", "_a", "symbol", "name", "marker", "symbol", "_a", "_a", "symbol", "z", "originalGenerateId", "createIdGenerator", "name", "marker", "symbol", "_a", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "symbol", "_a", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "_a", "symbol", "originalGenerateId", "createIdGenerator", "__export", "name", "marker", "symbol", "_a", "_a", "symbol", "name", "marker", "_a", "symbol", "text", "asSchema", "parsePartialJson", "context", "safeParseJSON", "safeValidateTypes", "error", "result", "originalGenerateId", "createIdGenerator", "originalGenerateMessageId", "name", "marker", "symbol", "_a", "_a", "symbol", "z", "ResultSchema", "RequestSchema", "ServerCapabilitiesSchema", "InitializeResultSchema", "PaginatedResultSchema", "ToolSchema", "ListToolsResultSchema", "TextContentSchema", "ImageContentSchema", "ResourceContentsSchema", "TextResourceContentsSchema", "BlobResourceContentsSchema", "EmbeddedResourceSchema", "CallToolResultSchema", "JSONRPC_VERSION", "JSONRPCRequestSchema", "JSONRPCResponseSchema", "JSONRPCErrorSchema", "JSONRPCNotificationSchema", "JSONRPCMessageSchema", "__export", "_a", "formatDataStreamPart", "mergeIntoDataStream", "toDataStream", "toDataStreamResponse", "toDataStreamInternal", "text", "init_performance", "init_performance", "info", "url", "name", "init_performance", "_a", "env", "error", "e", "name", "context", "init_performance", "init_performance", "init_performance", "name", "dir", "_a", "_a", "init_performance", "env", "_onMessage", "ctx", "error", "time", "url", "DurableObject", "error", "DurableObject", "env", "_a", "self", "binding", "event", "body", "init_performance", "init_performance", "Server", "_a", "init_performance", "McpZodTypeKind", "processCreateParams", "processCreateParams", "errorMap", "_a", "init_performance", "Server", "name", "error", "config", "name", "init_performance", "init_performance", "init_performance", "_fetch", "fetch", "init_performance", "name", "context", "FunctionRegion", "_a", "error", "init_performance", "index", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "version", "version", "SOCKET_STATES", "CHANNEL_STATES", "CHANNEL_EVENTS", "TRANSPORTS", "CONNECTION_STATE", "init_performance", "init_performance", "init_performance", "PostgresTypes", "_a", "noop", "error", "init_performance", "init_performance", "channel", "_a", "init_performance", "REALTIME_PRESENCE_LISTEN_EVENTS", "channel", "_a", "REALTIME_POSTGRES_CHANGES_LISTEN_EVENT", "REALTIME_LISTEN_TYPES", "REALTIME_SUBSCRIBE_STATES", "config", "_a", "table", "error", "_b", "type", "binding", "noop", "_fetch", "fetch", "_a", "isBrowser", "channel", "error", "init_performance", "init_performance", "init_performance", "error", "resolveFetch", "_fetch", "fetch", "__awaiter", "error", "__awaiter", "fetch", "resolveFetch", "error", "init_performance", "init_performance", "version", "DEFAULT_HEADERS", "version", "fetch", "DEFAULT_HEADERS", "resolveFetch", "error", "fetch", "init_performance", "init_performance", "version", "DEFAULT_HEADERS", "version", "resolveFetch", "_fetch", "Headers", "fetch", "__awaiter", "_a", "DEFAULT_DB_OPTIONS", "DEFAULT_AUTH_OPTIONS", "DEFAULT_REALTIME_OPTIONS", "DEFAULT_GLOBAL_OPTIONS", "_a", "__awaiter", "init_performance", "init_performance", "init_performance", "init_performance", "version", "DEFAULT_HEADERS", "version", "init_performance", "init_performance", "error", "name", "init_performance", "emit", "emit", "resolveFetch", "_fetch", "fetch", "_a", "time", "_getErrorMessage", "handleError", "error", "_a", "_getRequestParams", "_handleRequest", "init_performance", "fetch", "resolveFetch", "error", "__rest", "_a", "init_performance", "init_performance", "init_performance", "init_performance", "name", "DEFAULT_HEADERS", "name", "resolveFetch", "_a", "version", "error", "result", "expiresAt", "data", "isValid", "init_performance", "init_performance", "_a", "name", "channel", "debug", "fetch", "init_performance", "init_performance", "error", "init_performance", "error", "init_performance", "error", "init_performance", "error", "init_performance", "error", "init_performance", "error", "env", "init_performance", "env", "init_performance", "env", "error", "init_performance", "env", "head", "env"]
}
